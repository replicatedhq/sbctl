{
  "metadata": {
    "resourceVersion": "27163"
  },
  "items": [
    {
      "metadata": {
        "name": "backingimagedatasources.longhorn.io",
        "uid": "1b57d184-e03e-4ddb-9d4f-1fee5854e8b5",
        "resourceVersion": "846",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "BackingImageDataSource"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"BackingImageDataSource\"},\"name\":\"backingimagedatasources.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"BackingImageDataSource\",\"listKind\":\"BackingImageDataSourceList\",\"plural\":\"backingimagedatasources\",\"shortNames\":[\"lhbids\"],\"singular\":\"backingimagedatasource\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The current state of the pod used to provisione the backing image file from source\",\"jsonPath\":\".status.currentState\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The data source type\",\"jsonPath\":\".spec.sourceType\",\"name\":\"SourceType\",\"type\":\"string\"},{\"description\":\"The node the backing image file will be prepared on\",\"jsonPath\":\".spec.nodeID\",\"name\":\"Node\",\"type\":\"string\"},{\"description\":\"The disk the backing image file will be prepared on\",\"jsonPath\":\".spec.diskUUID\",\"name\":\"DiskUUID\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "backingimagedatasources",
          "singular": "backingimagedatasource",
          "shortNames": [
            "lhbids"
          ],
          "kind": "BackingImageDataSource",
          "listKind": "BackingImageDataSourceList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The current state of the pod used to provisione the backing image file from source",
                "jsonPath": ".status.currentState"
              },
              {
                "name": "SourceType",
                "type": "string",
                "description": "The data source type",
                "jsonPath": ".spec.sourceType"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node the backing image file will be prepared on",
                "jsonPath": ".spec.nodeID"
              },
              {
                "name": "DiskUUID",
                "type": "string",
                "description": "The disk the backing image file will be prepared on",
                "jsonPath": ".spec.diskUUID"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backingimagedatasources",
          "singular": "backingimagedatasource",
          "shortNames": [
            "lhbids"
          ],
          "kind": "BackingImageDataSource",
          "listKind": "BackingImageDataSourceList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backingimagemanagers.longhorn.io",
        "uid": "0d7691d9-1fe6-4caf-bd44-29af476a6526",
        "resourceVersion": "843",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "BackingImageManager"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"BackingImageManager\"},\"name\":\"backingimagemanagers.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"BackingImageManager\",\"listKind\":\"BackingImageManagerList\",\"plural\":\"backingimagemanagers\",\"shortNames\":[\"lhbim\"],\"singular\":\"backingimagemanager\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The current state of the manager\",\"jsonPath\":\".status.currentState\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The image the manager pod will use\",\"jsonPath\":\".spec.image\",\"name\":\"Image\",\"type\":\"string\"},{\"description\":\"The node the manager is on\",\"jsonPath\":\".spec.nodeID\",\"name\":\"Node\",\"type\":\"string\"},{\"description\":\"The disk the manager is responsible for\",\"jsonPath\":\".spec.diskUUID\",\"name\":\"DiskUUID\",\"type\":\"string\"},{\"description\":\"The disk path the manager is using\",\"jsonPath\":\".spec.diskPath\",\"name\":\"DiskPath\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "backingimagemanagers",
          "singular": "backingimagemanager",
          "shortNames": [
            "lhbim"
          ],
          "kind": "BackingImageManager",
          "listKind": "BackingImageManagerList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The current state of the manager",
                "jsonPath": ".status.currentState"
              },
              {
                "name": "Image",
                "type": "string",
                "description": "The image the manager pod will use",
                "jsonPath": ".spec.image"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node the manager is on",
                "jsonPath": ".spec.nodeID"
              },
              {
                "name": "DiskUUID",
                "type": "string",
                "description": "The disk the manager is responsible for",
                "jsonPath": ".spec.diskUUID"
              },
              {
                "name": "DiskPath",
                "type": "string",
                "description": "The disk path the manager is using",
                "jsonPath": ".spec.diskPath"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backingimagemanagers",
          "singular": "backingimagemanager",
          "shortNames": [
            "lhbim"
          ],
          "kind": "BackingImageManager",
          "listKind": "BackingImageManagerList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backingimages.longhorn.io",
        "uid": "f10d23b9-dcb9-414a-9af0-0486330f7b1a",
        "resourceVersion": "840",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "BackingImage"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"BackingImage\"},\"name\":\"backingimages.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"BackingImage\",\"listKind\":\"BackingImageList\",\"plural\":\"backingimages\",\"shortNames\":[\"lhbi\"],\"singular\":\"backingimage\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The backing image name\",\"jsonPath\":\".spec.image\",\"name\":\"Image\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "backingimages",
          "singular": "backingimage",
          "shortNames": [
            "lhbi"
          ],
          "kind": "BackingImage",
          "listKind": "BackingImageList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "Image",
                "type": "string",
                "description": "The backing image name",
                "jsonPath": ".spec.image"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backingimages",
          "singular": "backingimage",
          "shortNames": [
            "lhbi"
          ],
          "kind": "BackingImage",
          "listKind": "BackingImageList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backups.longhorn.io",
        "uid": "6cd87494-22c3-4785-82aa-06f91beace2e",
        "resourceVersion": "855",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "Backup"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"Backup\"},\"name\":\"backups.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"Backup\",\"listKind\":\"BackupList\",\"plural\":\"backups\",\"shortNames\":[\"lhb\"],\"singular\":\"backup\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The snapshot name\",\"jsonPath\":\".status.snapshotName\",\"name\":\"SnapshotName\",\"type\":\"string\"},{\"description\":\"The snapshot size\",\"jsonPath\":\".status.size\",\"name\":\"SnapshotSize\",\"type\":\"string\"},{\"description\":\"The snapshot creation time\",\"jsonPath\":\".status.snapshotCreatedAt\",\"name\":\"SnapshotCreatedAt\",\"type\":\"string\"},{\"description\":\"The backup state\",\"jsonPath\":\".status.state\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The backup last synced time\",\"jsonPath\":\".status.lastSyncedAt\",\"name\":\"LastSyncedAt\",\"type\":\"string\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "backups",
          "singular": "backup",
          "shortNames": [
            "lhb"
          ],
          "kind": "Backup",
          "listKind": "BackupList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "SnapshotName",
                "type": "string",
                "description": "The snapshot name",
                "jsonPath": ".status.snapshotName"
              },
              {
                "name": "SnapshotSize",
                "type": "string",
                "description": "The snapshot size",
                "jsonPath": ".status.size"
              },
              {
                "name": "SnapshotCreatedAt",
                "type": "string",
                "description": "The snapshot creation time",
                "jsonPath": ".status.snapshotCreatedAt"
              },
              {
                "name": "State",
                "type": "string",
                "description": "The backup state",
                "jsonPath": ".status.state"
              },
              {
                "name": "LastSyncedAt",
                "type": "string",
                "description": "The backup last synced time",
                "jsonPath": ".status.lastSyncedAt"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backups",
          "singular": "backup",
          "shortNames": [
            "lhb"
          ],
          "kind": "Backup",
          "listKind": "BackupList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backups.velero.io",
        "uid": "f5df7f25-ea3d-458a-8300-77f2d9b70af1",
        "resourceVersion": "1840",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"backups.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"Backup\",\"listKind\":\"BackupList\",\"plural\":\"backups\",\"singular\":\"backup\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"Backup is a Velero resource that represents the capture of Kubernetes cluster state at a point in time (API objects and associated volume state).\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"BackupSpec defines the specification for a Velero backup.\",\"properties\":{\"defaultVolumesToRestic\":{\"description\":\"DefaultVolumesToRestic specifies whether restic should be used to take a backup of all pod volumes by default.\",\"type\":\"boolean\"},\"excludedNamespaces\":{\"description\":\"ExcludedNamespaces contains a list of namespaces that are not included in the backup.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"excludedResources\":{\"description\":\"ExcludedResources is a slice of resource names that are not included in the backup.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"hooks\":{\"description\":\"Hooks represent custom behaviors that should be executed at different phases of the backup.\",\"properties\":{\"resources\":{\"description\":\"Resources are hooks that should be executed when backing up individual instances of a resource.\",\"items\":{\"description\":\"BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.\",\"properties\":{\"excludedNamespaces\":{\"description\":\"ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"excludedResources\":{\"description\":\"ExcludedResources specifies the resources to which this hook spec does not apply.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedNamespaces\":{\"description\":\"IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedResources\":{\"description\":\"IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"labelSelector\":{\"description\":\"LabelSelector, if specified, filters the resources to which this hook spec applies.\",\"nullable\":true,\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"name\":{\"description\":\"Name is the name of this hook.\",\"type\":\"string\"},\"post\":{\"description\":\"PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all \\\"additional items\\\" from item actions are processed.\",\"items\":{\"description\":\"BackupResourceHook defines a hook for a resource.\",\"properties\":{\"exec\":{\"description\":\"Exec defines an exec hook.\",\"properties\":{\"command\":{\"description\":\"Command is the command and arguments to execute.\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"container\":{\"description\":\"Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.\",\"type\":\"string\"},\"onError\":{\"description\":\"OnError specifies how Velero should behave if it encounters an error executing this hook.\",\"enum\":[\"Continue\",\"Fail\"],\"type\":\"string\"},\"timeout\":{\"description\":\"Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.\",\"type\":\"string\"}},\"required\":[\"command\"],\"type\":\"object\"}},\"required\":[\"exec\"],\"type\":\"object\"},\"type\":\"array\"},\"pre\":{\"description\":\"PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any \\\"additional items\\\" from item actions are processed.\",\"items\":{\"description\":\"BackupResourceHook defines a hook for a resource.\",\"properties\":{\"exec\":{\"description\":\"Exec defines an exec hook.\",\"properties\":{\"command\":{\"description\":\"Command is the command and arguments to execute.\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"container\":{\"description\":\"Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.\",\"type\":\"string\"},\"onError\":{\"description\":\"OnError specifies how Velero should behave if it encounters an error executing this hook.\",\"enum\":[\"Continue\",\"Fail\"],\"type\":\"string\"},\"timeout\":{\"description\":\"Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.\",\"type\":\"string\"}},\"required\":[\"command\"],\"type\":\"object\"}},\"required\":[\"exec\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"name\"],\"type\":\"object\"},\"nullable\":true,\"type\":\"array\"}},\"type\":\"object\"},\"includeClusterResources\":{\"description\":\"IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.\",\"nullable\":true,\"type\":\"boolean\"},\"includedNamespaces\":{\"description\":\"IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedResources\":{\"description\":\"IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"labelSelector\":{\"description\":\"LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.\",\"nullable\":true,\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"metadata\":{\"properties\":{\"labels\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"},\"orderedResources\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"OrderedResources specifies the backup order of resources of specific Kind. The map key is the Kind name and value is a list of resource names separated by commas. Each resource name has format \\\"namespace/resourcename\\\".  For cluster resources, simply use \\\"resourcename\\\".\",\"nullable\":true,\"type\":\"object\"},\"snapshotVolumes\":{\"description\":\"SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.\",\"nullable\":true,\"type\":\"boolean\"},\"storageLocation\":{\"description\":\"StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.\",\"type\":\"string\"},\"ttl\":{\"description\":\"TTL is a time.Duration-parseable string describing how long the Backup should be retained for.\",\"type\":\"string\"},\"volumeSnapshotLocations\":{\"description\":\"VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"status\":{\"description\":\"BackupStatus captures the current status of a Velero backup.\",\"properties\":{\"completionTimestamp\":{\"description\":\"CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"errors\":{\"description\":\"Errors is a count of all error messages that were generated during execution of the backup.  The actual errors are in the backup's log file in object storage.\",\"type\":\"integer\"},\"expiration\":{\"description\":\"Expiration is when this Backup is eligible for garbage-collection.\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"formatVersion\":{\"description\":\"FormatVersion is the backup format version, including major, minor, and patch version.\",\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the Backup.\",\"enum\":[\"New\",\"FailedValidation\",\"InProgress\",\"Completed\",\"PartiallyFailed\",\"Failed\",\"Deleting\"],\"type\":\"string\"},\"progress\":{\"description\":\"Progress contains information about the backup's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a backup for any reason, it may be inaccurate/stale.\",\"nullable\":true,\"properties\":{\"itemsBackedUp\":{\"description\":\"ItemsBackedUp is the number of items that have actually been written to the backup tarball so far.\",\"type\":\"integer\"},\"totalItems\":{\"description\":\"TotalItems is the total number of items to be backed up. This number may change throughout the execution of the backup due to plugins that return additional related items to back up, the velero.io/exclude-from-backup label, and various other filters that happen as items are processed.\",\"type\":\"integer\"}},\"type\":\"object\"},\"startTimestamp\":{\"description\":\"StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"validationErrors\":{\"description\":\"ValidationErrors is a slice of all validation errors (if applicable).\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"version\":{\"description\":\"Version is the backup format major version. Deprecated: Please see FormatVersion\",\"type\":\"integer\"},\"volumeSnapshotsAttempted\":{\"description\":\"VolumeSnapshotsAttempted is the total number of attempted volume snapshots for this backup.\",\"type\":\"integer\"},\"volumeSnapshotsCompleted\":{\"description\":\"VolumeSnapshotsCompleted is the total number of successfully completed volume snapshots for this backup.\",\"type\":\"integer\"},\"warnings\":{\"description\":\"Warnings is a count of all warning messages that were generated during execution of the backup. The actual warnings are in the backup's log file in object storage.\",\"type\":\"integer\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "backups",
          "singular": "backup",
          "kind": "Backup",
          "listKind": "BackupList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "Backup is a Velero resource that represents the capture of Kubernetes cluster state at a point in time (API objects and associated volume state).",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "BackupSpec defines the specification for a Velero backup.",
                    "type": "object",
                    "properties": {
                      "defaultVolumesToRestic": {
                        "description": "DefaultVolumesToRestic specifies whether restic should be used to take a backup of all pod volumes by default.",
                        "type": "boolean"
                      },
                      "excludedNamespaces": {
                        "description": "ExcludedNamespaces contains a list of namespaces that are not included in the backup.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "excludedResources": {
                        "description": "ExcludedResources is a slice of resource names that are not included in the backup.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "hooks": {
                        "description": "Hooks represent custom behaviors that should be executed at different phases of the backup.",
                        "type": "object",
                        "properties": {
                          "resources": {
                            "description": "Resources are hooks that should be executed when backing up individual instances of a resource.",
                            "type": "array",
                            "items": {
                              "description": "BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.",
                              "type": "object",
                              "required": [
                                "name"
                              ],
                              "properties": {
                                "excludedNamespaces": {
                                  "description": "ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "excludedResources": {
                                  "description": "ExcludedResources specifies the resources to which this hook spec does not apply.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "includedNamespaces": {
                                  "description": "IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "includedResources": {
                                  "description": "IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "labelSelector": {
                                  "description": "LabelSelector, if specified, filters the resources to which this hook spec applies.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string"
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "nullable": true
                                },
                                "name": {
                                  "description": "Name is the name of this hook.",
                                  "type": "string"
                                },
                                "post": {
                                  "description": "PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all \"additional items\" from item actions are processed.",
                                  "type": "array",
                                  "items": {
                                    "description": "BackupResourceHook defines a hook for a resource.",
                                    "type": "object",
                                    "required": [
                                      "exec"
                                    ],
                                    "properties": {
                                      "exec": {
                                        "description": "Exec defines an exec hook.",
                                        "type": "object",
                                        "required": [
                                          "command"
                                        ],
                                        "properties": {
                                          "command": {
                                            "description": "Command is the command and arguments to execute.",
                                            "type": "array",
                                            "minItems": 1,
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "container": {
                                            "description": "Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.",
                                            "type": "string"
                                          },
                                          "onError": {
                                            "description": "OnError specifies how Velero should behave if it encounters an error executing this hook.",
                                            "type": "string",
                                            "enum": [
                                              "Continue",
                                              "Fail"
                                            ]
                                          },
                                          "timeout": {
                                            "description": "Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "pre": {
                                  "description": "PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any \"additional items\" from item actions are processed.",
                                  "type": "array",
                                  "items": {
                                    "description": "BackupResourceHook defines a hook for a resource.",
                                    "type": "object",
                                    "required": [
                                      "exec"
                                    ],
                                    "properties": {
                                      "exec": {
                                        "description": "Exec defines an exec hook.",
                                        "type": "object",
                                        "required": [
                                          "command"
                                        ],
                                        "properties": {
                                          "command": {
                                            "description": "Command is the command and arguments to execute.",
                                            "type": "array",
                                            "minItems": 1,
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "container": {
                                            "description": "Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.",
                                            "type": "string"
                                          },
                                          "onError": {
                                            "description": "OnError specifies how Velero should behave if it encounters an error executing this hook.",
                                            "type": "string",
                                            "enum": [
                                              "Continue",
                                              "Fail"
                                            ]
                                          },
                                          "timeout": {
                                            "description": "Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "nullable": true
                          }
                        }
                      },
                      "includeClusterResources": {
                        "description": "IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.",
                        "type": "boolean",
                        "nullable": true
                      },
                      "includedNamespaces": {
                        "description": "IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "includedResources": {
                        "description": "IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "labelSelector": {
                        "description": "LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        },
                        "nullable": true
                      },
                      "metadata": {
                        "type": "object",
                        "properties": {
                          "labels": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "orderedResources": {
                        "description": "OrderedResources specifies the backup order of resources of specific Kind. The map key is the Kind name and value is a list of resource names separated by commas. Each resource name has format \"namespace/resourcename\".  For cluster resources, simply use \"resourcename\".",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "snapshotVolumes": {
                        "description": "SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.",
                        "type": "boolean",
                        "nullable": true
                      },
                      "storageLocation": {
                        "description": "StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.",
                        "type": "string"
                      },
                      "ttl": {
                        "description": "TTL is a time.Duration-parseable string describing how long the Backup should be retained for.",
                        "type": "string"
                      },
                      "volumeSnapshotLocations": {
                        "description": "VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "BackupStatus captures the current status of a Velero backup.",
                    "type": "object",
                    "properties": {
                      "completionTimestamp": {
                        "description": "CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "errors": {
                        "description": "Errors is a count of all error messages that were generated during execution of the backup.  The actual errors are in the backup's log file in object storage.",
                        "type": "integer"
                      },
                      "expiration": {
                        "description": "Expiration is when this Backup is eligible for garbage-collection.",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "formatVersion": {
                        "description": "FormatVersion is the backup format version, including major, minor, and patch version.",
                        "type": "string"
                      },
                      "phase": {
                        "description": "Phase is the current state of the Backup.",
                        "type": "string",
                        "enum": [
                          "New",
                          "FailedValidation",
                          "InProgress",
                          "Completed",
                          "PartiallyFailed",
                          "Failed",
                          "Deleting"
                        ]
                      },
                      "progress": {
                        "description": "Progress contains information about the backup's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a backup for any reason, it may be inaccurate/stale.",
                        "type": "object",
                        "properties": {
                          "itemsBackedUp": {
                            "description": "ItemsBackedUp is the number of items that have actually been written to the backup tarball so far.",
                            "type": "integer"
                          },
                          "totalItems": {
                            "description": "TotalItems is the total number of items to be backed up. This number may change throughout the execution of the backup due to plugins that return additional related items to back up, the velero.io/exclude-from-backup label, and various other filters that happen as items are processed.",
                            "type": "integer"
                          }
                        },
                        "nullable": true
                      },
                      "startTimestamp": {
                        "description": "StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "validationErrors": {
                        "description": "ValidationErrors is a slice of all validation errors (if applicable).",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "version": {
                        "description": "Version is the backup format major version. Deprecated: Please see FormatVersion",
                        "type": "integer"
                      },
                      "volumeSnapshotsAttempted": {
                        "description": "VolumeSnapshotsAttempted is the total number of attempted volume snapshots for this backup.",
                        "type": "integer"
                      },
                      "volumeSnapshotsCompleted": {
                        "description": "VolumeSnapshotsCompleted is the total number of successfully completed volume snapshots for this backup.",
                        "type": "integer"
                      },
                      "warnings": {
                        "description": "Warnings is a count of all warning messages that were generated during execution of the backup. The actual warnings are in the backup's log file in object storage.",
                        "type": "integer"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backups",
          "singular": "backup",
          "kind": "Backup",
          "listKind": "BackupList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backupstoragelocations.velero.io",
        "uid": "658db799-c16a-49a6-a17a-123032a6320d",
        "resourceVersion": "1842",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"backupstoragelocations.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"BackupStorageLocation\",\"listKind\":\"BackupStorageLocationList\",\"plural\":\"backupstoragelocations\",\"shortNames\":[\"bsl\"],\"singular\":\"backupstoragelocation\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"Backup Storage Location status such as Available/Unavailable\",\"jsonPath\":\".status.phase\",\"name\":\"Phase\",\"type\":\"string\"},{\"description\":\"LastValidationTime is the last time the backup store location was validated\",\"jsonPath\":\".status.lastValidationTime\",\"name\":\"Last Validated\",\"type\":\"date\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"},{\"description\":\"Default backup storage location\",\"jsonPath\":\".spec.default\",\"name\":\"Default\",\"type\":\"boolean\"}],\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"BackupStorageLocation is a location where Velero stores backup objects\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"BackupStorageLocationSpec defines the desired state of a Velero BackupStorageLocation\",\"properties\":{\"accessMode\":{\"description\":\"AccessMode defines the permissions for the backup storage location.\",\"enum\":[\"ReadOnly\",\"ReadWrite\"],\"type\":\"string\"},\"backupSyncPeriod\":{\"description\":\"BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.\",\"nullable\":true,\"type\":\"string\"},\"config\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"Config is for provider-specific configuration fields.\",\"type\":\"object\"},\"credential\":{\"description\":\"Credential contains the credential information intended to be used with this location\",\"properties\":{\"key\":{\"description\":\"The key of the secret to select from.  Must be a valid secret key.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"},\"default\":{\"description\":\"Default indicates this location is the default backup storage location.\",\"type\":\"boolean\"},\"objectStorage\":{\"description\":\"ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.\",\"properties\":{\"bucket\":{\"description\":\"Bucket is the bucket to use for object storage.\",\"type\":\"string\"},\"caCert\":{\"description\":\"CACert defines a CA bundle to use when verifying TLS connections to the provider.\",\"format\":\"byte\",\"type\":\"string\"},\"prefix\":{\"description\":\"Prefix is the path inside a bucket to use for Velero storage. Optional.\",\"type\":\"string\"}},\"required\":[\"bucket\"],\"type\":\"object\"},\"provider\":{\"description\":\"Provider is the provider of the backup storage.\",\"type\":\"string\"},\"validationFrequency\":{\"description\":\"ValidationFrequency defines how frequently to validate the corresponding object storage. A value of 0 disables validation.\",\"nullable\":true,\"type\":\"string\"}},\"required\":[\"objectStorage\",\"provider\"],\"type\":\"object\"},\"status\":{\"description\":\"BackupStorageLocationStatus defines the observed state of BackupStorageLocation\",\"properties\":{\"accessMode\":{\"description\":\"AccessMode is an unused field. \\n Deprecated: there is now an AccessMode field on the Spec and this field will be removed entirely as of v2.0.\",\"enum\":[\"ReadOnly\",\"ReadWrite\"],\"type\":\"string\"},\"lastSyncedRevision\":{\"description\":\"LastSyncedRevision is the value of the `metadata/revision` file in the backup storage location the last time the BSL's contents were synced into the cluster. \\n Deprecated: this field is no longer updated or used for detecting changes to the location's contents and will be removed entirely in v2.0.\",\"type\":\"string\"},\"lastSyncedTime\":{\"description\":\"LastSyncedTime is the last time the contents of the location were synced into the cluster.\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"lastValidationTime\":{\"description\":\"LastValidationTime is the last time the backup store location was validated the cluster.\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the BackupStorageLocation.\",\"enum\":[\"Available\",\"Unavailable\"],\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "backupstoragelocations",
          "singular": "backupstoragelocation",
          "shortNames": [
            "bsl"
          ],
          "kind": "BackupStorageLocation",
          "listKind": "BackupStorageLocationList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "BackupStorageLocation is a location where Velero stores backup objects",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "BackupStorageLocationSpec defines the desired state of a Velero BackupStorageLocation",
                    "type": "object",
                    "required": [
                      "objectStorage",
                      "provider"
                    ],
                    "properties": {
                      "accessMode": {
                        "description": "AccessMode defines the permissions for the backup storage location.",
                        "type": "string",
                        "enum": [
                          "ReadOnly",
                          "ReadWrite"
                        ]
                      },
                      "backupSyncPeriod": {
                        "description": "BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.",
                        "type": "string",
                        "nullable": true
                      },
                      "config": {
                        "description": "Config is for provider-specific configuration fields.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "credential": {
                        "description": "Credential contains the credential information intended to be used with this location",
                        "type": "object",
                        "required": [
                          "key"
                        ],
                        "properties": {
                          "key": {
                            "description": "The key of the secret to select from.  Must be a valid secret key.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the Secret or its key must be defined",
                            "type": "boolean"
                          }
                        }
                      },
                      "default": {
                        "description": "Default indicates this location is the default backup storage location.",
                        "type": "boolean"
                      },
                      "objectStorage": {
                        "description": "ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.",
                        "type": "object",
                        "required": [
                          "bucket"
                        ],
                        "properties": {
                          "bucket": {
                            "description": "Bucket is the bucket to use for object storage.",
                            "type": "string"
                          },
                          "caCert": {
                            "description": "CACert defines a CA bundle to use when verifying TLS connections to the provider.",
                            "type": "string",
                            "format": "byte"
                          },
                          "prefix": {
                            "description": "Prefix is the path inside a bucket to use for Velero storage. Optional.",
                            "type": "string"
                          }
                        }
                      },
                      "provider": {
                        "description": "Provider is the provider of the backup storage.",
                        "type": "string"
                      },
                      "validationFrequency": {
                        "description": "ValidationFrequency defines how frequently to validate the corresponding object storage. A value of 0 disables validation.",
                        "type": "string",
                        "nullable": true
                      }
                    }
                  },
                  "status": {
                    "description": "BackupStorageLocationStatus defines the observed state of BackupStorageLocation",
                    "type": "object",
                    "properties": {
                      "accessMode": {
                        "description": "AccessMode is an unused field. \n Deprecated: there is now an AccessMode field on the Spec and this field will be removed entirely as of v2.0.",
                        "type": "string",
                        "enum": [
                          "ReadOnly",
                          "ReadWrite"
                        ]
                      },
                      "lastSyncedRevision": {
                        "description": "LastSyncedRevision is the value of the `metadata/revision` file in the backup storage location the last time the BSL's contents were synced into the cluster. \n Deprecated: this field is no longer updated or used for detecting changes to the location's contents and will be removed entirely in v2.0.",
                        "type": "string"
                      },
                      "lastSyncedTime": {
                        "description": "LastSyncedTime is the last time the contents of the location were synced into the cluster.",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "lastValidationTime": {
                        "description": "LastValidationTime is the last time the backup store location was validated the cluster.",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "phase": {
                        "description": "Phase is the current state of the BackupStorageLocation.",
                        "type": "string",
                        "enum": [
                          "Available",
                          "Unavailable"
                        ]
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "Phase",
                "type": "string",
                "description": "Backup Storage Location status such as Available/Unavailable",
                "jsonPath": ".status.phase"
              },
              {
                "name": "Last Validated",
                "type": "date",
                "description": "LastValidationTime is the last time the backup store location was validated",
                "jsonPath": ".status.lastValidationTime"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              },
              {
                "name": "Default",
                "type": "boolean",
                "description": "Default backup storage location",
                "jsonPath": ".spec.default"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backupstoragelocations",
          "singular": "backupstoragelocation",
          "shortNames": [
            "bsl"
          ],
          "kind": "BackupStorageLocation",
          "listKind": "BackupStorageLocationList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backuptargets.longhorn.io",
        "uid": "61aaff46-b551-490d-b8ac-35dd7efce732",
        "resourceVersion": "849",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "BackupTarget"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"BackupTarget\"},\"name\":\"backuptargets.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"BackupTarget\",\"listKind\":\"BackupTargetList\",\"plural\":\"backuptargets\",\"shortNames\":[\"lhbt\"],\"singular\":\"backuptarget\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The backup target URL\",\"jsonPath\":\".spec.backupTargetURL\",\"name\":\"URL\",\"type\":\"string\"},{\"description\":\"The backup target credential secret\",\"jsonPath\":\".spec.credentialSecret\",\"name\":\"Credential\",\"type\":\"string\"},{\"description\":\"The backup target poll interval\",\"jsonPath\":\".spec.pollInterval\",\"name\":\"Interval\",\"type\":\"string\"},{\"description\":\"Indicate whether the backup target is available or not\",\"jsonPath\":\".status.available\",\"name\":\"Available\",\"type\":\"boolean\"},{\"description\":\"The backup target last synced time\",\"jsonPath\":\".status.lastSyncedAt\",\"name\":\"LastSyncedAt\",\"type\":\"string\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "backuptargets",
          "singular": "backuptarget",
          "shortNames": [
            "lhbt"
          ],
          "kind": "BackupTarget",
          "listKind": "BackupTargetList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "URL",
                "type": "string",
                "description": "The backup target URL",
                "jsonPath": ".spec.backupTargetURL"
              },
              {
                "name": "Credential",
                "type": "string",
                "description": "The backup target credential secret",
                "jsonPath": ".spec.credentialSecret"
              },
              {
                "name": "Interval",
                "type": "string",
                "description": "The backup target poll interval",
                "jsonPath": ".spec.pollInterval"
              },
              {
                "name": "Available",
                "type": "boolean",
                "description": "Indicate whether the backup target is available or not",
                "jsonPath": ".status.available"
              },
              {
                "name": "LastSyncedAt",
                "type": "string",
                "description": "The backup target last synced time",
                "jsonPath": ".status.lastSyncedAt"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backuptargets",
          "singular": "backuptarget",
          "shortNames": [
            "lhbt"
          ],
          "kind": "BackupTarget",
          "listKind": "BackupTargetList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "backupvolumes.longhorn.io",
        "uid": "7fc91bb0-0bda-4a65-a327-825fb609ca55",
        "resourceVersion": "852",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "BackupVolume"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"BackupVolume\"},\"name\":\"backupvolumes.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"BackupVolume\",\"listKind\":\"BackupVolumeList\",\"plural\":\"backupvolumes\",\"shortNames\":[\"lhbv\"],\"singular\":\"backupvolume\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The backup volume creation time\",\"jsonPath\":\".status.createdAt\",\"name\":\"CreatedAt\",\"type\":\"string\"},{\"description\":\"The backup volume last backup name\",\"jsonPath\":\".status.lastBackupName\",\"name\":\"LastBackupName\",\"type\":\"string\"},{\"description\":\"The backup volume last backup time\",\"jsonPath\":\".status.lastBackupAt\",\"name\":\"LastBackupAt\",\"type\":\"string\"},{\"description\":\"The backup volume last synced time\",\"jsonPath\":\".status.lastSyncedAt\",\"name\":\"LastSyncedAt\",\"type\":\"string\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "backupvolumes",
          "singular": "backupvolume",
          "shortNames": [
            "lhbv"
          ],
          "kind": "BackupVolume",
          "listKind": "BackupVolumeList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "CreatedAt",
                "type": "string",
                "description": "The backup volume creation time",
                "jsonPath": ".status.createdAt"
              },
              {
                "name": "LastBackupName",
                "type": "string",
                "description": "The backup volume last backup name",
                "jsonPath": ".status.lastBackupName"
              },
              {
                "name": "LastBackupAt",
                "type": "string",
                "description": "The backup volume last backup time",
                "jsonPath": ".status.lastBackupAt"
              },
              {
                "name": "LastSyncedAt",
                "type": "string",
                "description": "The backup volume last synced time",
                "jsonPath": ".status.lastSyncedAt"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "backupvolumes",
          "singular": "backupvolume",
          "shortNames": [
            "lhbv"
          ],
          "kind": "BackupVolume",
          "listKind": "BackupVolumeList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "contourconfigurations.projectcontour.io",
        "uid": "a2a3fd03-ffb9-450a-ac60-88d8aed18600",
        "resourceVersion": "1523",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:42Z",
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.6.2",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.6.2\"},\"creationTimestamp\":null,\"name\":\"contourconfigurations.projectcontour.io\"},\"spec\":{\"group\":\"projectcontour.io\",\"names\":{\"kind\":\"ContourConfiguration\",\"listKind\":\"ContourConfigurationList\",\"plural\":\"contourconfigurations\",\"shortNames\":[\"contourconfig\"],\"singular\":\"contourconfiguration\"},\"preserveUnknownFields\":false,\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1alpha1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"ContourConfiguration is the schema for a Contour instance.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"ContourConfigurationSpec represents a configuration of a Contour controller. It contains most of all the options that can be customized, the other remaining options being command line flags.\",\"properties\":{\"debug\":{\"default\":{\"kubernetesLogLevel\":0,\"logLevel\":\"info\"},\"description\":\"Debug contains parameters to enable debug logging and debug interfaces inside Contour.\",\"properties\":{\"address\":{\"description\":\"Defines the Contour debug address interface.\",\"type\":\"string\"},\"kubernetesLogLevel\":{\"default\":0,\"description\":\"KubernetesDebugLogLevel defines the log level which Contour will use when outputting Kubernetes specific log information. \\n Details: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md\",\"maximum\":9,\"minimum\":0,\"type\":\"integer\"},\"logLevel\":{\"description\":\"DebugLogLevel defines the log level which Contour will use when outputting log information.\",\"enum\":[\"info\",\"debug\"],\"type\":\"string\"},\"port\":{\"description\":\"Defines the Contour debug address port.\",\"type\":\"integer\"}},\"required\":[\"logLevel\"],\"type\":\"object\"},\"enableExternalNameService\":{\"default\":false,\"description\":\"EnableExternalNameService allows processing of ExternalNameServices Defaults to disabled for security reasons.\",\"type\":\"boolean\"},\"envoy\":{\"default\":{\"cluster\":{\"dnsLookupFamily\":\"auto\"},\"defaultHTTPVersions\":[\"HTTP/1.1\",\"HTTP/2\"],\"health\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"http\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8080},\"https\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8443},\"listener\":{\"connectionBalancer\":\"\",\"disableAllowChunkedLength\":false,\"tls\":{\"cipherSuites\":[\"[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\",\"[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\",\"ECDHE-ECDSA-AES256-GCM-SHA384\",\"ECDHE-RSA-AES256-GCM-SHA384\"],\"minimumProtocolVersion\":\"1.2\"},\"useProxyProtocol\":false},\"logging\":{\"accessLogFormat\":\"envoy\"},\"metrics\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"network\":{\"adminPort\":9001},\"service\":{\"name\":\"envoy\",\"namespace\":\"projectcontour\"}},\"description\":\"Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.\",\"properties\":{\"clientCertificate\":{\"description\":\"ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"cluster\":{\"description\":\"Cluster holds various configurable Envoy cluster values that can be set in the config file.\",\"properties\":{\"dnsLookupFamily\":{\"default\":\"auto\",\"description\":\"DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. Note: This only applies to externalName clusters. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.\",\"enum\":[\"auto\",\"v4\",\"v6\"],\"type\":\"string\"}},\"required\":[\"dnsLookupFamily\"],\"type\":\"object\"},\"defaultHTTPVersions\":{\"description\":\"DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form \\\"HTTP/xx\\\". Supported versions are \\\"HTTP/1.1\\\" and \\\"HTTP/2\\\".\",\"items\":{\"description\":\"HTTPVersionType is the name of a supported HTTP version.\",\"enum\":[\"HTTP/1.1\",\"HTTP/2\"],\"type\":\"string\"},\"type\":\"array\"},\"health\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"description\":\"Health defines the endpoint Envoy uses to serve health checks.\",\"properties\":{\"address\":{\"description\":\"Defines the health address interface.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the health port.\",\"type\":\"integer\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"http\":{\"default\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8080},\"description\":\"Defines the HTTP Listener for Envoy.\",\"properties\":{\"accessLog\":{\"description\":\"AccessLog defines where Envoy logs are outputted for this listener.\",\"type\":\"string\"},\"address\":{\"description\":\"Defines an Envoy Listener Address.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines an Envoy listener Port.\",\"type\":\"integer\"}},\"required\":[\"accessLog\",\"address\",\"port\"],\"type\":\"object\"},\"https\":{\"default\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8443},\"description\":\"Defines the HTTP Listener for Envoy.\",\"properties\":{\"accessLog\":{\"description\":\"AccessLog defines where Envoy logs are outputted for this listener.\",\"type\":\"string\"},\"address\":{\"description\":\"Defines an Envoy Listener Address.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines an Envoy listener Port.\",\"type\":\"integer\"}},\"required\":[\"accessLog\",\"address\",\"port\"],\"type\":\"object\"},\"listener\":{\"description\":\"Listener hold various configurable Envoy listener values.\",\"properties\":{\"connectionBalancer\":{\"description\":\"ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.\",\"enum\":[\"\",\"exact\"],\"type\":\"string\"},\"disableAllowChunkedLength\":{\"description\":\"DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the \\\"Content-Length\\\" header if \\\"Transfer-Encoding: chunked\\\" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221\",\"type\":\"boolean\"},\"tls\":{\"description\":\"TLS holds various configurable Envoy TLS listener values.\",\"properties\":{\"cipherSuites\":{\"description\":\"CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use. \\n See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.\",\"items\":{\"enum\":[\"[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\",\"[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\",\"ECDHE-ECDSA-AES128-GCM-SHA256\",\"ECDHE-RSA-AES128-GCM-SHA256\",\"ECDHE-ECDSA-AES128-SHA\",\"ECDHE-RSA-AES128-SHA\",\"AES128-GCM-SHA256\",\"AES128-SHA\",\"ECDHE-ECDSA-AES256-GCM-SHA384\",\"ECDHE-RSA-AES256-GCM-SHA384\",\"ECDHE-ECDSA-AES256-SHA\",\"ECDHE-RSA-AES256-SHA\",\"AES256-GCM-SHA384\",\"AES256-SHA\"],\"type\":\"string\"},\"type\":\"array\"},\"minimumProtocolVersion\":{\"description\":\"MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`.\",\"enum\":[\"1.2\",\"1.3\"],\"type\":\"string\"}},\"required\":[\"cipherSuites\",\"minimumProtocolVersion\"],\"type\":\"object\"},\"useProxyProtocol\":{\"description\":\"Use PROXY protocol for all listeners.\",\"type\":\"boolean\"}},\"required\":[\"connectionBalancer\",\"disableAllowChunkedLength\",\"tls\",\"useProxyProtocol\"],\"type\":\"object\"},\"logging\":{\"description\":\"Logging defines how Envoy's logs can be configured.\",\"properties\":{\"accessLogFormat\":{\"description\":\"AccessLogFormat sets the global access log format. Valid options are 'envoy' or 'json'\",\"enum\":[\"envoy\",\"json\"],\"type\":\"string\"},\"accessLogFormatString\":{\"description\":\"AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.\",\"type\":\"string\"},\"jsonFields\":{\"description\":\"AccessLogFields sets the fields that JSON logging will output when AccessLogFormat is json.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"accessLogFormat\"],\"type\":\"object\"},\"metrics\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"description\":\"Metrics defines the endpoint Envoy uses to serve metrics.\",\"properties\":{\"address\":{\"description\":\"Defines the metrics address interface.\",\"maxLength\":253,\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the metrics port.\",\"type\":\"integer\"},\"tls\":{\"description\":\"TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.\",\"properties\":{\"caFile\":{\"description\":\"CA filename.\",\"type\":\"string\"},\"certFile\":{\"description\":\"Client certificate filename.\",\"type\":\"string\"},\"keyFile\":{\"description\":\"Client key filename.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"network\":{\"description\":\"Network holds various configurable Envoy network values.\",\"properties\":{\"adminPort\":{\"default\":9001,\"description\":\"Configure the port used to access the Envoy Admin interface. If configured to port \\\"0\\\" then the admin interface is disabled.\",\"type\":\"integer\"},\"numTrustedHops\":{\"description\":\"XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address. \\n See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"adminPort\"],\"type\":\"object\"},\"service\":{\"default\":{\"name\":\"envoy\",\"namespace\":\"projectcontour\"},\"description\":\"Service holds Envoy service parameters for setting Ingress status.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"timeouts\":{\"description\":\"Timeouts holds various configurable timeouts that can be set in the config file.\",\"properties\":{\"connectionIdleTimeout\":{\"description\":\"ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to \\\"infinity\\\" to disable the timeout entirely. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.\",\"type\":\"string\"},\"connectionShutdownGracePeriod\":{\"description\":\"ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.\",\"type\":\"string\"},\"delayedCloseTimeout\":{\"description\":\"DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection. \\n Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.\",\"type\":\"string\"},\"maxConnectionDuration\":{\"description\":\"MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to \\\"infinity\\\" for no max duration. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.\",\"type\":\"string\"},\"requestTimeout\":{\"description\":\"RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to \\\"infinity\\\" to disable the timeout entirely. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.\",\"type\":\"string\"},\"streamIdleTimeout\":{\"description\":\"StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to \\\"infinity\\\" to disable the timeout entirely. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"cluster\",\"defaultHTTPVersions\",\"http\",\"https\",\"listener\",\"logging\",\"metrics\",\"network\",\"service\"],\"type\":\"object\"},\"gateway\":{\"description\":\"Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.\",\"properties\":{\"controllerName\":{\"default\":\"projectcontour.io/projectcontour/contour\",\"description\":\"ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of \\\"projectcontour.io/\\u003cnamespace\\u003e/contour\\\". If unset, the gatewayclass controller will not be started.\",\"type\":\"string\"}},\"required\":[\"controllerName\"],\"type\":\"object\"},\"health\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8000},\"description\":\"Health defines the endpoints Contour uses to serve health checks.\",\"properties\":{\"address\":{\"description\":\"Defines the health address interface.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the health port.\",\"type\":\"integer\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"httpproxy\":{\"default\":{\"disablePermitInsecure\":false},\"description\":\"HTTPProxy defines parameters on HTTPProxy.\",\"properties\":{\"disablePermitInsecure\":{\"description\":\"DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.\",\"type\":\"boolean\"},\"fallbackCertificate\":{\"description\":\"FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"rootNamespaces\":{\"description\":\"Restrict Contour to searching these namespaces for root ingress routes.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"disablePermitInsecure\"],\"type\":\"object\"},\"ingress\":{\"description\":\"Ingress contains parameters for ingress options.\",\"properties\":{\"className\":{\"description\":\"Ingress Class Name Contour should use.\",\"type\":\"string\"},\"statusAddress\":{\"description\":\"Address to set in Ingress object status.\",\"type\":\"string\"}},\"type\":\"object\"},\"metrics\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8000},\"description\":\"Metrics defines the endpoint Contour uses to serve metrics.\",\"properties\":{\"address\":{\"description\":\"Defines the metrics address interface.\",\"maxLength\":253,\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the metrics port.\",\"type\":\"integer\"},\"tls\":{\"description\":\"TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.\",\"properties\":{\"caFile\":{\"description\":\"CA filename.\",\"type\":\"string\"},\"certFile\":{\"description\":\"Client certificate filename.\",\"type\":\"string\"},\"keyFile\":{\"description\":\"Client key filename.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"policy\":{\"description\":\"Policy specifies default policy applied if not overridden by the user\",\"properties\":{\"applyToIngress\":{\"description\":\"ApplyToIngress determines if the Policies will apply to ingress objects\",\"type\":\"boolean\"},\"requestHeaders\":{\"description\":\"RequestHeadersPolicy defines the request headers set/removed on all routes\",\"properties\":{\"remove\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"},\"responseHeaders\":{\"description\":\"ResponseHeadersPolicy defines the response headers set/removed on all routes\",\"properties\":{\"remove\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"}},\"type\":\"object\"},\"rateLimitService\":{\"description\":\"RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.\",\"properties\":{\"domain\":{\"description\":\"Domain is passed to the Rate Limit Service.\",\"type\":\"string\"},\"enableXRateLimitHeaders\":{\"description\":\"EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request. \\n ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\",\"type\":\"boolean\"},\"extensionService\":{\"description\":\"ExtensionService identifies the extension service defining the RLS.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"failOpen\":{\"description\":\"FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.\",\"type\":\"boolean\"}},\"required\":[\"domain\",\"enableXRateLimitHeaders\",\"failOpen\"],\"type\":\"object\"},\"xdsServer\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8001,\"tls\":{\"caFile\":\"/certs/ca.crt\",\"certFile\":\"/certs/tls.crt\",\"insecure\":false,\"keyFile\":\"/certs/tls.key\"},\"type\":\"contour\"},\"description\":\"XDSServer contains parameters for the xDS server.\",\"properties\":{\"address\":{\"description\":\"Defines the xDS gRPC API address which Contour will serve.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the xDS gRPC API port which Contour will serve.\",\"type\":\"integer\"},\"tls\":{\"description\":\"TLS holds TLS file config details.\",\"properties\":{\"caFile\":{\"description\":\"CA filename.\",\"type\":\"string\"},\"certFile\":{\"description\":\"Client certificate filename.\",\"type\":\"string\"},\"insecure\":{\"description\":\"Allow serving the xDS gRPC API without TLS.\",\"type\":\"boolean\"},\"keyFile\":{\"description\":\"Client key filename.\",\"type\":\"string\"}},\"required\":[\"insecure\"],\"type\":\"object\"},\"type\":{\"description\":\"Defines the XDSServer to use for `contour serve`.\",\"enum\":[\"contour\",\"envoy\"],\"type\":\"string\"}},\"required\":[\"address\",\"port\",\"type\"],\"type\":\"object\"}},\"type\":\"object\"},\"status\":{\"description\":\"ContourConfigurationStatus defines the observed state of a ContourConfiguration resource.\",\"properties\":{\"conditions\":{\"description\":\"Conditions contains the current status of the Contour resource. \\n Contour will update a single condition, `Valid`, that is in normal-true polarity. \\n Contour will not modify any other Conditions set in this block, in case some other controller wants to add a Condition.\",\"items\":{\"description\":\"DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \\n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \\n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \\n Remember that Conditions have a type, a status, and a reason. \\n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \\n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \\n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \\n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \\n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.\",\"properties\":{\"errors\":{\"description\":\"Errors contains a slice of relevant error subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"lastTransitionTime\":{\"description\":\"lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.\",\"format\":\"date-time\",\"type\":\"string\"},\"message\":{\"description\":\"message is a human readable message indicating details about the transition. This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"observedGeneration\":{\"description\":\"observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"},\"reason\":{\"description\":\"reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"},\"warnings\":{\"description\":\"Warnings contains a slice of relevant warning subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"lastTransitionTime\",\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-map-keys\":[\"type\"],\"x-kubernetes-list-type\":\"map\"}},\"type\":\"object\"}},\"required\":[\"spec\"],\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]},\"status\":{\"acceptedNames\":{\"kind\":\"\",\"plural\":\"\"},\"conditions\":[],\"storedVersions\":[]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "projectcontour.io",
        "names": {
          "plural": "contourconfigurations",
          "singular": "contourconfiguration",
          "shortNames": [
            "contourconfig"
          ],
          "kind": "ContourConfiguration",
          "listKind": "ContourConfigurationList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1alpha1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "ContourConfiguration is the schema for a Contour instance.",
                "type": "object",
                "required": [
                  "spec"
                ],
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "ContourConfigurationSpec represents a configuration of a Contour controller. It contains most of all the options that can be customized, the other remaining options being command line flags.",
                    "type": "object",
                    "properties": {
                      "debug": {
                        "description": "Debug contains parameters to enable debug logging and debug interfaces inside Contour.",
                        "type": "object",
                        "default": {
                          "kubernetesLogLevel": 0,
                          "logLevel": "info"
                        },
                        "required": [
                          "logLevel"
                        ],
                        "properties": {
                          "address": {
                            "description": "Defines the Contour debug address interface.",
                            "type": "string"
                          },
                          "kubernetesLogLevel": {
                            "description": "KubernetesDebugLogLevel defines the log level which Contour will use when outputting Kubernetes specific log information. \n Details: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md",
                            "type": "integer",
                            "default": 0,
                            "maximum": 9,
                            "minimum": 0
                          },
                          "logLevel": {
                            "description": "DebugLogLevel defines the log level which Contour will use when outputting log information.",
                            "type": "string",
                            "enum": [
                              "info",
                              "debug"
                            ]
                          },
                          "port": {
                            "description": "Defines the Contour debug address port.",
                            "type": "integer"
                          }
                        }
                      },
                      "enableExternalNameService": {
                        "description": "EnableExternalNameService allows processing of ExternalNameServices Defaults to disabled for security reasons.",
                        "type": "boolean",
                        "default": false
                      },
                      "envoy": {
                        "description": "Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.",
                        "type": "object",
                        "default": {
                          "cluster": {
                            "dnsLookupFamily": "auto"
                          },
                          "defaultHTTPVersions": [
                            "HTTP/1.1",
                            "HTTP/2"
                          ],
                          "health": {
                            "address": "***HIDDEN***",
                            "port": 8002
                          },
                          "http": {
                            "accessLog": "/dev/stdout",
                            "address": "***HIDDEN***",
                            "port": 8080
                          },
                          "https": {
                            "accessLog": "/dev/stdout",
                            "address": "***HIDDEN***",
                            "port": 8443
                          },
                          "listener": {
                            "connectionBalancer": "",
                            "disableAllowChunkedLength": false,
                            "tls": {
                              "cipherSuites": [
                                "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]",
                                "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]",
                                "ECDHE-ECDSA-AES256-GCM-SHA384",
                                "ECDHE-RSA-AES256-GCM-SHA384"
                              ],
                              "minimumProtocolVersion": "1.2"
                            },
                            "useProxyProtocol": false
                          },
                          "logging": {
                            "accessLogFormat": "envoy"
                          },
                          "metrics": {
                            "address": "***HIDDEN***",
                            "port": 8002
                          },
                          "network": {
                            "adminPort": 9001
                          },
                          "service": {
                            "name": "envoy",
                            "namespace": "projectcontour"
                          }
                        },
                        "required": [
                          "cluster",
                          "defaultHTTPVersions",
                          "http",
                          "https",
                          "listener",
                          "logging",
                          "metrics",
                          "network",
                          "service"
                        ],
                        "properties": {
                          "clientCertificate": {
                            "description": "ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.",
                            "type": "object",
                            "required": [
                              "name",
                              "namespace"
                            ],
                            "properties": {
                              "name": {
                                "type": "string"
                              },
                              "namespace": {
                                "type": "string"
                              }
                            }
                          },
                          "cluster": {
                            "description": "Cluster holds various configurable Envoy cluster values that can be set in the config file.",
                            "type": "object",
                            "required": [
                              "dnsLookupFamily"
                            ],
                            "properties": {
                              "dnsLookupFamily": {
                                "description": "DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. Note: This only applies to externalName clusters. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.",
                                "type": "string",
                                "default": "auto",
                                "enum": [
                                  "auto",
                                  "v4",
                                  "v6"
                                ]
                              }
                            }
                          },
                          "defaultHTTPVersions": {
                            "description": "DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form \"HTTP/xx\". Supported versions are \"HTTP/1.1\" and \"HTTP/2\".",
                            "type": "array",
                            "items": {
                              "description": "HTTPVersionType is the name of a supported HTTP version.",
                              "type": "string",
                              "enum": [
                                "HTTP/1.1",
                                "HTTP/2"
                              ]
                            }
                          },
                          "health": {
                            "description": "Health defines the endpoint Envoy uses to serve health checks.",
                            "type": "object",
                            "default": {
                              "address": "***HIDDEN***",
                              "port": 8002
                            },
                            "required": [
                              "address",
                              "port"
                            ],
                            "properties": {
                              "address": {
                                "description": "Defines the health address interface.",
                                "type": "string",
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines the health port.",
                                "type": "integer"
                              }
                            }
                          },
                          "http": {
                            "description": "Defines the HTTP Listener for Envoy.",
                            "type": "object",
                            "default": {
                              "accessLog": "/dev/stdout",
                              "address": "***HIDDEN***",
                              "port": 8080
                            },
                            "required": [
                              "accessLog",
                              "address",
                              "port"
                            ],
                            "properties": {
                              "accessLog": {
                                "description": "AccessLog defines where Envoy logs are outputted for this listener.",
                                "type": "string"
                              },
                              "address": {
                                "description": "Defines an Envoy Listener Address.",
                                "type": "string",
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines an Envoy listener Port.",
                                "type": "integer"
                              }
                            }
                          },
                          "https": {
                            "description": "Defines the HTTP Listener for Envoy.",
                            "type": "object",
                            "default": {
                              "accessLog": "/dev/stdout",
                              "address": "***HIDDEN***",
                              "port": 8443
                            },
                            "required": [
                              "accessLog",
                              "address",
                              "port"
                            ],
                            "properties": {
                              "accessLog": {
                                "description": "AccessLog defines where Envoy logs are outputted for this listener.",
                                "type": "string"
                              },
                              "address": {
                                "description": "Defines an Envoy Listener Address.",
                                "type": "string",
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines an Envoy listener Port.",
                                "type": "integer"
                              }
                            }
                          },
                          "listener": {
                            "description": "Listener hold various configurable Envoy listener values.",
                            "type": "object",
                            "required": [
                              "connectionBalancer",
                              "disableAllowChunkedLength",
                              "tls",
                              "useProxyProtocol"
                            ],
                            "properties": {
                              "connectionBalancer": {
                                "description": "ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.",
                                "type": "string",
                                "enum": [
                                  "",
                                  "exact"
                                ]
                              },
                              "disableAllowChunkedLength": {
                                "description": "DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the \"Content-Length\" header if \"Transfer-Encoding: chunked\" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221",
                                "type": "boolean"
                              },
                              "tls": {
                                "description": "TLS holds various configurable Envoy TLS listener values.",
                                "type": "object",
                                "required": [
                                  "cipherSuites",
                                  "minimumProtocolVersion"
                                ],
                                "properties": {
                                  "cipherSuites": {
                                    "description": "CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use. \n See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.",
                                    "type": "array",
                                    "items": {
                                      "type": "string",
                                      "enum": [
                                        "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]",
                                        "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]",
                                        "ECDHE-ECDSA-AES128-GCM-SHA256",
                                        "ECDHE-RSA-AES128-GCM-SHA256",
                                        "ECDHE-ECDSA-AES128-SHA",
                                        "ECDHE-RSA-AES128-SHA",
                                        "AES128-GCM-SHA256",
                                        "AES128-SHA",
                                        "ECDHE-ECDSA-AES256-GCM-SHA384",
                                        "ECDHE-RSA-AES256-GCM-SHA384",
                                        "ECDHE-ECDSA-AES256-SHA",
                                        "ECDHE-RSA-AES256-SHA",
                                        "AES256-GCM-SHA384",
                                        "AES256-SHA"
                                      ]
                                    }
                                  },
                                  "minimumProtocolVersion": {
                                    "description": "MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`.",
                                    "type": "string",
                                    "enum": [
                                      "1.2",
                                      "1.3"
                                    ]
                                  }
                                }
                              },
                              "useProxyProtocol": {
                                "description": "Use PROXY protocol for all listeners.",
                                "type": "boolean"
                              }
                            }
                          },
                          "logging": {
                            "description": "Logging defines how Envoy's logs can be configured.",
                            "type": "object",
                            "required": [
                              "accessLogFormat"
                            ],
                            "properties": {
                              "accessLogFormat": {
                                "description": "AccessLogFormat sets the global access log format. Valid options are 'envoy' or 'json'",
                                "type": "string",
                                "enum": [
                                  "envoy",
                                  "json"
                                ]
                              },
                              "accessLogFormatString": {
                                "description": "AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.",
                                "type": "string"
                              },
                              "jsonFields": {
                                "description": "AccessLogFields sets the fields that JSON logging will output when AccessLogFormat is json.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "metrics": {
                            "description": "Metrics defines the endpoint Envoy uses to serve metrics.",
                            "type": "object",
                            "default": {
                              "address": "***HIDDEN***",
                              "port": 8002
                            },
                            "required": [
                              "address",
                              "port"
                            ],
                            "properties": {
                              "address": {
                                "description": "Defines the metrics address interface.",
                                "type": "string",
                                "maxLength": 253,
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines the metrics port.",
                                "type": "integer"
                              },
                              "tls": {
                                "description": "TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.",
                                "type": "object",
                                "properties": {
                                  "caFile": {
                                    "description": "CA filename.",
                                    "type": "string"
                                  },
                                  "certFile": {
                                    "description": "Client certificate filename.",
                                    "type": "string"
                                  },
                                  "keyFile": {
                                    "description": "Client key filename.",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "network": {
                            "description": "Network holds various configurable Envoy network values.",
                            "type": "object",
                            "required": [
                              "adminPort"
                            ],
                            "properties": {
                              "adminPort": {
                                "description": "Configure the port used to access the Envoy Admin interface. If configured to port \"0\" then the admin interface is disabled.",
                                "type": "integer",
                                "default": 9001
                              },
                              "numTrustedHops": {
                                "description": "XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address. \n See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "service": {
                            "description": "Service holds Envoy service parameters for setting Ingress status.",
                            "type": "object",
                            "default": {
                              "name": "envoy",
                              "namespace": "projectcontour"
                            },
                            "required": [
                              "name",
                              "namespace"
                            ],
                            "properties": {
                              "name": {
                                "type": "string"
                              },
                              "namespace": {
                                "type": "string"
                              }
                            }
                          },
                          "timeouts": {
                            "description": "Timeouts holds various configurable timeouts that can be set in the config file.",
                            "type": "object",
                            "properties": {
                              "connectionIdleTimeout": {
                                "description": "ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to \"infinity\" to disable the timeout entirely. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.",
                                "type": "string"
                              },
                              "connectionShutdownGracePeriod": {
                                "description": "ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.",
                                "type": "string"
                              },
                              "delayedCloseTimeout": {
                                "description": "DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection. \n Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.",
                                "type": "string"
                              },
                              "maxConnectionDuration": {
                                "description": "MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to \"infinity\" for no max duration. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.",
                                "type": "string"
                              },
                              "requestTimeout": {
                                "description": "RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to \"infinity\" to disable the timeout entirely. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.",
                                "type": "string"
                              },
                              "streamIdleTimeout": {
                                "description": "StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to \"infinity\" to disable the timeout entirely. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "gateway": {
                        "description": "Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.",
                        "type": "object",
                        "required": [
                          "controllerName"
                        ],
                        "properties": {
                          "controllerName": {
                            "description": "ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of \"projectcontour.io/\u003cnamespace\u003e/contour\". If unset, the gatewayclass controller will not be started.",
                            "type": "string",
                            "default": "projectcontour.io/projectcontour/contour"
                          }
                        }
                      },
                      "health": {
                        "description": "Health defines the endpoints Contour uses to serve health checks.",
                        "type": "object",
                        "default": {
                          "address": "***HIDDEN***",
                          "port": 8000
                        },
                        "required": [
                          "address",
                          "port"
                        ],
                        "properties": {
                          "address": {
                            "description": "Defines the health address interface.",
                            "type": "string",
                            "minLength": 1
                          },
                          "port": {
                            "description": "Defines the health port.",
                            "type": "integer"
                          }
                        }
                      },
                      "httpproxy": {
                        "description": "HTTPProxy defines parameters on HTTPProxy.",
                        "type": "object",
                        "default": {
                          "disablePermitInsecure": false
                        },
                        "required": [
                          "disablePermitInsecure"
                        ],
                        "properties": {
                          "disablePermitInsecure": {
                            "description": "DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.",
                            "type": "boolean"
                          },
                          "fallbackCertificate": {
                            "description": "FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.",
                            "type": "object",
                            "required": [
                              "name",
                              "namespace"
                            ],
                            "properties": {
                              "name": {
                                "type": "string"
                              },
                              "namespace": {
                                "type": "string"
                              }
                            }
                          },
                          "rootNamespaces": {
                            "description": "Restrict Contour to searching these namespaces for root ingress routes.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "ingress": {
                        "description": "Ingress contains parameters for ingress options.",
                        "type": "object",
                        "properties": {
                          "className": {
                            "description": "Ingress Class Name Contour should use.",
                            "type": "string"
                          },
                          "statusAddress": {
                            "description": "Address to set in Ingress object status.",
                            "type": "string"
                          }
                        }
                      },
                      "metrics": {
                        "description": "Metrics defines the endpoint Contour uses to serve metrics.",
                        "type": "object",
                        "default": {
                          "address": "***HIDDEN***",
                          "port": 8000
                        },
                        "required": [
                          "address",
                          "port"
                        ],
                        "properties": {
                          "address": {
                            "description": "Defines the metrics address interface.",
                            "type": "string",
                            "maxLength": 253,
                            "minLength": 1
                          },
                          "port": {
                            "description": "Defines the metrics port.",
                            "type": "integer"
                          },
                          "tls": {
                            "description": "TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.",
                            "type": "object",
                            "properties": {
                              "caFile": {
                                "description": "CA filename.",
                                "type": "string"
                              },
                              "certFile": {
                                "description": "Client certificate filename.",
                                "type": "string"
                              },
                              "keyFile": {
                                "description": "Client key filename.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "policy": {
                        "description": "Policy specifies default policy applied if not overridden by the user",
                        "type": "object",
                        "properties": {
                          "applyToIngress": {
                            "description": "ApplyToIngress determines if the Policies will apply to ingress objects",
                            "type": "boolean"
                          },
                          "requestHeaders": {
                            "description": "RequestHeadersPolicy defines the request headers set/removed on all routes",
                            "type": "object",
                            "properties": {
                              "remove": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "set": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "responseHeaders": {
                            "description": "ResponseHeadersPolicy defines the response headers set/removed on all routes",
                            "type": "object",
                            "properties": {
                              "remove": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "set": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      },
                      "rateLimitService": {
                        "description": "RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.",
                        "type": "object",
                        "required": [
                          "domain",
                          "enableXRateLimitHeaders",
                          "failOpen"
                        ],
                        "properties": {
                          "domain": {
                            "description": "Domain is passed to the Rate Limit Service.",
                            "type": "string"
                          },
                          "enableXRateLimitHeaders": {
                            "description": "EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request. \n ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html",
                            "type": "boolean"
                          },
                          "extensionService": {
                            "description": "ExtensionService identifies the extension service defining the RLS.",
                            "type": "object",
                            "required": [
                              "name",
                              "namespace"
                            ],
                            "properties": {
                              "name": {
                                "type": "string"
                              },
                              "namespace": {
                                "type": "string"
                              }
                            }
                          },
                          "failOpen": {
                            "description": "FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.",
                            "type": "boolean"
                          }
                        }
                      },
                      "xdsServer": {
                        "description": "XDSServer contains parameters for the xDS server.",
                        "type": "object",
                        "default": {
                          "address": "***HIDDEN***",
                          "port": 8001,
                          "tls": {
                            "caFile": "/certs/ca.crt",
                            "certFile": "/certs/tls.crt",
                            "insecure": false,
                            "keyFile": "/certs/tls.key"
                          },
                          "type": "contour"
                        },
                        "required": [
                          "address",
                          "port",
                          "type"
                        ],
                        "properties": {
                          "address": {
                            "description": "Defines the xDS gRPC API address which Contour will serve.",
                            "type": "string",
                            "minLength": 1
                          },
                          "port": {
                            "description": "Defines the xDS gRPC API port which Contour will serve.",
                            "type": "integer"
                          },
                          "tls": {
                            "description": "TLS holds TLS file config details.",
                            "type": "object",
                            "required": [
                              "insecure"
                            ],
                            "properties": {
                              "caFile": {
                                "description": "CA filename.",
                                "type": "string"
                              },
                              "certFile": {
                                "description": "Client certificate filename.",
                                "type": "string"
                              },
                              "insecure": {
                                "description": "Allow serving the xDS gRPC API without TLS.",
                                "type": "boolean"
                              },
                              "keyFile": {
                                "description": "Client key filename.",
                                "type": "string"
                              }
                            }
                          },
                          "type": {
                            "description": "Defines the XDSServer to use for `contour serve`.",
                            "type": "string",
                            "enum": [
                              "contour",
                              "envoy"
                            ]
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "ContourConfigurationStatus defines the observed state of a ContourConfiguration resource.",
                    "type": "object",
                    "properties": {
                      "conditions": {
                        "description": "Conditions contains the current status of the Contour resource. \n Contour will update a single condition, `Valid`, that is in normal-true polarity. \n Contour will not modify any other Conditions set in this block, in case some other controller wants to add a Condition.",
                        "type": "array",
                        "items": {
                          "description": "DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \n Remember that Conditions have a type, a status, and a reason. \n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.",
                          "type": "object",
                          "required": [
                            "lastTransitionTime",
                            "message",
                            "reason",
                            "status",
                            "type"
                          ],
                          "properties": {
                            "errors": {
                              "description": "Errors contains a slice of relevant error subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            },
                            "lastTransitionTime": {
                              "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                              "type": "string",
                              "format": "date-time"
                            },
                            "message": {
                              "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                              "type": "string",
                              "maxLength": 32768
                            },
                            "observedGeneration": {
                              "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                              "type": "integer",
                              "format": "int64",
                              "minimum": 0
                            },
                            "reason": {
                              "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                              "type": "string",
                              "maxLength": 1024,
                              "minLength": 1,
                              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                            },
                            "status": {
                              "description": "status of the condition, one of True, False, Unknown.",
                              "type": "string",
                              "enum": [
                                "True",
                                "False",
                                "Unknown"
                              ]
                            },
                            "type": {
                              "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                              "type": "string",
                              "maxLength": 316,
                              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                            },
                            "warnings": {
                              "description": "Warnings contains a slice of relevant warning subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "type"
                        ],
                        "x-kubernetes-list-type": "map"
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "contourconfigurations",
          "singular": "contourconfiguration",
          "shortNames": [
            "contourconfig"
          ],
          "kind": "ContourConfiguration",
          "listKind": "ContourConfigurationList"
        },
        "storedVersions": [
          "v1alpha1"
        ]
      }
    },
    {
      "metadata": {
        "name": "contourdeployments.projectcontour.io",
        "uid": "eb52810d-dde0-4175-9db1-ff0178f9d1dc",
        "resourceVersion": "1526",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:42Z",
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.6.2",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.6.2\"},\"creationTimestamp\":null,\"name\":\"contourdeployments.projectcontour.io\"},\"spec\":{\"group\":\"projectcontour.io\",\"names\":{\"kind\":\"ContourDeployment\",\"listKind\":\"ContourDeploymentList\",\"plural\":\"contourdeployments\",\"shortNames\":[\"contourdeploy\"],\"singular\":\"contourdeployment\"},\"preserveUnknownFields\":false,\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1alpha1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"ContourDeployment is the schema for a Contour Deployment.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"ContourDeploymentSpec defines the parameters of how a Contour instance should be configured.\",\"properties\":{\"config\":{\"description\":\"Config is the config that the instances of Contour are to utilize.\",\"properties\":{\"debug\":{\"default\":{\"kubernetesLogLevel\":0,\"logLevel\":\"info\"},\"description\":\"Debug contains parameters to enable debug logging and debug interfaces inside Contour.\",\"properties\":{\"address\":{\"description\":\"Defines the Contour debug address interface.\",\"type\":\"string\"},\"kubernetesLogLevel\":{\"default\":0,\"description\":\"KubernetesDebugLogLevel defines the log level which Contour will use when outputting Kubernetes specific log information. \\n Details: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md\",\"maximum\":9,\"minimum\":0,\"type\":\"integer\"},\"logLevel\":{\"description\":\"DebugLogLevel defines the log level which Contour will use when outputting log information.\",\"enum\":[\"info\",\"debug\"],\"type\":\"string\"},\"port\":{\"description\":\"Defines the Contour debug address port.\",\"type\":\"integer\"}},\"required\":[\"logLevel\"],\"type\":\"object\"},\"enableExternalNameService\":{\"default\":false,\"description\":\"EnableExternalNameService allows processing of ExternalNameServices Defaults to disabled for security reasons.\",\"type\":\"boolean\"},\"envoy\":{\"default\":{\"cluster\":{\"dnsLookupFamily\":\"auto\"},\"defaultHTTPVersions\":[\"HTTP/1.1\",\"HTTP/2\"],\"health\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"http\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8080},\"https\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8443},\"listener\":{\"connectionBalancer\":\"\",\"disableAllowChunkedLength\":false,\"tls\":{\"cipherSuites\":[\"[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\",\"[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\",\"ECDHE-ECDSA-AES256-GCM-SHA384\",\"ECDHE-RSA-AES256-GCM-SHA384\"],\"minimumProtocolVersion\":\"1.2\"},\"useProxyProtocol\":false},\"logging\":{\"accessLogFormat\":\"envoy\"},\"metrics\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"network\":{\"adminPort\":9001},\"service\":{\"name\":\"envoy\",\"namespace\":\"projectcontour\"}},\"description\":\"Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.\",\"properties\":{\"clientCertificate\":{\"description\":\"ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"cluster\":{\"description\":\"Cluster holds various configurable Envoy cluster values that can be set in the config file.\",\"properties\":{\"dnsLookupFamily\":{\"default\":\"auto\",\"description\":\"DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. Note: This only applies to externalName clusters. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.\",\"enum\":[\"auto\",\"v4\",\"v6\"],\"type\":\"string\"}},\"required\":[\"dnsLookupFamily\"],\"type\":\"object\"},\"defaultHTTPVersions\":{\"description\":\"DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form \\\"HTTP/xx\\\". Supported versions are \\\"HTTP/1.1\\\" and \\\"HTTP/2\\\".\",\"items\":{\"description\":\"HTTPVersionType is the name of a supported HTTP version.\",\"enum\":[\"HTTP/1.1\",\"HTTP/2\"],\"type\":\"string\"},\"type\":\"array\"},\"health\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"description\":\"Health defines the endpoint Envoy uses to serve health checks.\",\"properties\":{\"address\":{\"description\":\"Defines the health address interface.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the health port.\",\"type\":\"integer\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"http\":{\"default\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8080},\"description\":\"Defines the HTTP Listener for Envoy.\",\"properties\":{\"accessLog\":{\"description\":\"AccessLog defines where Envoy logs are outputted for this listener.\",\"type\":\"string\"},\"address\":{\"description\":\"Defines an Envoy Listener Address.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines an Envoy listener Port.\",\"type\":\"integer\"}},\"required\":[\"accessLog\",\"address\",\"port\"],\"type\":\"object\"},\"https\":{\"default\":{\"accessLog\":\"/dev/stdout\",\"address\":\"***HIDDEN***\",\"port\":8443},\"description\":\"Defines the HTTP Listener for Envoy.\",\"properties\":{\"accessLog\":{\"description\":\"AccessLog defines where Envoy logs are outputted for this listener.\",\"type\":\"string\"},\"address\":{\"description\":\"Defines an Envoy Listener Address.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines an Envoy listener Port.\",\"type\":\"integer\"}},\"required\":[\"accessLog\",\"address\",\"port\"],\"type\":\"object\"},\"listener\":{\"description\":\"Listener hold various configurable Envoy listener values.\",\"properties\":{\"connectionBalancer\":{\"description\":\"ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.\",\"enum\":[\"\",\"exact\"],\"type\":\"string\"},\"disableAllowChunkedLength\":{\"description\":\"DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the \\\"Content-Length\\\" header if \\\"Transfer-Encoding: chunked\\\" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221\",\"type\":\"boolean\"},\"tls\":{\"description\":\"TLS holds various configurable Envoy TLS listener values.\",\"properties\":{\"cipherSuites\":{\"description\":\"CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use. \\n See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.\",\"items\":{\"enum\":[\"[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]\",\"[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]\",\"ECDHE-ECDSA-AES128-GCM-SHA256\",\"ECDHE-RSA-AES128-GCM-SHA256\",\"ECDHE-ECDSA-AES128-SHA\",\"ECDHE-RSA-AES128-SHA\",\"AES128-GCM-SHA256\",\"AES128-SHA\",\"ECDHE-ECDSA-AES256-GCM-SHA384\",\"ECDHE-RSA-AES256-GCM-SHA384\",\"ECDHE-ECDSA-AES256-SHA\",\"ECDHE-RSA-AES256-SHA\",\"AES256-GCM-SHA384\",\"AES256-SHA\"],\"type\":\"string\"},\"type\":\"array\"},\"minimumProtocolVersion\":{\"description\":\"MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`.\",\"enum\":[\"1.2\",\"1.3\"],\"type\":\"string\"}},\"required\":[\"cipherSuites\",\"minimumProtocolVersion\"],\"type\":\"object\"},\"useProxyProtocol\":{\"description\":\"Use PROXY protocol for all listeners.\",\"type\":\"boolean\"}},\"required\":[\"connectionBalancer\",\"disableAllowChunkedLength\",\"tls\",\"useProxyProtocol\"],\"type\":\"object\"},\"logging\":{\"description\":\"Logging defines how Envoy's logs can be configured.\",\"properties\":{\"accessLogFormat\":{\"description\":\"AccessLogFormat sets the global access log format. Valid options are 'envoy' or 'json'\",\"enum\":[\"envoy\",\"json\"],\"type\":\"string\"},\"accessLogFormatString\":{\"description\":\"AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.\",\"type\":\"string\"},\"jsonFields\":{\"description\":\"AccessLogFields sets the fields that JSON logging will output when AccessLogFormat is json.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"accessLogFormat\"],\"type\":\"object\"},\"metrics\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8002},\"description\":\"Metrics defines the endpoint Envoy uses to serve metrics.\",\"properties\":{\"address\":{\"description\":\"Defines the metrics address interface.\",\"maxLength\":253,\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the metrics port.\",\"type\":\"integer\"},\"tls\":{\"description\":\"TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.\",\"properties\":{\"caFile\":{\"description\":\"CA filename.\",\"type\":\"string\"},\"certFile\":{\"description\":\"Client certificate filename.\",\"type\":\"string\"},\"keyFile\":{\"description\":\"Client key filename.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"network\":{\"description\":\"Network holds various configurable Envoy network values.\",\"properties\":{\"adminPort\":{\"default\":9001,\"description\":\"Configure the port used to access the Envoy Admin interface. If configured to port \\\"0\\\" then the admin interface is disabled.\",\"type\":\"integer\"},\"numTrustedHops\":{\"description\":\"XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address. \\n See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"adminPort\"],\"type\":\"object\"},\"service\":{\"default\":{\"name\":\"envoy\",\"namespace\":\"projectcontour\"},\"description\":\"Service holds Envoy service parameters for setting Ingress status.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"timeouts\":{\"description\":\"Timeouts holds various configurable timeouts that can be set in the config file.\",\"properties\":{\"connectionIdleTimeout\":{\"description\":\"ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to \\\"infinity\\\" to disable the timeout entirely. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.\",\"type\":\"string\"},\"connectionShutdownGracePeriod\":{\"description\":\"ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.\",\"type\":\"string\"},\"delayedCloseTimeout\":{\"description\":\"DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection. \\n Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.\",\"type\":\"string\"},\"maxConnectionDuration\":{\"description\":\"MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to \\\"infinity\\\" for no max duration. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.\",\"type\":\"string\"},\"requestTimeout\":{\"description\":\"RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to \\\"infinity\\\" to disable the timeout entirely. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.\",\"type\":\"string\"},\"streamIdleTimeout\":{\"description\":\"StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to \\\"infinity\\\" to disable the timeout entirely. \\n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"cluster\",\"defaultHTTPVersions\",\"http\",\"https\",\"listener\",\"logging\",\"metrics\",\"network\",\"service\"],\"type\":\"object\"},\"gateway\":{\"description\":\"Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.\",\"properties\":{\"controllerName\":{\"default\":\"projectcontour.io/projectcontour/contour\",\"description\":\"ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of \\\"projectcontour.io/\\u003cnamespace\\u003e/contour\\\". If unset, the gatewayclass controller will not be started.\",\"type\":\"string\"}},\"required\":[\"controllerName\"],\"type\":\"object\"},\"health\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8000},\"description\":\"Health defines the endpoints Contour uses to serve health checks.\",\"properties\":{\"address\":{\"description\":\"Defines the health address interface.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the health port.\",\"type\":\"integer\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"httpproxy\":{\"default\":{\"disablePermitInsecure\":false},\"description\":\"HTTPProxy defines parameters on HTTPProxy.\",\"properties\":{\"disablePermitInsecure\":{\"description\":\"DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.\",\"type\":\"boolean\"},\"fallbackCertificate\":{\"description\":\"FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"rootNamespaces\":{\"description\":\"Restrict Contour to searching these namespaces for root ingress routes.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"disablePermitInsecure\"],\"type\":\"object\"},\"ingress\":{\"description\":\"Ingress contains parameters for ingress options.\",\"properties\":{\"className\":{\"description\":\"Ingress Class Name Contour should use.\",\"type\":\"string\"},\"statusAddress\":{\"description\":\"Address to set in Ingress object status.\",\"type\":\"string\"}},\"type\":\"object\"},\"metrics\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8000},\"description\":\"Metrics defines the endpoint Contour uses to serve metrics.\",\"properties\":{\"address\":{\"description\":\"Defines the metrics address interface.\",\"maxLength\":253,\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the metrics port.\",\"type\":\"integer\"},\"tls\":{\"description\":\"TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.\",\"properties\":{\"caFile\":{\"description\":\"CA filename.\",\"type\":\"string\"},\"certFile\":{\"description\":\"Client certificate filename.\",\"type\":\"string\"},\"keyFile\":{\"description\":\"Client key filename.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"policy\":{\"description\":\"Policy specifies default policy applied if not overridden by the user\",\"properties\":{\"applyToIngress\":{\"description\":\"ApplyToIngress determines if the Policies will apply to ingress objects\",\"type\":\"boolean\"},\"requestHeaders\":{\"description\":\"RequestHeadersPolicy defines the request headers set/removed on all routes\",\"properties\":{\"remove\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"},\"responseHeaders\":{\"description\":\"ResponseHeadersPolicy defines the response headers set/removed on all routes\",\"properties\":{\"remove\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"}},\"type\":\"object\"},\"rateLimitService\":{\"description\":\"RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.\",\"properties\":{\"domain\":{\"description\":\"Domain is passed to the Rate Limit Service.\",\"type\":\"string\"},\"enableXRateLimitHeaders\":{\"description\":\"EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request. \\n ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\",\"type\":\"boolean\"},\"extensionService\":{\"description\":\"ExtensionService identifies the extension service defining the RLS.\",\"properties\":{\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"}},\"required\":[\"name\",\"namespace\"],\"type\":\"object\"},\"failOpen\":{\"description\":\"FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.\",\"type\":\"boolean\"}},\"required\":[\"domain\",\"enableXRateLimitHeaders\",\"failOpen\"],\"type\":\"object\"},\"xdsServer\":{\"default\":{\"address\":\"***HIDDEN***\",\"port\":8001,\"tls\":{\"caFile\":\"/certs/ca.crt\",\"certFile\":\"/certs/tls.crt\",\"insecure\":false,\"keyFile\":\"/certs/tls.key\"},\"type\":\"contour\"},\"description\":\"XDSServer contains parameters for the xDS server.\",\"properties\":{\"address\":{\"description\":\"Defines the xDS gRPC API address which Contour will serve.\",\"minLength\":1,\"type\":\"string\"},\"port\":{\"description\":\"Defines the xDS gRPC API port which Contour will serve.\",\"type\":\"integer\"},\"tls\":{\"description\":\"TLS holds TLS file config details.\",\"properties\":{\"caFile\":{\"description\":\"CA filename.\",\"type\":\"string\"},\"certFile\":{\"description\":\"Client certificate filename.\",\"type\":\"string\"},\"insecure\":{\"description\":\"Allow serving the xDS gRPC API without TLS.\",\"type\":\"boolean\"},\"keyFile\":{\"description\":\"Client key filename.\",\"type\":\"string\"}},\"required\":[\"insecure\"],\"type\":\"object\"},\"type\":{\"description\":\"Defines the XDSServer to use for `contour serve`.\",\"enum\":[\"contour\",\"envoy\"],\"type\":\"string\"}},\"required\":[\"address\",\"port\",\"type\"],\"type\":\"object\"}},\"type\":\"object\"},\"replicas\":{\"default\":2,\"description\":\"Replicas is the desired number of Contour replicas. If unset, defaults to 2.\",\"format\":\"int32\",\"minimum\":0,\"type\":\"integer\"}},\"required\":[\"config\"],\"type\":\"object\"},\"status\":{\"description\":\"ContourDeploymentStatus defines the observed state of a ContourDeployment resource.\",\"properties\":{\"conditions\":{\"description\":\"Conditions contains the current status of the Contour resource. \\n Contour will update a single condition, `Valid`, that is in normal-true polarity. \\n Contour will not modify any other Conditions set in this block, in case some other controller wants to add a Condition.\",\"items\":{\"description\":\"DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \\n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \\n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \\n Remember that Conditions have a type, a status, and a reason. \\n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \\n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \\n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \\n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \\n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.\",\"properties\":{\"errors\":{\"description\":\"Errors contains a slice of relevant error subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"lastTransitionTime\":{\"description\":\"lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.\",\"format\":\"date-time\",\"type\":\"string\"},\"message\":{\"description\":\"message is a human readable message indicating details about the transition. This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"observedGeneration\":{\"description\":\"observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"},\"reason\":{\"description\":\"reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"},\"warnings\":{\"description\":\"Warnings contains a slice of relevant warning subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"lastTransitionTime\",\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-map-keys\":[\"type\"],\"x-kubernetes-list-type\":\"map\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]},\"status\":{\"acceptedNames\":{\"kind\":\"\",\"plural\":\"\"},\"conditions\":[],\"storedVersions\":[]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "projectcontour.io",
        "names": {
          "plural": "contourdeployments",
          "singular": "contourdeployment",
          "shortNames": [
            "contourdeploy"
          ],
          "kind": "ContourDeployment",
          "listKind": "ContourDeploymentList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1alpha1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "ContourDeployment is the schema for a Contour Deployment.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "ContourDeploymentSpec defines the parameters of how a Contour instance should be configured.",
                    "type": "object",
                    "required": [
                      "config"
                    ],
                    "properties": {
                      "config": {
                        "description": "Config is the config that the instances of Contour are to utilize.",
                        "type": "object",
                        "properties": {
                          "debug": {
                            "description": "Debug contains parameters to enable debug logging and debug interfaces inside Contour.",
                            "type": "object",
                            "default": {
                              "kubernetesLogLevel": 0,
                              "logLevel": "info"
                            },
                            "required": [
                              "logLevel"
                            ],
                            "properties": {
                              "address": {
                                "description": "Defines the Contour debug address interface.",
                                "type": "string"
                              },
                              "kubernetesLogLevel": {
                                "description": "KubernetesDebugLogLevel defines the log level which Contour will use when outputting Kubernetes specific log information. \n Details: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md",
                                "type": "integer",
                                "default": 0,
                                "maximum": 9,
                                "minimum": 0
                              },
                              "logLevel": {
                                "description": "DebugLogLevel defines the log level which Contour will use when outputting log information.",
                                "type": "string",
                                "enum": [
                                  "info",
                                  "debug"
                                ]
                              },
                              "port": {
                                "description": "Defines the Contour debug address port.",
                                "type": "integer"
                              }
                            }
                          },
                          "enableExternalNameService": {
                            "description": "EnableExternalNameService allows processing of ExternalNameServices Defaults to disabled for security reasons.",
                            "type": "boolean",
                            "default": false
                          },
                          "envoy": {
                            "description": "Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.",
                            "type": "object",
                            "default": {
                              "cluster": {
                                "dnsLookupFamily": "auto"
                              },
                              "defaultHTTPVersions": [
                                "HTTP/1.1",
                                "HTTP/2"
                              ],
                              "health": {
                                "address": "***HIDDEN***",
                                "port": 8002
                              },
                              "http": {
                                "accessLog": "/dev/stdout",
                                "address": "***HIDDEN***",
                                "port": 8080
                              },
                              "https": {
                                "accessLog": "/dev/stdout",
                                "address": "***HIDDEN***",
                                "port": 8443
                              },
                              "listener": {
                                "connectionBalancer": "",
                                "disableAllowChunkedLength": false,
                                "tls": {
                                  "cipherSuites": [
                                    "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]",
                                    "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]",
                                    "ECDHE-ECDSA-AES256-GCM-SHA384",
                                    "ECDHE-RSA-AES256-GCM-SHA384"
                                  ],
                                  "minimumProtocolVersion": "1.2"
                                },
                                "useProxyProtocol": false
                              },
                              "logging": {
                                "accessLogFormat": "envoy"
                              },
                              "metrics": {
                                "address": "***HIDDEN***",
                                "port": 8002
                              },
                              "network": {
                                "adminPort": 9001
                              },
                              "service": {
                                "name": "envoy",
                                "namespace": "projectcontour"
                              }
                            },
                            "required": [
                              "cluster",
                              "defaultHTTPVersions",
                              "http",
                              "https",
                              "listener",
                              "logging",
                              "metrics",
                              "network",
                              "service"
                            ],
                            "properties": {
                              "clientCertificate": {
                                "description": "ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.",
                                "type": "object",
                                "required": [
                                  "name",
                                  "namespace"
                                ],
                                "properties": {
                                  "name": {
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "type": "string"
                                  }
                                }
                              },
                              "cluster": {
                                "description": "Cluster holds various configurable Envoy cluster values that can be set in the config file.",
                                "type": "object",
                                "required": [
                                  "dnsLookupFamily"
                                ],
                                "properties": {
                                  "dnsLookupFamily": {
                                    "description": "DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. Note: This only applies to externalName clusters. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.",
                                    "type": "string",
                                    "default": "auto",
                                    "enum": [
                                      "auto",
                                      "v4",
                                      "v6"
                                    ]
                                  }
                                }
                              },
                              "defaultHTTPVersions": {
                                "description": "DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form \"HTTP/xx\". Supported versions are \"HTTP/1.1\" and \"HTTP/2\".",
                                "type": "array",
                                "items": {
                                  "description": "HTTPVersionType is the name of a supported HTTP version.",
                                  "type": "string",
                                  "enum": [
                                    "HTTP/1.1",
                                    "HTTP/2"
                                  ]
                                }
                              },
                              "health": {
                                "description": "Health defines the endpoint Envoy uses to serve health checks.",
                                "type": "object",
                                "default": {
                                  "address": "***HIDDEN***",
                                  "port": 8002
                                },
                                "required": [
                                  "address",
                                  "port"
                                ],
                                "properties": {
                                  "address": {
                                    "description": "Defines the health address interface.",
                                    "type": "string",
                                    "minLength": 1
                                  },
                                  "port": {
                                    "description": "Defines the health port.",
                                    "type": "integer"
                                  }
                                }
                              },
                              "http": {
                                "description": "Defines the HTTP Listener for Envoy.",
                                "type": "object",
                                "default": {
                                  "accessLog": "/dev/stdout",
                                  "address": "***HIDDEN***",
                                  "port": 8080
                                },
                                "required": [
                                  "accessLog",
                                  "address",
                                  "port"
                                ],
                                "properties": {
                                  "accessLog": {
                                    "description": "AccessLog defines where Envoy logs are outputted for this listener.",
                                    "type": "string"
                                  },
                                  "address": {
                                    "description": "Defines an Envoy Listener Address.",
                                    "type": "string",
                                    "minLength": 1
                                  },
                                  "port": {
                                    "description": "Defines an Envoy listener Port.",
                                    "type": "integer"
                                  }
                                }
                              },
                              "https": {
                                "description": "Defines the HTTP Listener for Envoy.",
                                "type": "object",
                                "default": {
                                  "accessLog": "/dev/stdout",
                                  "address": "***HIDDEN***",
                                  "port": 8443
                                },
                                "required": [
                                  "accessLog",
                                  "address",
                                  "port"
                                ],
                                "properties": {
                                  "accessLog": {
                                    "description": "AccessLog defines where Envoy logs are outputted for this listener.",
                                    "type": "string"
                                  },
                                  "address": {
                                    "description": "Defines an Envoy Listener Address.",
                                    "type": "string",
                                    "minLength": 1
                                  },
                                  "port": {
                                    "description": "Defines an Envoy listener Port.",
                                    "type": "integer"
                                  }
                                }
                              },
                              "listener": {
                                "description": "Listener hold various configurable Envoy listener values.",
                                "type": "object",
                                "required": [
                                  "connectionBalancer",
                                  "disableAllowChunkedLength",
                                  "tls",
                                  "useProxyProtocol"
                                ],
                                "properties": {
                                  "connectionBalancer": {
                                    "description": "ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.",
                                    "type": "string",
                                    "enum": [
                                      "",
                                      "exact"
                                    ]
                                  },
                                  "disableAllowChunkedLength": {
                                    "description": "DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the \"Content-Length\" header if \"Transfer-Encoding: chunked\" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221",
                                    "type": "boolean"
                                  },
                                  "tls": {
                                    "description": "TLS holds various configurable Envoy TLS listener values.",
                                    "type": "object",
                                    "required": [
                                      "cipherSuites",
                                      "minimumProtocolVersion"
                                    ],
                                    "properties": {
                                      "cipherSuites": {
                                        "description": "CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use. \n See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.",
                                        "type": "array",
                                        "items": {
                                          "type": "string",
                                          "enum": [
                                            "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]",
                                            "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]",
                                            "ECDHE-ECDSA-AES128-GCM-SHA256",
                                            "ECDHE-RSA-AES128-GCM-SHA256",
                                            "ECDHE-ECDSA-AES128-SHA",
                                            "ECDHE-RSA-AES128-SHA",
                                            "AES128-GCM-SHA256",
                                            "AES128-SHA",
                                            "ECDHE-ECDSA-AES256-GCM-SHA384",
                                            "ECDHE-RSA-AES256-GCM-SHA384",
                                            "ECDHE-ECDSA-AES256-SHA",
                                            "ECDHE-RSA-AES256-SHA",
                                            "AES256-GCM-SHA384",
                                            "AES256-SHA"
                                          ]
                                        }
                                      },
                                      "minimumProtocolVersion": {
                                        "description": "MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`.",
                                        "type": "string",
                                        "enum": [
                                          "1.2",
                                          "1.3"
                                        ]
                                      }
                                    }
                                  },
                                  "useProxyProtocol": {
                                    "description": "Use PROXY protocol for all listeners.",
                                    "type": "boolean"
                                  }
                                }
                              },
                              "logging": {
                                "description": "Logging defines how Envoy's logs can be configured.",
                                "type": "object",
                                "required": [
                                  "accessLogFormat"
                                ],
                                "properties": {
                                  "accessLogFormat": {
                                    "description": "AccessLogFormat sets the global access log format. Valid options are 'envoy' or 'json'",
                                    "type": "string",
                                    "enum": [
                                      "envoy",
                                      "json"
                                    ]
                                  },
                                  "accessLogFormatString": {
                                    "description": "AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.",
                                    "type": "string"
                                  },
                                  "jsonFields": {
                                    "description": "AccessLogFields sets the fields that JSON logging will output when AccessLogFormat is json.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "metrics": {
                                "description": "Metrics defines the endpoint Envoy uses to serve metrics.",
                                "type": "object",
                                "default": {
                                  "address": "***HIDDEN***",
                                  "port": 8002
                                },
                                "required": [
                                  "address",
                                  "port"
                                ],
                                "properties": {
                                  "address": {
                                    "description": "Defines the metrics address interface.",
                                    "type": "string",
                                    "maxLength": 253,
                                    "minLength": 1
                                  },
                                  "port": {
                                    "description": "Defines the metrics port.",
                                    "type": "integer"
                                  },
                                  "tls": {
                                    "description": "TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.",
                                    "type": "object",
                                    "properties": {
                                      "caFile": {
                                        "description": "CA filename.",
                                        "type": "string"
                                      },
                                      "certFile": {
                                        "description": "Client certificate filename.",
                                        "type": "string"
                                      },
                                      "keyFile": {
                                        "description": "Client key filename.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "network": {
                                "description": "Network holds various configurable Envoy network values.",
                                "type": "object",
                                "required": [
                                  "adminPort"
                                ],
                                "properties": {
                                  "adminPort": {
                                    "description": "Configure the port used to access the Envoy Admin interface. If configured to port \"0\" then the admin interface is disabled.",
                                    "type": "integer",
                                    "default": 9001
                                  },
                                  "numTrustedHops": {
                                    "description": "XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address. \n See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.",
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              },
                              "service": {
                                "description": "Service holds Envoy service parameters for setting Ingress status.",
                                "type": "object",
                                "default": {
                                  "name": "envoy",
                                  "namespace": "projectcontour"
                                },
                                "required": [
                                  "name",
                                  "namespace"
                                ],
                                "properties": {
                                  "name": {
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "type": "string"
                                  }
                                }
                              },
                              "timeouts": {
                                "description": "Timeouts holds various configurable timeouts that can be set in the config file.",
                                "type": "object",
                                "properties": {
                                  "connectionIdleTimeout": {
                                    "description": "ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to \"infinity\" to disable the timeout entirely. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.",
                                    "type": "string"
                                  },
                                  "connectionShutdownGracePeriod": {
                                    "description": "ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.",
                                    "type": "string"
                                  },
                                  "delayedCloseTimeout": {
                                    "description": "DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection. \n Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.",
                                    "type": "string"
                                  },
                                  "maxConnectionDuration": {
                                    "description": "MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to \"infinity\" for no max duration. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.",
                                    "type": "string"
                                  },
                                  "requestTimeout": {
                                    "description": "RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to \"infinity\" to disable the timeout entirely. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.",
                                    "type": "string"
                                  },
                                  "streamIdleTimeout": {
                                    "description": "StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to \"infinity\" to disable the timeout entirely. \n See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "gateway": {
                            "description": "Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.",
                            "type": "object",
                            "required": [
                              "controllerName"
                            ],
                            "properties": {
                              "controllerName": {
                                "description": "ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of \"projectcontour.io/\u003cnamespace\u003e/contour\". If unset, the gatewayclass controller will not be started.",
                                "type": "string",
                                "default": "projectcontour.io/projectcontour/contour"
                              }
                            }
                          },
                          "health": {
                            "description": "Health defines the endpoints Contour uses to serve health checks.",
                            "type": "object",
                            "default": {
                              "address": "***HIDDEN***",
                              "port": 8000
                            },
                            "required": [
                              "address",
                              "port"
                            ],
                            "properties": {
                              "address": {
                                "description": "Defines the health address interface.",
                                "type": "string",
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines the health port.",
                                "type": "integer"
                              }
                            }
                          },
                          "httpproxy": {
                            "description": "HTTPProxy defines parameters on HTTPProxy.",
                            "type": "object",
                            "default": {
                              "disablePermitInsecure": false
                            },
                            "required": [
                              "disablePermitInsecure"
                            ],
                            "properties": {
                              "disablePermitInsecure": {
                                "description": "DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.",
                                "type": "boolean"
                              },
                              "fallbackCertificate": {
                                "description": "FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.",
                                "type": "object",
                                "required": [
                                  "name",
                                  "namespace"
                                ],
                                "properties": {
                                  "name": {
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "type": "string"
                                  }
                                }
                              },
                              "rootNamespaces": {
                                "description": "Restrict Contour to searching these namespaces for root ingress routes.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "ingress": {
                            "description": "Ingress contains parameters for ingress options.",
                            "type": "object",
                            "properties": {
                              "className": {
                                "description": "Ingress Class Name Contour should use.",
                                "type": "string"
                              },
                              "statusAddress": {
                                "description": "Address to set in Ingress object status.",
                                "type": "string"
                              }
                            }
                          },
                          "metrics": {
                            "description": "Metrics defines the endpoint Contour uses to serve metrics.",
                            "type": "object",
                            "default": {
                              "address": "***HIDDEN***",
                              "port": 8000
                            },
                            "required": [
                              "address",
                              "port"
                            ],
                            "properties": {
                              "address": {
                                "description": "Defines the metrics address interface.",
                                "type": "string",
                                "maxLength": 253,
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines the metrics port.",
                                "type": "integer"
                              },
                              "tls": {
                                "description": "TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.",
                                "type": "object",
                                "properties": {
                                  "caFile": {
                                    "description": "CA filename.",
                                    "type": "string"
                                  },
                                  "certFile": {
                                    "description": "Client certificate filename.",
                                    "type": "string"
                                  },
                                  "keyFile": {
                                    "description": "Client key filename.",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "policy": {
                            "description": "Policy specifies default policy applied if not overridden by the user",
                            "type": "object",
                            "properties": {
                              "applyToIngress": {
                                "description": "ApplyToIngress determines if the Policies will apply to ingress objects",
                                "type": "boolean"
                              },
                              "requestHeaders": {
                                "description": "RequestHeadersPolicy defines the request headers set/removed on all routes",
                                "type": "object",
                                "properties": {
                                  "remove": {
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "set": {
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "responseHeaders": {
                                "description": "ResponseHeadersPolicy defines the response headers set/removed on all routes",
                                "type": "object",
                                "properties": {
                                  "remove": {
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "set": {
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "rateLimitService": {
                            "description": "RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.",
                            "type": "object",
                            "required": [
                              "domain",
                              "enableXRateLimitHeaders",
                              "failOpen"
                            ],
                            "properties": {
                              "domain": {
                                "description": "Domain is passed to the Rate Limit Service.",
                                "type": "string"
                              },
                              "enableXRateLimitHeaders": {
                                "description": "EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request. \n ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html",
                                "type": "boolean"
                              },
                              "extensionService": {
                                "description": "ExtensionService identifies the extension service defining the RLS.",
                                "type": "object",
                                "required": [
                                  "name",
                                  "namespace"
                                ],
                                "properties": {
                                  "name": {
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "type": "string"
                                  }
                                }
                              },
                              "failOpen": {
                                "description": "FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.",
                                "type": "boolean"
                              }
                            }
                          },
                          "xdsServer": {
                            "description": "XDSServer contains parameters for the xDS server.",
                            "type": "object",
                            "default": {
                              "address": "***HIDDEN***",
                              "port": 8001,
                              "tls": {
                                "caFile": "/certs/ca.crt",
                                "certFile": "/certs/tls.crt",
                                "insecure": false,
                                "keyFile": "/certs/tls.key"
                              },
                              "type": "contour"
                            },
                            "required": [
                              "address",
                              "port",
                              "type"
                            ],
                            "properties": {
                              "address": {
                                "description": "Defines the xDS gRPC API address which Contour will serve.",
                                "type": "string",
                                "minLength": 1
                              },
                              "port": {
                                "description": "Defines the xDS gRPC API port which Contour will serve.",
                                "type": "integer"
                              },
                              "tls": {
                                "description": "TLS holds TLS file config details.",
                                "type": "object",
                                "required": [
                                  "insecure"
                                ],
                                "properties": {
                                  "caFile": {
                                    "description": "CA filename.",
                                    "type": "string"
                                  },
                                  "certFile": {
                                    "description": "Client certificate filename.",
                                    "type": "string"
                                  },
                                  "insecure": {
                                    "description": "Allow serving the xDS gRPC API without TLS.",
                                    "type": "boolean"
                                  },
                                  "keyFile": {
                                    "description": "Client key filename.",
                                    "type": "string"
                                  }
                                }
                              },
                              "type": {
                                "description": "Defines the XDSServer to use for `contour serve`.",
                                "type": "string",
                                "enum": [
                                  "contour",
                                  "envoy"
                                ]
                              }
                            }
                          }
                        }
                      },
                      "replicas": {
                        "description": "Replicas is the desired number of Contour replicas. If unset, defaults to 2.",
                        "type": "integer",
                        "format": "int32",
                        "default": 2,
                        "minimum": 0
                      }
                    }
                  },
                  "status": {
                    "description": "ContourDeploymentStatus defines the observed state of a ContourDeployment resource.",
                    "type": "object",
                    "properties": {
                      "conditions": {
                        "description": "Conditions contains the current status of the Contour resource. \n Contour will update a single condition, `Valid`, that is in normal-true polarity. \n Contour will not modify any other Conditions set in this block, in case some other controller wants to add a Condition.",
                        "type": "array",
                        "items": {
                          "description": "DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \n Remember that Conditions have a type, a status, and a reason. \n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.",
                          "type": "object",
                          "required": [
                            "lastTransitionTime",
                            "message",
                            "reason",
                            "status",
                            "type"
                          ],
                          "properties": {
                            "errors": {
                              "description": "Errors contains a slice of relevant error subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            },
                            "lastTransitionTime": {
                              "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                              "type": "string",
                              "format": "date-time"
                            },
                            "message": {
                              "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                              "type": "string",
                              "maxLength": 32768
                            },
                            "observedGeneration": {
                              "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                              "type": "integer",
                              "format": "int64",
                              "minimum": 0
                            },
                            "reason": {
                              "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                              "type": "string",
                              "maxLength": 1024,
                              "minLength": 1,
                              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                            },
                            "status": {
                              "description": "status of the condition, one of True, False, Unknown.",
                              "type": "string",
                              "enum": [
                                "True",
                                "False",
                                "Unknown"
                              ]
                            },
                            "type": {
                              "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                              "type": "string",
                              "maxLength": 316,
                              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                            },
                            "warnings": {
                              "description": "Warnings contains a slice of relevant warning subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "type"
                        ],
                        "x-kubernetes-list-type": "map"
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "contourdeployments",
          "singular": "contourdeployment",
          "shortNames": [
            "contourdeploy"
          ],
          "kind": "ContourDeployment",
          "listKind": "ContourDeploymentList"
        },
        "storedVersions": [
          "v1alpha1"
        ]
      }
    },
    {
      "metadata": {
        "name": "deletebackuprequests.velero.io",
        "uid": "78088462-2526-416e-8f1d-21e3d5d7b9f6",
        "resourceVersion": "1843",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"deletebackuprequests.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"DeleteBackupRequest\",\"listKind\":\"DeleteBackupRequestList\",\"plural\":\"deletebackuprequests\",\"singular\":\"deletebackuprequest\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"DeleteBackupRequest is a request to delete one or more backups.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"DeleteBackupRequestSpec is the specification for which backups to delete.\",\"properties\":{\"backupName\":{\"type\":\"string\"}},\"required\":[\"backupName\"],\"type\":\"object\"},\"status\":{\"description\":\"DeleteBackupRequestStatus is the current status of a DeleteBackupRequest.\",\"properties\":{\"errors\":{\"description\":\"Errors contains any errors that were encountered during the deletion process.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"phase\":{\"description\":\"Phase is the current state of the DeleteBackupRequest.\",\"enum\":[\"New\",\"InProgress\",\"Processed\"],\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "deletebackuprequests",
          "singular": "deletebackuprequest",
          "kind": "DeleteBackupRequest",
          "listKind": "DeleteBackupRequestList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "DeleteBackupRequest is a request to delete one or more backups.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "DeleteBackupRequestSpec is the specification for which backups to delete.",
                    "type": "object",
                    "required": [
                      "backupName"
                    ],
                    "properties": {
                      "backupName": {
                        "type": "string"
                      }
                    }
                  },
                  "status": {
                    "description": "DeleteBackupRequestStatus is the current status of a DeleteBackupRequest.",
                    "type": "object",
                    "properties": {
                      "errors": {
                        "description": "Errors contains any errors that were encountered during the deletion process.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "phase": {
                        "description": "Phase is the current state of the DeleteBackupRequest.",
                        "type": "string",
                        "enum": [
                          "New",
                          "InProgress",
                          "Processed"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "deletebackuprequests",
          "singular": "deletebackuprequest",
          "kind": "DeleteBackupRequest",
          "listKind": "DeleteBackupRequestList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "downloadrequests.velero.io",
        "uid": "4f1873b8-adfd-4559-a829-c1bc6d6802e2",
        "resourceVersion": "1844",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"downloadrequests.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"DownloadRequest\",\"listKind\":\"DownloadRequestList\",\"plural\":\"downloadrequests\",\"singular\":\"downloadrequest\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"DownloadRequest is a request to download an artifact from backup object storage, such as a backup log file.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"DownloadRequestSpec is the specification for a download request.\",\"properties\":{\"target\":{\"description\":\"Target is what to download (e.g. logs for a backup).\",\"properties\":{\"kind\":{\"description\":\"Kind is the type of file to download.\",\"enum\":[\"BackupLog\",\"BackupContents\",\"BackupVolumeSnapshots\",\"BackupResourceList\",\"RestoreLog\",\"RestoreResults\"],\"type\":\"string\"},\"name\":{\"description\":\"Name is the name of the kubernetes resource with which the file is associated.\",\"type\":\"string\"}},\"required\":[\"kind\",\"name\"],\"type\":\"object\"}},\"required\":[\"target\"],\"type\":\"object\"},\"status\":{\"description\":\"DownloadRequestStatus is the current status of a DownloadRequest.\",\"properties\":{\"downloadURL\":{\"description\":\"DownloadURL contains the pre-signed URL for the target file.\",\"type\":\"string\"},\"expiration\":{\"description\":\"Expiration is when this DownloadRequest expires and can be deleted by the system.\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the DownloadRequest.\",\"enum\":[\"New\",\"Processed\"],\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "downloadrequests",
          "singular": "downloadrequest",
          "kind": "DownloadRequest",
          "listKind": "DownloadRequestList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "DownloadRequest is a request to download an artifact from backup object storage, such as a backup log file.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "DownloadRequestSpec is the specification for a download request.",
                    "type": "object",
                    "required": [
                      "target"
                    ],
                    "properties": {
                      "target": {
                        "description": "Target is what to download (e.g. logs for a backup).",
                        "type": "object",
                        "required": [
                          "kind",
                          "name"
                        ],
                        "properties": {
                          "kind": {
                            "description": "Kind is the type of file to download.",
                            "type": "string",
                            "enum": [
                              "BackupLog",
                              "BackupContents",
                              "BackupVolumeSnapshots",
                              "BackupResourceList",
                              "RestoreLog",
                              "RestoreResults"
                            ]
                          },
                          "name": {
                            "description": "Name is the name of the kubernetes resource with which the file is associated.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "DownloadRequestStatus is the current status of a DownloadRequest.",
                    "type": "object",
                    "properties": {
                      "downloadURL": {
                        "description": "DownloadURL contains the pre-signed URL for the target file.",
                        "type": "string"
                      },
                      "expiration": {
                        "description": "Expiration is when this DownloadRequest expires and can be deleted by the system.",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "phase": {
                        "description": "Phase is the current state of the DownloadRequest.",
                        "type": "string",
                        "enum": [
                          "New",
                          "Processed"
                        ]
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "downloadrequests",
          "singular": "downloadrequest",
          "kind": "DownloadRequest",
          "listKind": "DownloadRequestList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "engineimages.longhorn.io",
        "uid": "dec69f2a-a263-4275-9fd6-2f4cc2b24afe",
        "resourceVersion": "828",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "EngineImage"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"EngineImage\"},\"name\":\"engineimages.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"EngineImage\",\"listKind\":\"EngineImageList\",\"plural\":\"engineimages\",\"shortNames\":[\"lhei\"],\"singular\":\"engineimage\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"State of the engine image\",\"jsonPath\":\".status.state\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The Longhorn engine image\",\"jsonPath\":\".spec.image\",\"name\":\"Image\",\"type\":\"string\"},{\"description\":\"Number of volumes are using the engine image\",\"jsonPath\":\".status.refCount\",\"name\":\"RefCount\",\"type\":\"integer\"},{\"description\":\"The build date of the engine image\",\"jsonPath\":\".status.buildDate\",\"name\":\"BuildDate\",\"type\":\"date\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "engineimages",
          "singular": "engineimage",
          "shortNames": [
            "lhei"
          ],
          "kind": "EngineImage",
          "listKind": "EngineImageList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "State of the engine image",
                "jsonPath": ".status.state"
              },
              {
                "name": "Image",
                "type": "string",
                "description": "The Longhorn engine image",
                "jsonPath": ".spec.image"
              },
              {
                "name": "RefCount",
                "type": "integer",
                "description": "Number of volumes are using the engine image",
                "jsonPath": ".status.refCount"
              },
              {
                "name": "BuildDate",
                "type": "date",
                "description": "The build date of the engine image",
                "jsonPath": ".status.buildDate"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "engineimages",
          "singular": "engineimage",
          "shortNames": [
            "lhei"
          ],
          "kind": "EngineImage",
          "listKind": "EngineImageList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "engines.longhorn.io",
        "uid": "8109ad07-9d96-42d4-b2aa-3f19d5fd8b49",
        "resourceVersion": "816",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "Engine"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"Engine\"},\"name\":\"engines.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"Engine\",\"listKind\":\"EngineList\",\"plural\":\"engines\",\"shortNames\":[\"lhe\"],\"singular\":\"engine\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The current state of the engine\",\"jsonPath\":\".status.currentState\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The node that the engine is on\",\"jsonPath\":\".spec.nodeID\",\"name\":\"Node\",\"type\":\"string\"},{\"description\":\"The instance manager of the engine\",\"jsonPath\":\".status.instanceManagerName\",\"name\":\"InstanceManager\",\"type\":\"string\"},{\"description\":\"The current image of the engine\",\"jsonPath\":\".status.currentImage\",\"name\":\"Image\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "engines",
          "singular": "engine",
          "shortNames": [
            "lhe"
          ],
          "kind": "Engine",
          "listKind": "EngineList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The current state of the engine",
                "jsonPath": ".status.currentState"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node that the engine is on",
                "jsonPath": ".spec.nodeID"
              },
              {
                "name": "InstanceManager",
                "type": "string",
                "description": "The instance manager of the engine",
                "jsonPath": ".status.instanceManagerName"
              },
              {
                "name": "Image",
                "type": "string",
                "description": "The current image of the engine",
                "jsonPath": ".status.currentImage"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "engines",
          "singular": "engine",
          "shortNames": [
            "lhe"
          ],
          "kind": "Engine",
          "listKind": "EngineList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "extensionservices.projectcontour.io",
        "uid": "197f326a-6169-4402-b91e-68e47dec5dbd",
        "resourceVersion": "1527",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:42Z",
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.6.2",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.6.2\"},\"creationTimestamp\":null,\"name\":\"extensionservices.projectcontour.io\"},\"spec\":{\"group\":\"projectcontour.io\",\"names\":{\"kind\":\"ExtensionService\",\"listKind\":\"ExtensionServiceList\",\"plural\":\"extensionservices\",\"shortNames\":[\"extensionservice\",\"extensionservices\"],\"singular\":\"extensionservice\"},\"preserveUnknownFields\":false,\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1alpha1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"ExtensionService is the schema for the Contour extension services API. An ExtensionService resource binds a network service to the Contour API so that Contour API features can be implemented by collaborating components.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"ExtensionServiceSpec defines the desired state of an ExtensionService resource.\",\"properties\":{\"loadBalancerPolicy\":{\"description\":\"The policy for load balancing GRPC service requests. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.\",\"properties\":{\"requestHashPolicies\":{\"description\":\"RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.\",\"items\":{\"description\":\"RequestHashPolicy contains configuration for an individual hash policy on a request attribute.\",\"properties\":{\"hashSourceIP\":{\"description\":\"HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.\",\"type\":\"boolean\"},\"headerHashOptions\":{\"description\":\"HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.\",\"properties\":{\"headerName\":{\"description\":\"HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"terminal\":{\"description\":\"Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.\",\"type\":\"boolean\"}},\"type\":\"object\"},\"type\":\"array\"},\"strategy\":{\"description\":\"Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.\",\"type\":\"string\"}},\"type\":\"object\"},\"protocol\":{\"description\":\"Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be h2 or h2c. If omitted, protocol-selection falls back on Service annotations.\",\"enum\":[\"h2\",\"h2c\"],\"type\":\"string\"},\"protocolVersion\":{\"description\":\"This field sets the version of the GRPC protocol that Envoy uses to send requests to the extension service. Since Contour always uses the v3 Envoy API, this is currently fixed at \\\"v3\\\". However, other protocol options will be available in future.\",\"enum\":[\"v3\"],\"type\":\"string\"},\"services\":{\"description\":\"Services specifies the set of Kubernetes Service resources that receive GRPC extension API requests. If no weights are specified for any of the entries in this array, traffic will be spread evenly across all the services. Otherwise, traffic is balanced proportionally to the Weight field in each entry.\",\"items\":{\"description\":\"ExtensionServiceTarget defines an Kubernetes Service to target with extension service traffic.\",\"properties\":{\"name\":{\"description\":\"Name is the name of Kubernetes service that will accept service traffic.\",\"type\":\"string\"},\"port\":{\"description\":\"Port (defined as Integer) to proxy traffic to since a service can have multiple defined.\",\"exclusiveMaximum\":true,\"maximum\":65536,\"minimum\":1,\"type\":\"integer\"},\"weight\":{\"description\":\"Weight defines proportion of traffic to balance to the Kubernetes Service.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"name\",\"port\"],\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"},\"timeoutPolicy\":{\"description\":\"The timeout policy for requests to the services.\",\"properties\":{\"idle\":{\"description\":\"Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.\",\"pattern\":\"^(((\\\\d*(\\\\.\\\\d*)?h)|(\\\\d*(\\\\.\\\\d*)?m)|(\\\\d*(\\\\.\\\\d*)?s)|(\\\\d*(\\\\.\\\\d*)?ms)|(\\\\d*(\\\\.\\\\d*)?us)|(\\\\d*(\\\\.\\\\d*)?µs)|(\\\\d*(\\\\.\\\\d*)?ns))+|infinity|infinite)$\",\"type\":\"string\"},\"response\":{\"description\":\"Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.\",\"pattern\":\"^(((\\\\d*(\\\\.\\\\d*)?h)|(\\\\d*(\\\\.\\\\d*)?m)|(\\\\d*(\\\\.\\\\d*)?s)|(\\\\d*(\\\\.\\\\d*)?ms)|(\\\\d*(\\\\.\\\\d*)?us)|(\\\\d*(\\\\.\\\\d*)?µs)|(\\\\d*(\\\\.\\\\d*)?ns))+|infinity|infinite)$\",\"type\":\"string\"}},\"type\":\"object\"},\"validation\":{\"description\":\"UpstreamValidation defines how to verify the backend service's certificate\",\"properties\":{\"caSecret\":{\"description\":\"Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend\",\"type\":\"string\"},\"subjectName\":{\"description\":\"Key which is expected to be present in the 'subjectAltName' of the presented certificate\",\"type\":\"string\"}},\"required\":[\"caSecret\",\"subjectName\"],\"type\":\"object\"}},\"required\":[\"services\"],\"type\":\"object\"},\"status\":{\"description\":\"ExtensionServiceStatus defines the observed state of an ExtensionService resource.\",\"properties\":{\"conditions\":{\"description\":\"Conditions contains the current status of the ExtensionService resource. \\n Contour will update a single condition, `Valid`, that is in normal-true polarity. \\n Contour will not modify any other Conditions set in this block, in case some other controller wants to add a Condition.\",\"items\":{\"description\":\"DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \\n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \\n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \\n Remember that Conditions have a type, a status, and a reason. \\n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \\n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \\n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \\n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \\n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.\",\"properties\":{\"errors\":{\"description\":\"Errors contains a slice of relevant error subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"lastTransitionTime\":{\"description\":\"lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.\",\"format\":\"date-time\",\"type\":\"string\"},\"message\":{\"description\":\"message is a human readable message indicating details about the transition. This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"observedGeneration\":{\"description\":\"observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"},\"reason\":{\"description\":\"reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"},\"warnings\":{\"description\":\"Warnings contains a slice of relevant warning subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"lastTransitionTime\",\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-map-keys\":[\"type\"],\"x-kubernetes-list-type\":\"map\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]},\"status\":{\"acceptedNames\":{\"kind\":\"\",\"plural\":\"\"},\"conditions\":[],\"storedVersions\":[]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "projectcontour.io",
        "names": {
          "plural": "extensionservices",
          "singular": "extensionservice",
          "shortNames": [
            "extensionservice",
            "extensionservices"
          ],
          "kind": "ExtensionService",
          "listKind": "ExtensionServiceList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1alpha1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "ExtensionService is the schema for the Contour extension services API. An ExtensionService resource binds a network service to the Contour API so that Contour API features can be implemented by collaborating components.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "ExtensionServiceSpec defines the desired state of an ExtensionService resource.",
                    "type": "object",
                    "required": [
                      "services"
                    ],
                    "properties": {
                      "loadBalancerPolicy": {
                        "description": "The policy for load balancing GRPC service requests. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.",
                        "type": "object",
                        "properties": {
                          "requestHashPolicies": {
                            "description": "RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.",
                            "type": "array",
                            "items": {
                              "description": "RequestHashPolicy contains configuration for an individual hash policy on a request attribute.",
                              "type": "object",
                              "properties": {
                                "hashSourceIP": {
                                  "description": "HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.",
                                  "type": "boolean"
                                },
                                "headerHashOptions": {
                                  "description": "HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.",
                                  "type": "object",
                                  "properties": {
                                    "headerName": {
                                      "description": "HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.",
                                      "type": "string",
                                      "minLength": 1
                                    }
                                  }
                                },
                                "terminal": {
                                  "description": "Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.",
                                  "type": "boolean"
                                }
                              }
                            }
                          },
                          "strategy": {
                            "description": "Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.",
                            "type": "string"
                          }
                        }
                      },
                      "protocol": {
                        "description": "Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be h2 or h2c. If omitted, protocol-selection falls back on Service annotations.",
                        "type": "string",
                        "enum": [
                          "h2",
                          "h2c"
                        ]
                      },
                      "protocolVersion": {
                        "description": "This field sets the version of the GRPC protocol that Envoy uses to send requests to the extension service. Since Contour always uses the v3 Envoy API, this is currently fixed at \"v3\". However, other protocol options will be available in future.",
                        "type": "string",
                        "enum": [
                          "v3"
                        ]
                      },
                      "services": {
                        "description": "Services specifies the set of Kubernetes Service resources that receive GRPC extension API requests. If no weights are specified for any of the entries in this array, traffic will be spread evenly across all the services. Otherwise, traffic is balanced proportionally to the Weight field in each entry.",
                        "type": "array",
                        "minItems": 1,
                        "items": {
                          "description": "ExtensionServiceTarget defines an Kubernetes Service to target with extension service traffic.",
                          "type": "object",
                          "required": [
                            "name",
                            "port"
                          ],
                          "properties": {
                            "name": {
                              "description": "Name is the name of Kubernetes service that will accept service traffic.",
                              "type": "string"
                            },
                            "port": {
                              "description": "Port (defined as Integer) to proxy traffic to since a service can have multiple defined.",
                              "type": "integer",
                              "maximum": 65536,
                              "exclusiveMaximum": true,
                              "minimum": 1
                            },
                            "weight": {
                              "description": "Weight defines proportion of traffic to balance to the Kubernetes Service.",
                              "type": "integer",
                              "format": "int32"
                            }
                          }
                        }
                      },
                      "timeoutPolicy": {
                        "description": "The timeout policy for requests to the services.",
                        "type": "object",
                        "properties": {
                          "idle": {
                            "description": "Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.",
                            "type": "string",
                            "pattern": "^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?µs)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$"
                          },
                          "response": {
                            "description": "Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.",
                            "type": "string",
                            "pattern": "^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?µs)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$"
                          }
                        }
                      },
                      "validation": {
                        "description": "UpstreamValidation defines how to verify the backend service's certificate",
                        "type": "object",
                        "required": [
                          "caSecret",
                          "subjectName"
                        ],
                        "properties": {
                          "caSecret": {
                            "description": "Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend",
                            "type": "string"
                          },
                          "subjectName": {
                            "description": "Key which is expected to be present in the 'subjectAltName' of the presented certificate",
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "ExtensionServiceStatus defines the observed state of an ExtensionService resource.",
                    "type": "object",
                    "properties": {
                      "conditions": {
                        "description": "Conditions contains the current status of the ExtensionService resource. \n Contour will update a single condition, `Valid`, that is in normal-true polarity. \n Contour will not modify any other Conditions set in this block, in case some other controller wants to add a Condition.",
                        "type": "array",
                        "items": {
                          "description": "DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \n Remember that Conditions have a type, a status, and a reason. \n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.",
                          "type": "object",
                          "required": [
                            "lastTransitionTime",
                            "message",
                            "reason",
                            "status",
                            "type"
                          ],
                          "properties": {
                            "errors": {
                              "description": "Errors contains a slice of relevant error subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            },
                            "lastTransitionTime": {
                              "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                              "type": "string",
                              "format": "date-time"
                            },
                            "message": {
                              "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                              "type": "string",
                              "maxLength": 32768
                            },
                            "observedGeneration": {
                              "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                              "type": "integer",
                              "format": "int64",
                              "minimum": 0
                            },
                            "reason": {
                              "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                              "type": "string",
                              "maxLength": 1024,
                              "minLength": 1,
                              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                            },
                            "status": {
                              "description": "status of the condition, one of True, False, Unknown.",
                              "type": "string",
                              "enum": [
                                "True",
                                "False",
                                "Unknown"
                              ]
                            },
                            "type": {
                              "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                              "type": "string",
                              "maxLength": 316,
                              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                            },
                            "warnings": {
                              "description": "Warnings contains a slice of relevant warning subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "type"
                        ],
                        "x-kubernetes-list-type": "map"
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "extensionservices",
          "singular": "extensionservice",
          "shortNames": [
            "extensionservice",
            "extensionservices"
          ],
          "kind": "ExtensionService",
          "listKind": "ExtensionServiceList"
        },
        "storedVersions": [
          "v1alpha1"
        ]
      }
    },
    {
      "metadata": {
        "name": "httpproxies.projectcontour.io",
        "uid": "28911edd-ad71-4e66-be57-1719076d1f7a",
        "resourceVersion": "1535",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:42Z",
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.6.2",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.6.2\"},\"creationTimestamp\":null,\"name\":\"httpproxies.projectcontour.io\"},\"spec\":{\"group\":\"projectcontour.io\",\"names\":{\"kind\":\"HTTPProxy\",\"listKind\":\"HTTPProxyList\",\"plural\":\"httpproxies\",\"shortNames\":[\"proxy\",\"proxies\"],\"singular\":\"httpproxy\"},\"preserveUnknownFields\":false,\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"Fully qualified domain name\",\"jsonPath\":\".spec.virtualhost.fqdn\",\"name\":\"FQDN\",\"type\":\"string\"},{\"description\":\"Secret with TLS credentials\",\"jsonPath\":\".spec.virtualhost.tls.secretName\",\"name\":\"TLS Secret\",\"type\":\"string\"},{\"description\":\"The current status of the HTTPProxy\",\"jsonPath\":\".status.currentStatus\",\"name\":\"Status\",\"type\":\"string\"},{\"description\":\"Description of the current status\",\"jsonPath\":\".status.description\",\"name\":\"Status Description\",\"type\":\"string\"}],\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"HTTPProxy is an Ingress CRD specification.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"HTTPProxySpec defines the spec of the CRD.\",\"properties\":{\"includes\":{\"description\":\"Includes allow for specific routing configuration to be included from another HTTPProxy, possibly in another namespace.\",\"items\":{\"description\":\"Include describes a set of policies that can be applied to an HTTPProxy in a namespace.\",\"properties\":{\"conditions\":{\"description\":\"Conditions are a set of rules that are applied to included HTTPProxies. In effect, they are added onto the Conditions of included HTTPProxy Route structs. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the include invalid.\",\"items\":{\"description\":\"MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix or Header must be provided.\",\"properties\":{\"header\":{\"description\":\"Header specifies the header condition to match.\",\"properties\":{\"contains\":{\"description\":\"Contains specifies a substring that must be present in the header value.\",\"type\":\"string\"},\"exact\":{\"description\":\"Exact specifies a string that the header value must be equal to.\",\"type\":\"string\"},\"name\":{\"description\":\"Name is the name of the header to match against. Name is required. Header names are case insensitive.\",\"type\":\"string\"},\"notcontains\":{\"description\":\"NotContains specifies a substring that must not be present in the header value.\",\"type\":\"string\"},\"notexact\":{\"description\":\"NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.\",\"type\":\"string\"},\"notpresent\":{\"description\":\"NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.\",\"type\":\"boolean\"},\"present\":{\"description\":\"Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"prefix\":{\"description\":\"Prefix defines a prefix match for a request.\",\"type\":\"string\"}},\"type\":\"object\"},\"type\":\"array\"},\"name\":{\"description\":\"Name of the HTTPProxy\",\"type\":\"string\"},\"namespace\":{\"description\":\"Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"ingressClassName\":{\"description\":\"IngressClassName optionally specifies the ingress class to use for this HTTPProxy. This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it is given precedence over this field.\",\"type\":\"string\"},\"routes\":{\"description\":\"Routes are the ingress routes. If TCPProxy is present, Routes is ignored.\",\"items\":{\"description\":\"Route contains the set of routes for a virtual host.\",\"properties\":{\"authPolicy\":{\"description\":\"AuthPolicy updates the authorization policy that was set on the root HTTPProxy object for client requests that match this route.\",\"properties\":{\"context\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.\",\"type\":\"object\"},\"disabled\":{\"description\":\"When true, this field disables client request authentication for the scope of the policy.\",\"type\":\"boolean\"}},\"type\":\"object\"},\"conditions\":{\"description\":\"Conditions are a set of rules that are applied to a Route. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the route invalid.\",\"items\":{\"description\":\"MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix or Header must be provided.\",\"properties\":{\"header\":{\"description\":\"Header specifies the header condition to match.\",\"properties\":{\"contains\":{\"description\":\"Contains specifies a substring that must be present in the header value.\",\"type\":\"string\"},\"exact\":{\"description\":\"Exact specifies a string that the header value must be equal to.\",\"type\":\"string\"},\"name\":{\"description\":\"Name is the name of the header to match against. Name is required. Header names are case insensitive.\",\"type\":\"string\"},\"notcontains\":{\"description\":\"NotContains specifies a substring that must not be present in the header value.\",\"type\":\"string\"},\"notexact\":{\"description\":\"NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.\",\"type\":\"string\"},\"notpresent\":{\"description\":\"NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.\",\"type\":\"boolean\"},\"present\":{\"description\":\"Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"prefix\":{\"description\":\"Prefix defines a prefix match for a request.\",\"type\":\"string\"}},\"type\":\"object\"},\"type\":\"array\"},\"cookieRewritePolicies\":{\"description\":\"The policies for rewriting Set-Cookie header attributes. Note that rewritten cookie names must be unique in this list. Order rewrite policies are specified in does not matter.\",\"items\":{\"properties\":{\"domainRewrite\":{\"description\":\"DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.\",\"properties\":{\"value\":{\"description\":\"Value is the value to rewrite the Domain attribute to. For now this is required.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$\",\"type\":\"string\"}},\"required\":[\"value\"],\"type\":\"object\"},\"name\":{\"description\":\"Name is the name of the cookie for which attributes will be rewritten.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[^()\\u003c\\u003e@,;:\\\\\\\\\\\"\\\\/[\\\\]?={} \\\\t\\\\x7f\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\x09\\\\x0a\\\\x0b\\\\x0c\\\\x0d\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f]+$\",\"type\":\"string\"},\"pathRewrite\":{\"description\":\"PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.\",\"properties\":{\"value\":{\"description\":\"Value is the value to rewrite the Path attribute to. For now this is required.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[^;\\\\x7f\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\x09\\\\x0a\\\\x0b\\\\x0c\\\\x0d\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f]+$\",\"type\":\"string\"}},\"required\":[\"value\"],\"type\":\"object\"},\"sameSite\":{\"description\":\"SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.\",\"enum\":[\"Strict\",\"Lax\",\"None\"],\"type\":\"string\"},\"secure\":{\"description\":\"Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"enableWebsockets\":{\"description\":\"Enables websocket support for the route.\",\"type\":\"boolean\"},\"healthCheckPolicy\":{\"description\":\"The health check policy for this route.\",\"properties\":{\"healthyThresholdCount\":{\"description\":\"The number of healthy health checks required before a host is marked healthy\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"},\"host\":{\"description\":\"The value of the host header in the HTTP health check request. If left empty (default value), the name \\\"contour-envoy-healthcheck\\\" will be used.\",\"type\":\"string\"},\"intervalSeconds\":{\"description\":\"The interval (seconds) between health checks\",\"format\":\"int64\",\"type\":\"integer\"},\"path\":{\"description\":\"HTTP endpoint used to perform health checks on upstream service\",\"type\":\"string\"},\"timeoutSeconds\":{\"description\":\"The time to wait (seconds) for a health check response\",\"format\":\"int64\",\"type\":\"integer\"},\"unhealthyThresholdCount\":{\"description\":\"The number of unhealthy health checks required before a host is marked unhealthy\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"}},\"required\":[\"path\"],\"type\":\"object\"},\"loadBalancerPolicy\":{\"description\":\"The load balancing policy for this route.\",\"properties\":{\"requestHashPolicies\":{\"description\":\"RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.\",\"items\":{\"description\":\"RequestHashPolicy contains configuration for an individual hash policy on a request attribute.\",\"properties\":{\"hashSourceIP\":{\"description\":\"HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.\",\"type\":\"boolean\"},\"headerHashOptions\":{\"description\":\"HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.\",\"properties\":{\"headerName\":{\"description\":\"HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"terminal\":{\"description\":\"Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.\",\"type\":\"boolean\"}},\"type\":\"object\"},\"type\":\"array\"},\"strategy\":{\"description\":\"Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.\",\"type\":\"string\"}},\"type\":\"object\"},\"pathRewritePolicy\":{\"description\":\"The policy for rewriting the path of the request URL after the request has been routed to a Service.\",\"properties\":{\"replacePrefix\":{\"description\":\"ReplacePrefix describes how the path prefix should be replaced.\",\"items\":{\"description\":\"ReplacePrefix describes a path prefix replacement.\",\"properties\":{\"prefix\":{\"description\":\"Prefix specifies the URL path prefix to be replaced. \\n If Prefix is specified, it must exactly match the MatchCondition prefix that is rendered by the chain of including HTTPProxies and only that path prefix will be replaced by Replacement. This allows HTTPProxies that are included through multiple roots to only replace specific path prefixes, leaving others unmodified. \\n If Prefix is not specified, all routing prefixes rendered by the include chain will be replaced.\",\"minLength\":1,\"type\":\"string\"},\"replacement\":{\"description\":\"Replacement is the string that the routing path prefix will be replaced with. This must not be empty.\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"replacement\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"permitInsecure\":{\"description\":\"Allow this path to respond to insecure requests over HTTP which are normally not permitted when a `virtualhost.tls` block is present.\",\"type\":\"boolean\"},\"rateLimitPolicy\":{\"description\":\"The policy for rate limiting on the route.\",\"properties\":{\"global\":{\"description\":\"Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.\",\"properties\":{\"descriptors\":{\"description\":\"Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.\",\"items\":{\"description\":\"RateLimitDescriptor defines a list of key-value pair generators.\",\"properties\":{\"entries\":{\"description\":\"Entries is the list of key-value pair generators.\",\"items\":{\"description\":\"RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.\",\"properties\":{\"genericKey\":{\"description\":\"GenericKey defines a descriptor entry with a static key and value.\",\"properties\":{\"key\":{\"description\":\"Key defines the key of the descriptor entry. If not set, the key is set to \\\"generic_key\\\".\",\"type\":\"string\"},\"value\":{\"description\":\"Value defines the value of the descriptor entry.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"remoteAddress\":{\"description\":\"RemoteAddress defines a descriptor entry with a key of \\\"remote_address\\\" and a value equal to the client's IP address (from x-forwarded-for).\",\"type\":\"object\"},\"requestHeader\":{\"description\":\"RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.\",\"properties\":{\"descriptorKey\":{\"description\":\"DescriptorKey defines the key to use on the descriptor entry.\",\"minLength\":1,\"type\":\"string\"},\"headerName\":{\"description\":\"HeaderName defines the name of the header to look for on the request.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"requestHeaderValueMatch\":{\"description\":\"RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is \\\"header_match\\\", and the descriptor value is static.\",\"properties\":{\"expectMatch\":{\"default\":true,\"description\":\"ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.\",\"type\":\"boolean\"},\"headers\":{\"description\":\"Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.\",\"items\":{\"description\":\"HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.\",\"properties\":{\"contains\":{\"description\":\"Contains specifies a substring that must be present in the header value.\",\"type\":\"string\"},\"exact\":{\"description\":\"Exact specifies a string that the header value must be equal to.\",\"type\":\"string\"},\"name\":{\"description\":\"Name is the name of the header to match against. Name is required. Header names are case insensitive.\",\"type\":\"string\"},\"notcontains\":{\"description\":\"NotContains specifies a substring that must not be present in the header value.\",\"type\":\"string\"},\"notexact\":{\"description\":\"NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.\",\"type\":\"string\"},\"notpresent\":{\"description\":\"NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.\",\"type\":\"boolean\"},\"present\":{\"description\":\"Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"},\"value\":{\"description\":\"Value defines the value of the descriptor entry.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"}},\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"}},\"type\":\"object\"},\"local\":{\"description\":\"Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.\",\"properties\":{\"burst\":{\"description\":\"Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.\",\"format\":\"int32\",\"type\":\"integer\"},\"requests\":{\"description\":\"Requests defines how many requests per unit of time should be allowed before rate limiting occurs.\",\"format\":\"int32\",\"minimum\":1,\"type\":\"integer\"},\"responseHeadersToAdd\":{\"description\":\"ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"responseStatusCode\":{\"description\":\"ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.\",\"format\":\"int32\",\"maximum\":599,\"minimum\":400,\"type\":\"integer\"},\"unit\":{\"description\":\"Unit defines the period of time within which requests over the limit will be rate limited. Valid values are \\\"second\\\", \\\"minute\\\" and \\\"hour\\\".\",\"enum\":[\"second\",\"minute\",\"hour\"],\"type\":\"string\"}},\"required\":[\"requests\",\"unit\"],\"type\":\"object\"}},\"type\":\"object\"},\"requestHeadersPolicy\":{\"description\":\"The policy for managing request headers during proxying.\",\"properties\":{\"remove\":{\"description\":\"Remove specifies a list of HTTP header names to remove.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"description\":\"Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"requestRedirectPolicy\":{\"description\":\"RequestRedirectPolicy defines an HTTP redirection.\",\"properties\":{\"hostname\":{\"description\":\"Hostname is the precise hostname to be used in the value of the `Location` header in the response. When empty, the hostname of the request is used. No wildcards are allowed.\",\"maxLength\":253,\"minLength\":1,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$\",\"type\":\"string\"},\"path\":{\"description\":\"Path allows for redirection to a different path from the original on the request. The path must start with a leading slash. \\n Note: Only one of Path or Prefix can be defined.\",\"pattern\":\"^\\\\/.*$\",\"type\":\"string\"},\"port\":{\"description\":\"Port is the port to be used in the value of the `Location` header in the response. When empty, port (if specified) of the request is used.\",\"format\":\"int32\",\"maximum\":65535,\"minimum\":1,\"type\":\"integer\"},\"prefix\":{\"description\":\"Prefix defines the value to swap the matched prefix or path with. The prefix must start with a leading slash. \\n Note: Only one of Path or Prefix can be defined.\",\"pattern\":\"^\\\\/.*$\",\"type\":\"string\"},\"scheme\":{\"description\":\"Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.\",\"enum\":[\"http\",\"https\"],\"type\":\"string\"},\"statusCode\":{\"default\":302,\"description\":\"StatusCode is the HTTP status code to be used in response.\",\"enum\":[301,302],\"type\":\"integer\"}},\"type\":\"object\"},\"responseHeadersPolicy\":{\"description\":\"The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.\",\"properties\":{\"remove\":{\"description\":\"Remove specifies a list of HTTP header names to remove.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"description\":\"Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"retryPolicy\":{\"description\":\"The retry policy for this route.\",\"properties\":{\"count\":{\"default\":1,\"description\":\"NumRetries is maximum allowed number of retries. If set to -1, then retries are disabled. If set to 0 or not supplied, the value is set to the Envoy default of 1.\",\"format\":\"int64\",\"minimum\":-1,\"type\":\"integer\"},\"perTryTimeout\":{\"description\":\"PerTryTimeout specifies the timeout per retry attempt. Ignored if NumRetries is not supplied.\",\"pattern\":\"^(((\\\\d*(\\\\.\\\\d*)?h)|(\\\\d*(\\\\.\\\\d*)?m)|(\\\\d*(\\\\.\\\\d*)?s)|(\\\\d*(\\\\.\\\\d*)?ms)|(\\\\d*(\\\\.\\\\d*)?us)|(\\\\d*(\\\\.\\\\d*)?µs)|(\\\\d*(\\\\.\\\\d*)?ns))+|infinity|infinite)$\",\"type\":\"string\"},\"retriableStatusCodes\":{\"description\":\"RetriableStatusCodes specifies the HTTP status codes that should be retried. \\n This field is only respected when you include `retriable-status-codes` in the `RetryOn` field.\",\"items\":{\"format\":\"int32\",\"type\":\"integer\"},\"type\":\"array\"},\"retryOn\":{\"description\":\"RetryOn specifies the conditions on which to retry a request. \\n Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on): \\n - `5xx` - `gateway-error` - `reset` - `connect-failure` - `retriable-4xx` - `refused-stream` - `retriable-status-codes` - `retriable-headers` \\n Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on): \\n - `cancelled` - `deadline-exceeded` - `internal` - `resource-exhausted` - `unavailable`\",\"items\":{\"description\":\"RetryOn is a string type alias with validation to ensure that the value is valid.\",\"enum\":[\"5xx\",\"gateway-error\",\"reset\",\"connect-failure\",\"retriable-4xx\",\"refused-stream\",\"retriable-status-codes\",\"retriable-headers\",\"cancelled\",\"deadline-exceeded\",\"internal\",\"resource-exhausted\",\"unavailable\"],\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"services\":{\"description\":\"Services are the services to proxy traffic.\",\"items\":{\"description\":\"Service defines an Kubernetes Service to proxy traffic.\",\"properties\":{\"cookieRewritePolicies\":{\"description\":\"The policies for rewriting Set-Cookie header attributes.\",\"items\":{\"properties\":{\"domainRewrite\":{\"description\":\"DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.\",\"properties\":{\"value\":{\"description\":\"Value is the value to rewrite the Domain attribute to. For now this is required.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$\",\"type\":\"string\"}},\"required\":[\"value\"],\"type\":\"object\"},\"name\":{\"description\":\"Name is the name of the cookie for which attributes will be rewritten.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[^()\\u003c\\u003e@,;:\\\\\\\\\\\"\\\\/[\\\\]?={} \\\\t\\\\x7f\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\x09\\\\x0a\\\\x0b\\\\x0c\\\\x0d\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f]+$\",\"type\":\"string\"},\"pathRewrite\":{\"description\":\"PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.\",\"properties\":{\"value\":{\"description\":\"Value is the value to rewrite the Path attribute to. For now this is required.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[^;\\\\x7f\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\x09\\\\x0a\\\\x0b\\\\x0c\\\\x0d\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f]+$\",\"type\":\"string\"}},\"required\":[\"value\"],\"type\":\"object\"},\"sameSite\":{\"description\":\"SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.\",\"enum\":[\"Strict\",\"Lax\",\"None\"],\"type\":\"string\"},\"secure\":{\"description\":\"Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"mirror\":{\"description\":\"If Mirror is true the Service will receive a read only mirror of the traffic for this route.\",\"type\":\"boolean\"},\"name\":{\"description\":\"Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.\",\"type\":\"string\"},\"port\":{\"description\":\"Port (defined as Integer) to proxy traffic to since a service can have multiple defined.\",\"exclusiveMaximum\":true,\"maximum\":65536,\"minimum\":1,\"type\":\"integer\"},\"protocol\":{\"description\":\"Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.\",\"enum\":[\"h2\",\"h2c\",\"tls\"],\"type\":\"string\"},\"requestHeadersPolicy\":{\"description\":\"The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.\",\"properties\":{\"remove\":{\"description\":\"Remove specifies a list of HTTP header names to remove.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"description\":\"Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"responseHeadersPolicy\":{\"description\":\"The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.\",\"properties\":{\"remove\":{\"description\":\"Remove specifies a list of HTTP header names to remove.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"description\":\"Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"validation\":{\"description\":\"UpstreamValidation defines how to verify the backend service's certificate\",\"properties\":{\"caSecret\":{\"description\":\"Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend\",\"type\":\"string\"},\"subjectName\":{\"description\":\"Key which is expected to be present in the 'subjectAltName' of the presented certificate\",\"type\":\"string\"}},\"required\":[\"caSecret\",\"subjectName\"],\"type\":\"object\"},\"weight\":{\"description\":\"Weight defines percentage of traffic to balance traffic\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"}},\"required\":[\"name\",\"port\"],\"type\":\"object\"},\"type\":\"array\"},\"timeoutPolicy\":{\"description\":\"The timeout policy for this route.\",\"properties\":{\"idle\":{\"description\":\"Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.\",\"pattern\":\"^(((\\\\d*(\\\\.\\\\d*)?h)|(\\\\d*(\\\\.\\\\d*)?m)|(\\\\d*(\\\\.\\\\d*)?s)|(\\\\d*(\\\\.\\\\d*)?ms)|(\\\\d*(\\\\.\\\\d*)?us)|(\\\\d*(\\\\.\\\\d*)?µs)|(\\\\d*(\\\\.\\\\d*)?ns))+|infinity|infinite)$\",\"type\":\"string\"},\"response\":{\"description\":\"Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.\",\"pattern\":\"^(((\\\\d*(\\\\.\\\\d*)?h)|(\\\\d*(\\\\.\\\\d*)?m)|(\\\\d*(\\\\.\\\\d*)?s)|(\\\\d*(\\\\.\\\\d*)?ms)|(\\\\d*(\\\\.\\\\d*)?us)|(\\\\d*(\\\\.\\\\d*)?µs)|(\\\\d*(\\\\.\\\\d*)?ns))+|infinity|infinite)$\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"},\"tcpproxy\":{\"description\":\"TCPProxy holds TCP proxy information.\",\"properties\":{\"healthCheckPolicy\":{\"description\":\"The health check policy for this tcp proxy\",\"properties\":{\"healthyThresholdCount\":{\"description\":\"The number of healthy health checks required before a host is marked healthy\",\"format\":\"int32\",\"type\":\"integer\"},\"intervalSeconds\":{\"description\":\"The interval (seconds) between health checks\",\"format\":\"int64\",\"type\":\"integer\"},\"timeoutSeconds\":{\"description\":\"The time to wait (seconds) for a health check response\",\"format\":\"int64\",\"type\":\"integer\"},\"unhealthyThresholdCount\":{\"description\":\"The number of unhealthy health checks required before a host is marked unhealthy\",\"format\":\"int32\",\"type\":\"integer\"}},\"type\":\"object\"},\"include\":{\"description\":\"Include specifies that this tcpproxy should be delegated to another HTTPProxy.\",\"properties\":{\"name\":{\"description\":\"Name of the child HTTPProxy\",\"type\":\"string\"},\"namespace\":{\"description\":\"Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"includes\":{\"description\":\"IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace. \\n Exists due to a mistake when developing HTTPProxy and the field was marked plural when it should have been singular. This field should stay to not break backwards compatibility to v1 users.\",\"properties\":{\"name\":{\"description\":\"Name of the child HTTPProxy\",\"type\":\"string\"},\"namespace\":{\"description\":\"Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"loadBalancerPolicy\":{\"description\":\"The load balancing policy for the backend services. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.\",\"properties\":{\"requestHashPolicies\":{\"description\":\"RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.\",\"items\":{\"description\":\"RequestHashPolicy contains configuration for an individual hash policy on a request attribute.\",\"properties\":{\"hashSourceIP\":{\"description\":\"HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.\",\"type\":\"boolean\"},\"headerHashOptions\":{\"description\":\"HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.\",\"properties\":{\"headerName\":{\"description\":\"HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"terminal\":{\"description\":\"Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.\",\"type\":\"boolean\"}},\"type\":\"object\"},\"type\":\"array\"},\"strategy\":{\"description\":\"Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.\",\"type\":\"string\"}},\"type\":\"object\"},\"services\":{\"description\":\"Services are the services to proxy traffic\",\"items\":{\"description\":\"Service defines an Kubernetes Service to proxy traffic.\",\"properties\":{\"cookieRewritePolicies\":{\"description\":\"The policies for rewriting Set-Cookie header attributes.\",\"items\":{\"properties\":{\"domainRewrite\":{\"description\":\"DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.\",\"properties\":{\"value\":{\"description\":\"Value is the value to rewrite the Domain attribute to. For now this is required.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$\",\"type\":\"string\"}},\"required\":[\"value\"],\"type\":\"object\"},\"name\":{\"description\":\"Name is the name of the cookie for which attributes will be rewritten.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[^()\\u003c\\u003e@,;:\\\\\\\\\\\"\\\\/[\\\\]?={} \\\\t\\\\x7f\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\x09\\\\x0a\\\\x0b\\\\x0c\\\\x0d\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f]+$\",\"type\":\"string\"},\"pathRewrite\":{\"description\":\"PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.\",\"properties\":{\"value\":{\"description\":\"Value is the value to rewrite the Path attribute to. For now this is required.\",\"maxLength\":4096,\"minLength\":1,\"pattern\":\"^[^;\\\\x7f\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\x09\\\\x0a\\\\x0b\\\\x0c\\\\x0d\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f]+$\",\"type\":\"string\"}},\"required\":[\"value\"],\"type\":\"object\"},\"sameSite\":{\"description\":\"SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.\",\"enum\":[\"Strict\",\"Lax\",\"None\"],\"type\":\"string\"},\"secure\":{\"description\":\"Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"mirror\":{\"description\":\"If Mirror is true the Service will receive a read only mirror of the traffic for this route.\",\"type\":\"boolean\"},\"name\":{\"description\":\"Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.\",\"type\":\"string\"},\"port\":{\"description\":\"Port (defined as Integer) to proxy traffic to since a service can have multiple defined.\",\"exclusiveMaximum\":true,\"maximum\":65536,\"minimum\":1,\"type\":\"integer\"},\"protocol\":{\"description\":\"Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.\",\"enum\":[\"h2\",\"h2c\",\"tls\"],\"type\":\"string\"},\"requestHeadersPolicy\":{\"description\":\"The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.\",\"properties\":{\"remove\":{\"description\":\"Remove specifies a list of HTTP header names to remove.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"description\":\"Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"responseHeadersPolicy\":{\"description\":\"The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.\",\"properties\":{\"remove\":{\"description\":\"Remove specifies a list of HTTP header names to remove.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"set\":{\"description\":\"Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"validation\":{\"description\":\"UpstreamValidation defines how to verify the backend service's certificate\",\"properties\":{\"caSecret\":{\"description\":\"Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend\",\"type\":\"string\"},\"subjectName\":{\"description\":\"Key which is expected to be present in the 'subjectAltName' of the presented certificate\",\"type\":\"string\"}},\"required\":[\"caSecret\",\"subjectName\"],\"type\":\"object\"},\"weight\":{\"description\":\"Weight defines percentage of traffic to balance traffic\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"}},\"required\":[\"name\",\"port\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"virtualhost\":{\"description\":\"Virtualhost appears at most once. If it is present, the object is considered to be a \\\"root\\\" HTTPProxy.\",\"properties\":{\"authorization\":{\"description\":\"This field configures an extension service to perform authorization for this virtual host. Authorization can only be configured on virtual hosts that have TLS enabled. If the TLS configuration requires client certificate validation, the client certificate is always included in the authentication check request.\",\"properties\":{\"authPolicy\":{\"description\":\"AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.\",\"properties\":{\"context\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.\",\"type\":\"object\"},\"disabled\":{\"description\":\"When true, this field disables client request authentication for the scope of the policy.\",\"type\":\"boolean\"}},\"type\":\"object\"},\"extensionRef\":{\"description\":\"ExtensionServiceRef specifies the extension resource that will authorize client requests.\",\"properties\":{\"apiVersion\":{\"description\":\"API version of the referent. If this field is not specified, the default \\\"projectcontour.io/v1alpha1\\\" will be used\",\"minLength\":1,\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\",\"minLength\":1,\"type\":\"string\"},\"namespace\":{\"description\":\"Namespace of the referent. If this field is not specifies, the namespace of the resource that targets the referent will be used. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"failOpen\":{\"description\":\"If FailOpen is true, the client request is forwarded to the upstream service even if the authorization server fails to respond. This field should not be set in most cases. It is intended for use only while migrating applications from internal authorization to Contour external authorization.\",\"type\":\"boolean\"},\"responseTimeout\":{\"description\":\"ResponseTimeout configures maximum time to wait for a check response from the authorization server. Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are \\\"ns\\\", \\\"us\\\" (or \\\"µs\\\"), \\\"ms\\\", \\\"s\\\", \\\"m\\\", \\\"h\\\". The string \\\"infinity\\\" is also a valid input and specifies no timeout.\",\"pattern\":\"^(((\\\\d*(\\\\.\\\\d*)?h)|(\\\\d*(\\\\.\\\\d*)?m)|(\\\\d*(\\\\.\\\\d*)?s)|(\\\\d*(\\\\.\\\\d*)?ms)|(\\\\d*(\\\\.\\\\d*)?us)|(\\\\d*(\\\\.\\\\d*)?µs)|(\\\\d*(\\\\.\\\\d*)?ns))+|infinity|infinite)$\",\"type\":\"string\"},\"withRequestBody\":{\"description\":\"WithRequestBody specifies configuration for sending the client request's body to authorization server.\",\"properties\":{\"allowPartialMessage\":{\"description\":\"If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.\",\"type\":\"boolean\"},\"maxRequestBytes\":{\"default\":1024,\"description\":\"MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.\",\"format\":\"int32\",\"minimum\":1,\"type\":\"integer\"},\"packAsBytes\":{\"description\":\"If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.\",\"type\":\"boolean\"}},\"type\":\"object\"}},\"required\":[\"extensionRef\"],\"type\":\"object\"},\"corsPolicy\":{\"description\":\"Specifies the cross-origin policy to apply to the VirtualHost.\",\"properties\":{\"allowCredentials\":{\"description\":\"Specifies whether the resource allows credentials.\",\"type\":\"boolean\"},\"allowHeaders\":{\"description\":\"AllowHeaders specifies the content for the *access-control-allow-headers* header.\",\"items\":{\"description\":\"CORSHeaderValue specifies the value of the string headers returned by a cross-domain request.\",\"pattern\":\"^[a-zA-Z0-9!#$%\\u0026'*+.^_`|~-]+$\",\"type\":\"string\"},\"type\":\"array\"},\"allowMethods\":{\"description\":\"AllowMethods specifies the content for the *access-control-allow-methods* header.\",\"items\":{\"description\":\"CORSHeaderValue specifies the value of the string headers returned by a cross-domain request.\",\"pattern\":\"^[a-zA-Z0-9!#$%\\u0026'*+.^_`|~-]+$\",\"type\":\"string\"},\"type\":\"array\"},\"allowOrigin\":{\"description\":\"AllowOrigin specifies the origins that will be allowed to do CORS requests. \\\"*\\\" means allow any origin.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"exposeHeaders\":{\"description\":\"ExposeHeaders Specifies the content for the *access-control-expose-headers* header.\",\"items\":{\"description\":\"CORSHeaderValue specifies the value of the string headers returned by a cross-domain request.\",\"pattern\":\"^[a-zA-Z0-9!#$%\\u0026'*+.^_`|~-]+$\",\"type\":\"string\"},\"type\":\"array\"},\"maxAge\":{\"description\":\"MaxAge indicates for how long the results of a preflight request can be cached. MaxAge durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are \\\"ns\\\", \\\"us\\\" (or \\\"µs\\\"), \\\"ms\\\", \\\"s\\\", \\\"m\\\", \\\"h\\\". Only positive values are allowed while 0 disables the cache requiring a preflight OPTIONS check for all cross-origin requests.\",\"type\":\"string\"}},\"required\":[\"allowMethods\",\"allowOrigin\"],\"type\":\"object\"},\"fqdn\":{\"description\":\"The fully qualified domain name of the root of the ingress tree all leaves of the DAG rooted at this object relate to the fqdn.\",\"pattern\":\"^(\\\\*\\\\.)?[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$\",\"type\":\"string\"},\"rateLimitPolicy\":{\"description\":\"The policy for rate limiting on the virtual host.\",\"properties\":{\"global\":{\"description\":\"Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.\",\"properties\":{\"descriptors\":{\"description\":\"Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.\",\"items\":{\"description\":\"RateLimitDescriptor defines a list of key-value pair generators.\",\"properties\":{\"entries\":{\"description\":\"Entries is the list of key-value pair generators.\",\"items\":{\"description\":\"RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.\",\"properties\":{\"genericKey\":{\"description\":\"GenericKey defines a descriptor entry with a static key and value.\",\"properties\":{\"key\":{\"description\":\"Key defines the key of the descriptor entry. If not set, the key is set to \\\"generic_key\\\".\",\"type\":\"string\"},\"value\":{\"description\":\"Value defines the value of the descriptor entry.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"remoteAddress\":{\"description\":\"RemoteAddress defines a descriptor entry with a key of \\\"remote_address\\\" and a value equal to the client's IP address (from x-forwarded-for).\",\"type\":\"object\"},\"requestHeader\":{\"description\":\"RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.\",\"properties\":{\"descriptorKey\":{\"description\":\"DescriptorKey defines the key to use on the descriptor entry.\",\"minLength\":1,\"type\":\"string\"},\"headerName\":{\"description\":\"HeaderName defines the name of the header to look for on the request.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"},\"requestHeaderValueMatch\":{\"description\":\"RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is \\\"header_match\\\", and the descriptor value is static.\",\"properties\":{\"expectMatch\":{\"default\":true,\"description\":\"ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.\",\"type\":\"boolean\"},\"headers\":{\"description\":\"Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.\",\"items\":{\"description\":\"HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.\",\"properties\":{\"contains\":{\"description\":\"Contains specifies a substring that must be present in the header value.\",\"type\":\"string\"},\"exact\":{\"description\":\"Exact specifies a string that the header value must be equal to.\",\"type\":\"string\"},\"name\":{\"description\":\"Name is the name of the header to match against. Name is required. Header names are case insensitive.\",\"type\":\"string\"},\"notcontains\":{\"description\":\"NotContains specifies a substring that must not be present in the header value.\",\"type\":\"string\"},\"notexact\":{\"description\":\"NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.\",\"type\":\"string\"},\"notpresent\":{\"description\":\"NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.\",\"type\":\"boolean\"},\"present\":{\"description\":\"Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.\",\"type\":\"boolean\"}},\"required\":[\"name\"],\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"},\"value\":{\"description\":\"Value defines the value of the descriptor entry.\",\"minLength\":1,\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"}},\"type\":\"object\"},\"minItems\":1,\"type\":\"array\"}},\"type\":\"object\"},\"local\":{\"description\":\"Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.\",\"properties\":{\"burst\":{\"description\":\"Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.\",\"format\":\"int32\",\"type\":\"integer\"},\"requests\":{\"description\":\"Requests defines how many requests per unit of time should be allowed before rate limiting occurs.\",\"format\":\"int32\",\"minimum\":1,\"type\":\"integer\"},\"responseHeadersToAdd\":{\"description\":\"ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.\",\"items\":{\"description\":\"HeaderValue represents a header name/value pair\",\"properties\":{\"name\":{\"description\":\"Name represents a key of a header\",\"minLength\":1,\"type\":\"string\"},\"value\":{\"description\":\"Value represents the value of a header specified by a key\",\"minLength\":1,\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"responseStatusCode\":{\"description\":\"ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.\",\"format\":\"int32\",\"maximum\":599,\"minimum\":400,\"type\":\"integer\"},\"unit\":{\"description\":\"Unit defines the period of time within which requests over the limit will be rate limited. Valid values are \\\"second\\\", \\\"minute\\\" and \\\"hour\\\".\",\"enum\":[\"second\",\"minute\",\"hour\"],\"type\":\"string\"}},\"required\":[\"requests\",\"unit\"],\"type\":\"object\"}},\"type\":\"object\"},\"tls\":{\"description\":\"If present the fields describes TLS properties of the virtual host. The SNI names that will be matched on are described in fqdn, the tls.secretName secret must contain a certificate that itself contains a name that matches the FQDN.\",\"properties\":{\"clientValidation\":{\"description\":\"ClientValidation defines how to verify the client certificate when an external client establishes a TLS connection to Envoy. \\n This setting: \\n 1. Enables TLS client certificate validation. 2. Specifies how the client certificate will be validated (i.e.    validation required or skipped). \\n Note: Setting client certificate validation to be skipped should be only used in conjunction with an external authorization server that performs client validation as Contour will ensure client certificates are passed along.\",\"properties\":{\"caSecret\":{\"description\":\"Name of a Kubernetes secret that contains a CA certificate bundle. The client certificate must validate against the certificates in the bundle. If specified and SkipClientCertValidation is true, client certificates will be required on requests.\",\"minLength\":1,\"type\":\"string\"},\"skipClientCertValidation\":{\"description\":\"SkipClientCertValidation disables downstream client certificate validation. Defaults to false. This field is intended to be used in conjunction with external authorization in order to enable the external authorization server to validate client certificates. When this field is set to true, client certificates are requested but not verified by Envoy. If CACertificate is specified, client certificates are required on requests, but not verified. If external authorization is in use, they are presented to the external authorization server.\",\"type\":\"boolean\"}},\"type\":\"object\"},\"enableFallbackCertificate\":{\"description\":\"EnableFallbackCertificate defines if the vhost should allow a default certificate to be applied which handles all requests which don't match the SNI defined in this vhost.\",\"type\":\"boolean\"},\"minimumProtocolVersion\":{\"description\":\"MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`. Any other value defaults to TLS 1.2.\",\"type\":\"string\"},\"passthrough\":{\"description\":\"Passthrough defines whether the encrypted TLS handshake will be passed through to the backing cluster. Either Passthrough or SecretName must be specified, but not both.\",\"type\":\"boolean\"},\"secretName\":{\"description\":\"SecretName is the name of a TLS secret in the current namespace. Either SecretName or Passthrough must be specified, but not both. If specified, the named secret must contain a matching certificate for the virtual host's FQDN.\",\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"fqdn\"],\"type\":\"object\"}},\"type\":\"object\"},\"status\":{\"default\":{\"currentStatus\":\"NotReconciled\",\"description\":\"Waiting for controller\"},\"description\":\"Status is a container for computed information about the HTTPProxy.\",\"properties\":{\"conditions\":{\"description\":\"Conditions contains information about the current status of the HTTPProxy, in an upstream-friendly container. \\n Contour will update a single condition, `Valid`, that is in normal-true polarity. That is, when `currentStatus` is `valid`, the `Valid` condition will be `status: true`, and vice versa. \\n Contour will leave untouched any other Conditions set in this block, in case some other controller wants to add a Condition. \\n If you are another controller owner and wish to add a condition, you *should* namespace your condition with a label, like `controller.domain.com/ConditionName`.\",\"items\":{\"description\":\"DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \\n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \\n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \\n Remember that Conditions have a type, a status, and a reason. \\n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \\n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \\n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \\n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \\n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.\",\"properties\":{\"errors\":{\"description\":\"Errors contains a slice of relevant error subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"lastTransitionTime\":{\"description\":\"lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.\",\"format\":\"date-time\",\"type\":\"string\"},\"message\":{\"description\":\"message is a human readable message indicating details about the transition. This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"observedGeneration\":{\"description\":\"observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"},\"reason\":{\"description\":\"reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"},\"warnings\":{\"description\":\"Warnings contains a slice of relevant warning subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"lastTransitionTime\",\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-map-keys\":[\"type\"],\"x-kubernetes-list-type\":\"map\"},\"currentStatus\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"loadBalancer\":{\"description\":\"LoadBalancer contains the current status of the load balancer.\",\"properties\":{\"ingress\":{\"description\":\"Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.\",\"items\":{\"description\":\"LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.\",\"properties\":{\"hostname\":{\"description\":\"Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)\",\"type\":\"string\"},\"ip\":{\"description\":\"IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)\",\"type\":\"string\"},\"ports\":{\"description\":\"Ports is a list of records of service ports If used, every port defined in the service should have an entry in it\",\"items\":{\"properties\":{\"error\":{\"description\":\"Error is to record the problem with the service port The format of the error shall comply with the following rules: - built-in error values shall be specified in this file and those shall use   CamelCase names - cloud provider specific error values must have names that comply with the   format foo.example.com/CamelCase. --- The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"},\"port\":{\"description\":\"Port is the port number of the service port of which status is recorded here\",\"format\":\"int32\",\"type\":\"integer\"},\"protocol\":{\"default\":\"TCP\",\"description\":\"Protocol is the protocol of the service port of which status is recorded here The supported values are: \\\"TCP\\\", \\\"UDP\\\", \\\"SCTP\\\"\",\"type\":\"string\"}},\"required\":[\"port\",\"protocol\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-type\":\"atomic\"}},\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"required\":[\"metadata\",\"spec\"],\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]},\"status\":{\"acceptedNames\":{\"kind\":\"\",\"plural\":\"\"},\"conditions\":[],\"storedVersions\":[]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "projectcontour.io",
        "names": {
          "plural": "httpproxies",
          "singular": "httpproxy",
          "shortNames": [
            "proxy",
            "proxies"
          ],
          "kind": "HTTPProxy",
          "listKind": "HTTPProxyList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "HTTPProxy is an Ingress CRD specification.",
                "type": "object",
                "required": [
                  "metadata",
                  "spec"
                ],
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "HTTPProxySpec defines the spec of the CRD.",
                    "type": "object",
                    "properties": {
                      "includes": {
                        "description": "Includes allow for specific routing configuration to be included from another HTTPProxy, possibly in another namespace.",
                        "type": "array",
                        "items": {
                          "description": "Include describes a set of policies that can be applied to an HTTPProxy in a namespace.",
                          "type": "object",
                          "required": [
                            "name"
                          ],
                          "properties": {
                            "conditions": {
                              "description": "Conditions are a set of rules that are applied to included HTTPProxies. In effect, they are added onto the Conditions of included HTTPProxy Route structs. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the include invalid.",
                              "type": "array",
                              "items": {
                                "description": "MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix or Header must be provided.",
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "description": "Header specifies the header condition to match.",
                                    "type": "object",
                                    "required": [
                                      "name"
                                    ],
                                    "properties": {
                                      "contains": {
                                        "description": "Contains specifies a substring that must be present in the header value.",
                                        "type": "string"
                                      },
                                      "exact": {
                                        "description": "Exact specifies a string that the header value must be equal to.",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "Name is the name of the header to match against. Name is required. Header names are case insensitive.",
                                        "type": "string"
                                      },
                                      "notcontains": {
                                        "description": "NotContains specifies a substring that must not be present in the header value.",
                                        "type": "string"
                                      },
                                      "notexact": {
                                        "description": "NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.",
                                        "type": "string"
                                      },
                                      "notpresent": {
                                        "description": "NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.",
                                        "type": "boolean"
                                      },
                                      "present": {
                                        "description": "Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.",
                                        "type": "boolean"
                                      }
                                    }
                                  },
                                  "prefix": {
                                    "description": "Prefix defines a prefix match for a request.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "name": {
                              "description": "Name of the HTTPProxy",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "ingressClassName": {
                        "description": "IngressClassName optionally specifies the ingress class to use for this HTTPProxy. This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it is given precedence over this field.",
                        "type": "string"
                      },
                      "routes": {
                        "description": "Routes are the ingress routes. If TCPProxy is present, Routes is ignored.",
                        "type": "array",
                        "items": {
                          "description": "Route contains the set of routes for a virtual host.",
                          "type": "object",
                          "properties": {
                            "authPolicy": {
                              "description": "AuthPolicy updates the authorization policy that was set on the root HTTPProxy object for client requests that match this route.",
                              "type": "object",
                              "properties": {
                                "context": {
                                  "description": "Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.",
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "disabled": {
                                  "description": "When true, this field disables client request authentication for the scope of the policy.",
                                  "type": "boolean"
                                }
                              }
                            },
                            "conditions": {
                              "description": "Conditions are a set of rules that are applied to a Route. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the route invalid.",
                              "type": "array",
                              "items": {
                                "description": "MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix or Header must be provided.",
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "description": "Header specifies the header condition to match.",
                                    "type": "object",
                                    "required": [
                                      "name"
                                    ],
                                    "properties": {
                                      "contains": {
                                        "description": "Contains specifies a substring that must be present in the header value.",
                                        "type": "string"
                                      },
                                      "exact": {
                                        "description": "Exact specifies a string that the header value must be equal to.",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "Name is the name of the header to match against. Name is required. Header names are case insensitive.",
                                        "type": "string"
                                      },
                                      "notcontains": {
                                        "description": "NotContains specifies a substring that must not be present in the header value.",
                                        "type": "string"
                                      },
                                      "notexact": {
                                        "description": "NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.",
                                        "type": "string"
                                      },
                                      "notpresent": {
                                        "description": "NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.",
                                        "type": "boolean"
                                      },
                                      "present": {
                                        "description": "Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.",
                                        "type": "boolean"
                                      }
                                    }
                                  },
                                  "prefix": {
                                    "description": "Prefix defines a prefix match for a request.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "cookieRewritePolicies": {
                              "description": "The policies for rewriting Set-Cookie header attributes. Note that rewritten cookie names must be unique in this list. Order rewrite policies are specified in does not matter.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "domainRewrite": {
                                    "description": "DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.",
                                    "type": "object",
                                    "required": [
                                      "value"
                                    ],
                                    "properties": {
                                      "value": {
                                        "description": "Value is the value to rewrite the Domain attribute to. For now this is required.",
                                        "type": "string",
                                        "maxLength": 4096,
                                        "minLength": 1,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      }
                                    }
                                  },
                                  "name": {
                                    "description": "Name is the name of the cookie for which attributes will be rewritten.",
                                    "type": "string",
                                    "maxLength": 4096,
                                    "minLength": 1,
                                    "pattern": "^[^()\u003c\u003e@,;:\\\\\"\\/[\\]?={} \\t\\x7f\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]+$"
                                  },
                                  "pathRewrite": {
                                    "description": "PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.",
                                    "type": "object",
                                    "required": [
                                      "value"
                                    ],
                                    "properties": {
                                      "value": {
                                        "description": "Value is the value to rewrite the Path attribute to. For now this is required.",
                                        "type": "string",
                                        "maxLength": 4096,
                                        "minLength": 1,
                                        "pattern": "^[^;\\x7f\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]+$"
                                      }
                                    }
                                  },
                                  "sameSite": {
                                    "description": "SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.",
                                    "type": "string",
                                    "enum": [
                                      "Strict",
                                      "Lax",
                                      "None"
                                    ]
                                  },
                                  "secure": {
                                    "description": "Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.",
                                    "type": "boolean"
                                  }
                                }
                              }
                            },
                            "enableWebsockets": {
                              "description": "Enables websocket support for the route.",
                              "type": "boolean"
                            },
                            "healthCheckPolicy": {
                              "description": "The health check policy for this route.",
                              "type": "object",
                              "required": [
                                "path"
                              ],
                              "properties": {
                                "healthyThresholdCount": {
                                  "description": "The number of healthy health checks required before a host is marked healthy",
                                  "type": "integer",
                                  "format": "int64",
                                  "minimum": 0
                                },
                                "host": {
                                  "description": "The value of the host header in the HTTP health check request. If left empty (default value), the name \"contour-envoy-healthcheck\" will be used.",
                                  "type": "string"
                                },
                                "intervalSeconds": {
                                  "description": "The interval (seconds) between health checks",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "path": {
                                  "description": "HTTP endpoint used to perform health checks on upstream service",
                                  "type": "string"
                                },
                                "timeoutSeconds": {
                                  "description": "The time to wait (seconds) for a health check response",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "unhealthyThresholdCount": {
                                  "description": "The number of unhealthy health checks required before a host is marked unhealthy",
                                  "type": "integer",
                                  "format": "int64",
                                  "minimum": 0
                                }
                              }
                            },
                            "loadBalancerPolicy": {
                              "description": "The load balancing policy for this route.",
                              "type": "object",
                              "properties": {
                                "requestHashPolicies": {
                                  "description": "RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.",
                                  "type": "array",
                                  "items": {
                                    "description": "RequestHashPolicy contains configuration for an individual hash policy on a request attribute.",
                                    "type": "object",
                                    "properties": {
                                      "hashSourceIP": {
                                        "description": "HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.",
                                        "type": "boolean"
                                      },
                                      "headerHashOptions": {
                                        "description": "HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.",
                                        "type": "object",
                                        "properties": {
                                          "headerName": {
                                            "description": "HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      },
                                      "terminal": {
                                        "description": "Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.",
                                        "type": "boolean"
                                      }
                                    }
                                  }
                                },
                                "strategy": {
                                  "description": "Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.",
                                  "type": "string"
                                }
                              }
                            },
                            "pathRewritePolicy": {
                              "description": "The policy for rewriting the path of the request URL after the request has been routed to a Service.",
                              "type": "object",
                              "properties": {
                                "replacePrefix": {
                                  "description": "ReplacePrefix describes how the path prefix should be replaced.",
                                  "type": "array",
                                  "items": {
                                    "description": "ReplacePrefix describes a path prefix replacement.",
                                    "type": "object",
                                    "required": [
                                      "replacement"
                                    ],
                                    "properties": {
                                      "prefix": {
                                        "description": "Prefix specifies the URL path prefix to be replaced. \n If Prefix is specified, it must exactly match the MatchCondition prefix that is rendered by the chain of including HTTPProxies and only that path prefix will be replaced by Replacement. This allows HTTPProxies that are included through multiple roots to only replace specific path prefixes, leaving others unmodified. \n If Prefix is not specified, all routing prefixes rendered by the include chain will be replaced.",
                                        "type": "string",
                                        "minLength": 1
                                      },
                                      "replacement": {
                                        "description": "Replacement is the string that the routing path prefix will be replaced with. This must not be empty.",
                                        "type": "string",
                                        "minLength": 1
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "permitInsecure": {
                              "description": "Allow this path to respond to insecure requests over HTTP which are normally not permitted when a `virtualhost.tls` block is present.",
                              "type": "boolean"
                            },
                            "rateLimitPolicy": {
                              "description": "The policy for rate limiting on the route.",
                              "type": "object",
                              "properties": {
                                "global": {
                                  "description": "Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.",
                                  "type": "object",
                                  "properties": {
                                    "descriptors": {
                                      "description": "Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.",
                                      "type": "array",
                                      "minItems": 1,
                                      "items": {
                                        "description": "RateLimitDescriptor defines a list of key-value pair generators.",
                                        "type": "object",
                                        "properties": {
                                          "entries": {
                                            "description": "Entries is the list of key-value pair generators.",
                                            "type": "array",
                                            "minItems": 1,
                                            "items": {
                                              "description": "RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.",
                                              "type": "object",
                                              "properties": {
                                                "genericKey": {
                                                  "description": "GenericKey defines a descriptor entry with a static key and value.",
                                                  "type": "object",
                                                  "properties": {
                                                    "key": {
                                                      "description": "Key defines the key of the descriptor entry. If not set, the key is set to \"generic_key\".",
                                                      "type": "string"
                                                    },
                                                    "value": {
                                                      "description": "Value defines the value of the descriptor entry.",
                                                      "type": "string",
                                                      "minLength": 1
                                                    }
                                                  }
                                                },
                                                "remoteAddress": {
                                                  "description": "RemoteAddress defines a descriptor entry with a key of \"remote_address\" and a value equal to the client's IP address (from x-forwarded-for).",
                                                  "type": "object"
                                                },
                                                "requestHeader": {
                                                  "description": "RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.",
                                                  "type": "object",
                                                  "properties": {
                                                    "descriptorKey": {
                                                      "description": "DescriptorKey defines the key to use on the descriptor entry.",
                                                      "type": "string",
                                                      "minLength": 1
                                                    },
                                                    "headerName": {
                                                      "description": "HeaderName defines the name of the header to look for on the request.",
                                                      "type": "string",
                                                      "minLength": 1
                                                    }
                                                  }
                                                },
                                                "requestHeaderValueMatch": {
                                                  "description": "RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is \"header_match\", and the descriptor value is static.",
                                                  "type": "object",
                                                  "properties": {
                                                    "expectMatch": {
                                                      "description": "ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.",
                                                      "type": "boolean",
                                                      "default": true
                                                    },
                                                    "headers": {
                                                      "description": "Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.",
                                                      "type": "array",
                                                      "minItems": 1,
                                                      "items": {
                                                        "description": "HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.",
                                                        "type": "object",
                                                        "required": [
                                                          "name"
                                                        ],
                                                        "properties": {
                                                          "contains": {
                                                            "description": "Contains specifies a substring that must be present in the header value.",
                                                            "type": "string"
                                                          },
                                                          "exact": {
                                                            "description": "Exact specifies a string that the header value must be equal to.",
                                                            "type": "string"
                                                          },
                                                          "name": {
                                                            "description": "Name is the name of the header to match against. Name is required. Header names are case insensitive.",
                                                            "type": "string"
                                                          },
                                                          "notcontains": {
                                                            "description": "NotContains specifies a substring that must not be present in the header value.",
                                                            "type": "string"
                                                          },
                                                          "notexact": {
                                                            "description": "NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.",
                                                            "type": "string"
                                                          },
                                                          "notpresent": {
                                                            "description": "NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.",
                                                            "type": "boolean"
                                                          },
                                                          "present": {
                                                            "description": "Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.",
                                                            "type": "boolean"
                                                          }
                                                        }
                                                      }
                                                    },
                                                    "value": {
                                                      "description": "Value defines the value of the descriptor entry.",
                                                      "type": "string",
                                                      "minLength": 1
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "local": {
                                  "description": "Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.",
                                  "type": "object",
                                  "required": [
                                    "requests",
                                    "unit"
                                  ],
                                  "properties": {
                                    "burst": {
                                      "description": "Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.",
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "requests": {
                                      "description": "Requests defines how many requests per unit of time should be allowed before rate limiting occurs.",
                                      "type": "integer",
                                      "format": "int32",
                                      "minimum": 1
                                    },
                                    "responseHeadersToAdd": {
                                      "description": "ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderValue represents a header name/value pair",
                                        "type": "object",
                                        "required": [
                                          "name",
                                          "value"
                                        ],
                                        "properties": {
                                          "name": {
                                            "description": "Name represents a key of a header",
                                            "type": "string",
                                            "minLength": 1
                                          },
                                          "value": {
                                            "description": "Value represents the value of a header specified by a key",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      }
                                    },
                                    "responseStatusCode": {
                                      "description": "ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.",
                                      "type": "integer",
                                      "format": "int32",
                                      "maximum": 599,
                                      "minimum": 400
                                    },
                                    "unit": {
                                      "description": "Unit defines the period of time within which requests over the limit will be rate limited. Valid values are \"second\", \"minute\" and \"hour\".",
                                      "type": "string",
                                      "enum": [
                                        "second",
                                        "minute",
                                        "hour"
                                      ]
                                    }
                                  }
                                }
                              }
                            },
                            "requestHeadersPolicy": {
                              "description": "The policy for managing request headers during proxying.",
                              "type": "object",
                              "properties": {
                                "remove": {
                                  "description": "Remove specifies a list of HTTP header names to remove.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "set": {
                                  "description": "Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.",
                                  "type": "array",
                                  "items": {
                                    "description": "HeaderValue represents a header name/value pair",
                                    "type": "object",
                                    "required": [
                                      "name",
                                      "value"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "Name represents a key of a header",
                                        "type": "string",
                                        "minLength": 1
                                      },
                                      "value": {
                                        "description": "Value represents the value of a header specified by a key",
                                        "type": "string",
                                        "minLength": 1
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "requestRedirectPolicy": {
                              "description": "RequestRedirectPolicy defines an HTTP redirection.",
                              "type": "object",
                              "properties": {
                                "hostname": {
                                  "description": "Hostname is the precise hostname to be used in the value of the `Location` header in the response. When empty, the hostname of the request is used. No wildcards are allowed.",
                                  "type": "string",
                                  "maxLength": 253,
                                  "minLength": 1,
                                  "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                },
                                "path": {
                                  "description": "Path allows for redirection to a different path from the original on the request. The path must start with a leading slash. \n Note: Only one of Path or Prefix can be defined.",
                                  "type": "string",
                                  "pattern": "^\\/.*$"
                                },
                                "port": {
                                  "description": "Port is the port to be used in the value of the `Location` header in the response. When empty, port (if specified) of the request is used.",
                                  "type": "integer",
                                  "format": "int32",
                                  "maximum": 65535,
                                  "minimum": 1
                                },
                                "prefix": {
                                  "description": "Prefix defines the value to swap the matched prefix or path with. The prefix must start with a leading slash. \n Note: Only one of Path or Prefix can be defined.",
                                  "type": "string",
                                  "pattern": "^\\/.*$"
                                },
                                "scheme": {
                                  "description": "Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.",
                                  "type": "string",
                                  "enum": [
                                    "http",
                                    "https"
                                  ]
                                },
                                "statusCode": {
                                  "description": "StatusCode is the HTTP status code to be used in response.",
                                  "type": "integer",
                                  "default": 302,
                                  "enum": [
                                    301,
                                    302
                                  ]
                                }
                              }
                            },
                            "responseHeadersPolicy": {
                              "description": "The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.",
                              "type": "object",
                              "properties": {
                                "remove": {
                                  "description": "Remove specifies a list of HTTP header names to remove.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "set": {
                                  "description": "Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.",
                                  "type": "array",
                                  "items": {
                                    "description": "HeaderValue represents a header name/value pair",
                                    "type": "object",
                                    "required": [
                                      "name",
                                      "value"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "Name represents a key of a header",
                                        "type": "string",
                                        "minLength": 1
                                      },
                                      "value": {
                                        "description": "Value represents the value of a header specified by a key",
                                        "type": "string",
                                        "minLength": 1
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "retryPolicy": {
                              "description": "The retry policy for this route.",
                              "type": "object",
                              "properties": {
                                "count": {
                                  "description": "NumRetries is maximum allowed number of retries. If set to -1, then retries are disabled. If set to 0 or not supplied, the value is set to the Envoy default of 1.",
                                  "type": "integer",
                                  "format": "int64",
                                  "default": 1,
                                  "minimum": -1
                                },
                                "perTryTimeout": {
                                  "description": "PerTryTimeout specifies the timeout per retry attempt. Ignored if NumRetries is not supplied.",
                                  "type": "string",
                                  "pattern": "^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?µs)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$"
                                },
                                "retriableStatusCodes": {
                                  "description": "RetriableStatusCodes specifies the HTTP status codes that should be retried. \n This field is only respected when you include `retriable-status-codes` in the `RetryOn` field.",
                                  "type": "array",
                                  "items": {
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                },
                                "retryOn": {
                                  "description": "RetryOn specifies the conditions on which to retry a request. \n Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on): \n - `5xx` - `gateway-error` - `reset` - `connect-failure` - `retriable-4xx` - `refused-stream` - `retriable-status-codes` - `retriable-headers` \n Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on): \n - `cancelled` - `deadline-exceeded` - `internal` - `resource-exhausted` - `unavailable`",
                                  "type": "array",
                                  "items": {
                                    "description": "RetryOn is a string type alias with validation to ensure that the value is valid.",
                                    "type": "string",
                                    "enum": [
                                      "5xx",
                                      "gateway-error",
                                      "reset",
                                      "connect-failure",
                                      "retriable-4xx",
                                      "refused-stream",
                                      "retriable-status-codes",
                                      "retriable-headers",
                                      "cancelled",
                                      "deadline-exceeded",
                                      "internal",
                                      "resource-exhausted",
                                      "unavailable"
                                    ]
                                  }
                                }
                              }
                            },
                            "services": {
                              "description": "Services are the services to proxy traffic.",
                              "type": "array",
                              "items": {
                                "description": "Service defines an Kubernetes Service to proxy traffic.",
                                "type": "object",
                                "required": [
                                  "name",
                                  "port"
                                ],
                                "properties": {
                                  "cookieRewritePolicies": {
                                    "description": "The policies for rewriting Set-Cookie header attributes.",
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "required": [
                                        "name"
                                      ],
                                      "properties": {
                                        "domainRewrite": {
                                          "description": "DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.",
                                          "type": "object",
                                          "required": [
                                            "value"
                                          ],
                                          "properties": {
                                            "value": {
                                              "description": "Value is the value to rewrite the Domain attribute to. For now this is required.",
                                              "type": "string",
                                              "maxLength": 4096,
                                              "minLength": 1,
                                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                            }
                                          }
                                        },
                                        "name": {
                                          "description": "Name is the name of the cookie for which attributes will be rewritten.",
                                          "type": "string",
                                          "maxLength": 4096,
                                          "minLength": 1,
                                          "pattern": "^[^()\u003c\u003e@,;:\\\\\"\\/[\\]?={} \\t\\x7f\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]+$"
                                        },
                                        "pathRewrite": {
                                          "description": "PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.",
                                          "type": "object",
                                          "required": [
                                            "value"
                                          ],
                                          "properties": {
                                            "value": {
                                              "description": "Value is the value to rewrite the Path attribute to. For now this is required.",
                                              "type": "string",
                                              "maxLength": 4096,
                                              "minLength": 1,
                                              "pattern": "^[^;\\x7f\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]+$"
                                            }
                                          }
                                        },
                                        "sameSite": {
                                          "description": "SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.",
                                          "type": "string",
                                          "enum": [
                                            "Strict",
                                            "Lax",
                                            "None"
                                          ]
                                        },
                                        "secure": {
                                          "description": "Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.",
                                          "type": "boolean"
                                        }
                                      }
                                    }
                                  },
                                  "mirror": {
                                    "description": "If Mirror is true the Service will receive a read only mirror of the traffic for this route.",
                                    "type": "boolean"
                                  },
                                  "name": {
                                    "description": "Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Port (defined as Integer) to proxy traffic to since a service can have multiple defined.",
                                    "type": "integer",
                                    "maximum": 65536,
                                    "exclusiveMaximum": true,
                                    "minimum": 1
                                  },
                                  "protocol": {
                                    "description": "Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.",
                                    "type": "string",
                                    "enum": [
                                      "h2",
                                      "h2c",
                                      "tls"
                                    ]
                                  },
                                  "requestHeadersPolicy": {
                                    "description": "The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.",
                                    "type": "object",
                                    "properties": {
                                      "remove": {
                                        "description": "Remove specifies a list of HTTP header names to remove.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "set": {
                                        "description": "Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.",
                                        "type": "array",
                                        "items": {
                                          "description": "HeaderValue represents a header name/value pair",
                                          "type": "object",
                                          "required": [
                                            "name",
                                            "value"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name represents a key of a header",
                                              "type": "string",
                                              "minLength": 1
                                            },
                                            "value": {
                                              "description": "Value represents the value of a header specified by a key",
                                              "type": "string",
                                              "minLength": 1
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "responseHeadersPolicy": {
                                    "description": "The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.",
                                    "type": "object",
                                    "properties": {
                                      "remove": {
                                        "description": "Remove specifies a list of HTTP header names to remove.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "set": {
                                        "description": "Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.",
                                        "type": "array",
                                        "items": {
                                          "description": "HeaderValue represents a header name/value pair",
                                          "type": "object",
                                          "required": [
                                            "name",
                                            "value"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name represents a key of a header",
                                              "type": "string",
                                              "minLength": 1
                                            },
                                            "value": {
                                              "description": "Value represents the value of a header specified by a key",
                                              "type": "string",
                                              "minLength": 1
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "validation": {
                                    "description": "UpstreamValidation defines how to verify the backend service's certificate",
                                    "type": "object",
                                    "required": [
                                      "caSecret",
                                      "subjectName"
                                    ],
                                    "properties": {
                                      "caSecret": {
                                        "description": "Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend",
                                        "type": "string"
                                      },
                                      "subjectName": {
                                        "description": "Key which is expected to be present in the 'subjectAltName' of the presented certificate",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "Weight defines percentage of traffic to balance traffic",
                                    "type": "integer",
                                    "format": "int64",
                                    "minimum": 0
                                  }
                                }
                              }
                            },
                            "timeoutPolicy": {
                              "description": "The timeout policy for this route.",
                              "type": "object",
                              "properties": {
                                "idle": {
                                  "description": "Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.",
                                  "type": "string",
                                  "pattern": "^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?µs)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$"
                                },
                                "response": {
                                  "description": "Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.",
                                  "type": "string",
                                  "pattern": "^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?µs)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$"
                                }
                              }
                            }
                          }
                        }
                      },
                      "tcpproxy": {
                        "description": "TCPProxy holds TCP proxy information.",
                        "type": "object",
                        "properties": {
                          "healthCheckPolicy": {
                            "description": "The health check policy for this tcp proxy",
                            "type": "object",
                            "properties": {
                              "healthyThresholdCount": {
                                "description": "The number of healthy health checks required before a host is marked healthy",
                                "type": "integer",
                                "format": "int32"
                              },
                              "intervalSeconds": {
                                "description": "The interval (seconds) between health checks",
                                "type": "integer",
                                "format": "int64"
                              },
                              "timeoutSeconds": {
                                "description": "The time to wait (seconds) for a health check response",
                                "type": "integer",
                                "format": "int64"
                              },
                              "unhealthyThresholdCount": {
                                "description": "The number of unhealthy health checks required before a host is marked unhealthy",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "include": {
                            "description": "Include specifies that this tcpproxy should be delegated to another HTTPProxy.",
                            "type": "object",
                            "required": [
                              "name"
                            ],
                            "properties": {
                              "name": {
                                "description": "Name of the child HTTPProxy",
                                "type": "string"
                              },
                              "namespace": {
                                "description": "Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.",
                                "type": "string"
                              }
                            }
                          },
                          "includes": {
                            "description": "IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace. \n Exists due to a mistake when developing HTTPProxy and the field was marked plural when it should have been singular. This field should stay to not break backwards compatibility to v1 users.",
                            "type": "object",
                            "required": [
                              "name"
                            ],
                            "properties": {
                              "name": {
                                "description": "Name of the child HTTPProxy",
                                "type": "string"
                              },
                              "namespace": {
                                "description": "Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.",
                                "type": "string"
                              }
                            }
                          },
                          "loadBalancerPolicy": {
                            "description": "The load balancing policy for the backend services. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.",
                            "type": "object",
                            "properties": {
                              "requestHashPolicies": {
                                "description": "RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.",
                                "type": "array",
                                "items": {
                                  "description": "RequestHashPolicy contains configuration for an individual hash policy on a request attribute.",
                                  "type": "object",
                                  "properties": {
                                    "hashSourceIP": {
                                      "description": "HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.",
                                      "type": "boolean"
                                    },
                                    "headerHashOptions": {
                                      "description": "HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.",
                                      "type": "object",
                                      "properties": {
                                        "headerName": {
                                          "description": "HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.",
                                          "type": "string",
                                          "minLength": 1
                                        }
                                      }
                                    },
                                    "terminal": {
                                      "description": "Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.",
                                      "type": "boolean"
                                    }
                                  }
                                }
                              },
                              "strategy": {
                                "description": "Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.",
                                "type": "string"
                              }
                            }
                          },
                          "services": {
                            "description": "Services are the services to proxy traffic",
                            "type": "array",
                            "items": {
                              "description": "Service defines an Kubernetes Service to proxy traffic.",
                              "type": "object",
                              "required": [
                                "name",
                                "port"
                              ],
                              "properties": {
                                "cookieRewritePolicies": {
                                  "description": "The policies for rewriting Set-Cookie header attributes.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "required": [
                                      "name"
                                    ],
                                    "properties": {
                                      "domainRewrite": {
                                        "description": "DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.",
                                        "type": "object",
                                        "required": [
                                          "value"
                                        ],
                                        "properties": {
                                          "value": {
                                            "description": "Value is the value to rewrite the Domain attribute to. For now this is required.",
                                            "type": "string",
                                            "maxLength": 4096,
                                            "minLength": 1,
                                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                          }
                                        }
                                      },
                                      "name": {
                                        "description": "Name is the name of the cookie for which attributes will be rewritten.",
                                        "type": "string",
                                        "maxLength": 4096,
                                        "minLength": 1,
                                        "pattern": "^[^()\u003c\u003e@,;:\\\\\"\\/[\\]?={} \\t\\x7f\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]+$"
                                      },
                                      "pathRewrite": {
                                        "description": "PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.",
                                        "type": "object",
                                        "required": [
                                          "value"
                                        ],
                                        "properties": {
                                          "value": {
                                            "description": "Value is the value to rewrite the Path attribute to. For now this is required.",
                                            "type": "string",
                                            "maxLength": 4096,
                                            "minLength": 1,
                                            "pattern": "^[^;\\x7f\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]+$"
                                          }
                                        }
                                      },
                                      "sameSite": {
                                        "description": "SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.",
                                        "type": "string",
                                        "enum": [
                                          "Strict",
                                          "Lax",
                                          "None"
                                        ]
                                      },
                                      "secure": {
                                        "description": "Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.",
                                        "type": "boolean"
                                      }
                                    }
                                  }
                                },
                                "mirror": {
                                  "description": "If Mirror is true the Service will receive a read only mirror of the traffic for this route.",
                                  "type": "boolean"
                                },
                                "name": {
                                  "description": "Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Port (defined as Integer) to proxy traffic to since a service can have multiple defined.",
                                  "type": "integer",
                                  "maximum": 65536,
                                  "exclusiveMaximum": true,
                                  "minimum": 1
                                },
                                "protocol": {
                                  "description": "Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.",
                                  "type": "string",
                                  "enum": [
                                    "h2",
                                    "h2c",
                                    "tls"
                                  ]
                                },
                                "requestHeadersPolicy": {
                                  "description": "The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.",
                                  "type": "object",
                                  "properties": {
                                    "remove": {
                                      "description": "Remove specifies a list of HTTP header names to remove.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "set": {
                                      "description": "Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderValue represents a header name/value pair",
                                        "type": "object",
                                        "required": [
                                          "name",
                                          "value"
                                        ],
                                        "properties": {
                                          "name": {
                                            "description": "Name represents a key of a header",
                                            "type": "string",
                                            "minLength": 1
                                          },
                                          "value": {
                                            "description": "Value represents the value of a header specified by a key",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "responseHeadersPolicy": {
                                  "description": "The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.",
                                  "type": "object",
                                  "properties": {
                                    "remove": {
                                      "description": "Remove specifies a list of HTTP header names to remove.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "set": {
                                      "description": "Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderValue represents a header name/value pair",
                                        "type": "object",
                                        "required": [
                                          "name",
                                          "value"
                                        ],
                                        "properties": {
                                          "name": {
                                            "description": "Name represents a key of a header",
                                            "type": "string",
                                            "minLength": 1
                                          },
                                          "value": {
                                            "description": "Value represents the value of a header specified by a key",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "validation": {
                                  "description": "UpstreamValidation defines how to verify the backend service's certificate",
                                  "type": "object",
                                  "required": [
                                    "caSecret",
                                    "subjectName"
                                  ],
                                  "properties": {
                                    "caSecret": {
                                      "description": "Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend",
                                      "type": "string"
                                    },
                                    "subjectName": {
                                      "description": "Key which is expected to be present in the 'subjectAltName' of the presented certificate",
                                      "type": "string"
                                    }
                                  }
                                },
                                "weight": {
                                  "description": "Weight defines percentage of traffic to balance traffic",
                                  "type": "integer",
                                  "format": "int64",
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      },
                      "virtualhost": {
                        "description": "Virtualhost appears at most once. If it is present, the object is considered to be a \"root\" HTTPProxy.",
                        "type": "object",
                        "required": [
                          "fqdn"
                        ],
                        "properties": {
                          "authorization": {
                            "description": "This field configures an extension service to perform authorization for this virtual host. Authorization can only be configured on virtual hosts that have TLS enabled. If the TLS configuration requires client certificate validation, the client certificate is always included in the authentication check request.",
                            "type": "object",
                            "required": [
                              "extensionRef"
                            ],
                            "properties": {
                              "authPolicy": {
                                "description": "AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.",
                                "type": "object",
                                "properties": {
                                  "context": {
                                    "description": "Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  },
                                  "disabled": {
                                    "description": "When true, this field disables client request authentication for the scope of the policy.",
                                    "type": "boolean"
                                  }
                                }
                              },
                              "extensionRef": {
                                "description": "ExtensionServiceRef specifies the extension resource that will authorize client requests.",
                                "type": "object",
                                "properties": {
                                  "apiVersion": {
                                    "description": "API version of the referent. If this field is not specified, the default \"projectcontour.io/v1alpha1\" will be used",
                                    "type": "string",
                                    "minLength": 1
                                  },
                                  "name": {
                                    "description": "Name of the referent. \n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string",
                                    "minLength": 1
                                  },
                                  "namespace": {
                                    "description": "Namespace of the referent. If this field is not specifies, the namespace of the resource that targets the referent will be used. \n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                    "type": "string",
                                    "minLength": 1
                                  }
                                }
                              },
                              "failOpen": {
                                "description": "If FailOpen is true, the client request is forwarded to the upstream service even if the authorization server fails to respond. This field should not be set in most cases. It is intended for use only while migrating applications from internal authorization to Contour external authorization.",
                                "type": "boolean"
                              },
                              "responseTimeout": {
                                "description": "ResponseTimeout configures maximum time to wait for a check response from the authorization server. Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". The string \"infinity\" is also a valid input and specifies no timeout.",
                                "type": "string",
                                "pattern": "^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?µs)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$"
                              },
                              "withRequestBody": {
                                "description": "WithRequestBody specifies configuration for sending the client request's body to authorization server.",
                                "type": "object",
                                "properties": {
                                  "allowPartialMessage": {
                                    "description": "If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.",
                                    "type": "boolean"
                                  },
                                  "maxRequestBytes": {
                                    "description": "MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.",
                                    "type": "integer",
                                    "format": "int32",
                                    "default": 1024,
                                    "minimum": 1
                                  },
                                  "packAsBytes": {
                                    "description": "If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.",
                                    "type": "boolean"
                                  }
                                }
                              }
                            }
                          },
                          "corsPolicy": {
                            "description": "Specifies the cross-origin policy to apply to the VirtualHost.",
                            "type": "object",
                            "required": [
                              "allowMethods",
                              "allowOrigin"
                            ],
                            "properties": {
                              "allowCredentials": {
                                "description": "Specifies whether the resource allows credentials.",
                                "type": "boolean"
                              },
                              "allowHeaders": {
                                "description": "AllowHeaders specifies the content for the *access-control-allow-headers* header.",
                                "type": "array",
                                "items": {
                                  "description": "CORSHeaderValue specifies the value of the string headers returned by a cross-domain request.",
                                  "type": "string",
                                  "pattern": "^[a-zA-Z0-9!#$%\u0026'*+.^_`|~-]+$"
                                }
                              },
                              "allowMethods": {
                                "description": "AllowMethods specifies the content for the *access-control-allow-methods* header.",
                                "type": "array",
                                "items": {
                                  "description": "CORSHeaderValue specifies the value of the string headers returned by a cross-domain request.",
                                  "type": "string",
                                  "pattern": "^[a-zA-Z0-9!#$%\u0026'*+.^_`|~-]+$"
                                }
                              },
                              "allowOrigin": {
                                "description": "AllowOrigin specifies the origins that will be allowed to do CORS requests. \"*\" means allow any origin.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "exposeHeaders": {
                                "description": "ExposeHeaders Specifies the content for the *access-control-expose-headers* header.",
                                "type": "array",
                                "items": {
                                  "description": "CORSHeaderValue specifies the value of the string headers returned by a cross-domain request.",
                                  "type": "string",
                                  "pattern": "^[a-zA-Z0-9!#$%\u0026'*+.^_`|~-]+$"
                                }
                              },
                              "maxAge": {
                                "description": "MaxAge indicates for how long the results of a preflight request can be cached. MaxAge durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". Only positive values are allowed while 0 disables the cache requiring a preflight OPTIONS check for all cross-origin requests.",
                                "type": "string"
                              }
                            }
                          },
                          "fqdn": {
                            "description": "The fully qualified domain name of the root of the ingress tree all leaves of the DAG rooted at this object relate to the fqdn.",
                            "type": "string",
                            "pattern": "^(\\*\\.)?[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "rateLimitPolicy": {
                            "description": "The policy for rate limiting on the virtual host.",
                            "type": "object",
                            "properties": {
                              "global": {
                                "description": "Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.",
                                "type": "object",
                                "properties": {
                                  "descriptors": {
                                    "description": "Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.",
                                    "type": "array",
                                    "minItems": 1,
                                    "items": {
                                      "description": "RateLimitDescriptor defines a list of key-value pair generators.",
                                      "type": "object",
                                      "properties": {
                                        "entries": {
                                          "description": "Entries is the list of key-value pair generators.",
                                          "type": "array",
                                          "minItems": 1,
                                          "items": {
                                            "description": "RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.",
                                            "type": "object",
                                            "properties": {
                                              "genericKey": {
                                                "description": "GenericKey defines a descriptor entry with a static key and value.",
                                                "type": "object",
                                                "properties": {
                                                  "key": {
                                                    "description": "Key defines the key of the descriptor entry. If not set, the key is set to \"generic_key\".",
                                                    "type": "string"
                                                  },
                                                  "value": {
                                                    "description": "Value defines the value of the descriptor entry.",
                                                    "type": "string",
                                                    "minLength": 1
                                                  }
                                                }
                                              },
                                              "remoteAddress": {
                                                "description": "RemoteAddress defines a descriptor entry with a key of \"remote_address\" and a value equal to the client's IP address (from x-forwarded-for).",
                                                "type": "object"
                                              },
                                              "requestHeader": {
                                                "description": "RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.",
                                                "type": "object",
                                                "properties": {
                                                  "descriptorKey": {
                                                    "description": "DescriptorKey defines the key to use on the descriptor entry.",
                                                    "type": "string",
                                                    "minLength": 1
                                                  },
                                                  "headerName": {
                                                    "description": "HeaderName defines the name of the header to look for on the request.",
                                                    "type": "string",
                                                    "minLength": 1
                                                  }
                                                }
                                              },
                                              "requestHeaderValueMatch": {
                                                "description": "RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is \"header_match\", and the descriptor value is static.",
                                                "type": "object",
                                                "properties": {
                                                  "expectMatch": {
                                                    "description": "ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.",
                                                    "type": "boolean",
                                                    "default": true
                                                  },
                                                  "headers": {
                                                    "description": "Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.",
                                                    "type": "array",
                                                    "minItems": 1,
                                                    "items": {
                                                      "description": "HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.",
                                                      "type": "object",
                                                      "required": [
                                                        "name"
                                                      ],
                                                      "properties": {
                                                        "contains": {
                                                          "description": "Contains specifies a substring that must be present in the header value.",
                                                          "type": "string"
                                                        },
                                                        "exact": {
                                                          "description": "Exact specifies a string that the header value must be equal to.",
                                                          "type": "string"
                                                        },
                                                        "name": {
                                                          "description": "Name is the name of the header to match against. Name is required. Header names are case insensitive.",
                                                          "type": "string"
                                                        },
                                                        "notcontains": {
                                                          "description": "NotContains specifies a substring that must not be present in the header value.",
                                                          "type": "string"
                                                        },
                                                        "notexact": {
                                                          "description": "NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.",
                                                          "type": "string"
                                                        },
                                                        "notpresent": {
                                                          "description": "NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.",
                                                          "type": "boolean"
                                                        },
                                                        "present": {
                                                          "description": "Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.",
                                                          "type": "boolean"
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "value": {
                                                    "description": "Value defines the value of the descriptor entry.",
                                                    "type": "string",
                                                    "minLength": 1
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "local": {
                                "description": "Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.",
                                "type": "object",
                                "required": [
                                  "requests",
                                  "unit"
                                ],
                                "properties": {
                                  "burst": {
                                    "description": "Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.",
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "requests": {
                                    "description": "Requests defines how many requests per unit of time should be allowed before rate limiting occurs.",
                                    "type": "integer",
                                    "format": "int32",
                                    "minimum": 1
                                  },
                                  "responseHeadersToAdd": {
                                    "description": "ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.",
                                    "type": "array",
                                    "items": {
                                      "description": "HeaderValue represents a header name/value pair",
                                      "type": "object",
                                      "required": [
                                        "name",
                                        "value"
                                      ],
                                      "properties": {
                                        "name": {
                                          "description": "Name represents a key of a header",
                                          "type": "string",
                                          "minLength": 1
                                        },
                                        "value": {
                                          "description": "Value represents the value of a header specified by a key",
                                          "type": "string",
                                          "minLength": 1
                                        }
                                      }
                                    }
                                  },
                                  "responseStatusCode": {
                                    "description": "ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.",
                                    "type": "integer",
                                    "format": "int32",
                                    "maximum": 599,
                                    "minimum": 400
                                  },
                                  "unit": {
                                    "description": "Unit defines the period of time within which requests over the limit will be rate limited. Valid values are \"second\", \"minute\" and \"hour\".",
                                    "type": "string",
                                    "enum": [
                                      "second",
                                      "minute",
                                      "hour"
                                    ]
                                  }
                                }
                              }
                            }
                          },
                          "tls": {
                            "description": "If present the fields describes TLS properties of the virtual host. The SNI names that will be matched on are described in fqdn, the tls.secretName secret must contain a certificate that itself contains a name that matches the FQDN.",
                            "type": "object",
                            "properties": {
                              "clientValidation": {
                                "description": "ClientValidation defines how to verify the client certificate when an external client establishes a TLS connection to Envoy. \n This setting: \n 1. Enables TLS client certificate validation. 2. Specifies how the client certificate will be validated (i.e.    validation required or skipped). \n Note: Setting client certificate validation to be skipped should be only used in conjunction with an external authorization server that performs client validation as Contour will ensure client certificates are passed along.",
                                "type": "object",
                                "properties": {
                                  "caSecret": {
                                    "description": "Name of a Kubernetes secret that contains a CA certificate bundle. The client certificate must validate against the certificates in the bundle. If specified and SkipClientCertValidation is true, client certificates will be required on requests.",
                                    "type": "string",
                                    "minLength": 1
                                  },
                                  "skipClientCertValidation": {
                                    "description": "SkipClientCertValidation disables downstream client certificate validation. Defaults to false. This field is intended to be used in conjunction with external authorization in order to enable the external authorization server to validate client certificates. When this field is set to true, client certificates are requested but not verified by Envoy. If CACertificate is specified, client certificates are required on requests, but not verified. If external authorization is in use, they are presented to the external authorization server.",
                                    "type": "boolean"
                                  }
                                }
                              },
                              "enableFallbackCertificate": {
                                "description": "EnableFallbackCertificate defines if the vhost should allow a default certificate to be applied which handles all requests which don't match the SNI defined in this vhost.",
                                "type": "boolean"
                              },
                              "minimumProtocolVersion": {
                                "description": "MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`. Any other value defaults to TLS 1.2.",
                                "type": "string"
                              },
                              "passthrough": {
                                "description": "Passthrough defines whether the encrypted TLS handshake will be passed through to the backing cluster. Either Passthrough or SecretName must be specified, but not both.",
                                "type": "boolean"
                              },
                              "secretName": {
                                "description": "SecretName is the name of a TLS secret in the current namespace. Either SecretName or Passthrough must be specified, but not both. If specified, the named secret must contain a matching certificate for the virtual host's FQDN.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "Status is a container for computed information about the HTTPProxy.",
                    "type": "object",
                    "default": {
                      "currentStatus": "NotReconciled",
                      "description": "Waiting for controller"
                    },
                    "properties": {
                      "conditions": {
                        "description": "Conditions contains information about the current status of the HTTPProxy, in an upstream-friendly container. \n Contour will update a single condition, `Valid`, that is in normal-true polarity. That is, when `currentStatus` is `valid`, the `Valid` condition will be `status: true`, and vice versa. \n Contour will leave untouched any other Conditions set in this block, in case some other controller wants to add a Condition. \n If you are another controller owner and wish to add a condition, you *should* namespace your condition with a label, like `controller.domain.com/ConditionName`.",
                        "type": "array",
                        "items": {
                          "description": "DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \n Remember that Conditions have a type, a status, and a reason. \n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.",
                          "type": "object",
                          "required": [
                            "lastTransitionTime",
                            "message",
                            "reason",
                            "status",
                            "type"
                          ],
                          "properties": {
                            "errors": {
                              "description": "Errors contains a slice of relevant error subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            },
                            "lastTransitionTime": {
                              "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                              "type": "string",
                              "format": "date-time"
                            },
                            "message": {
                              "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                              "type": "string",
                              "maxLength": 32768
                            },
                            "observedGeneration": {
                              "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                              "type": "integer",
                              "format": "int64",
                              "minimum": 0
                            },
                            "reason": {
                              "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                              "type": "string",
                              "maxLength": 1024,
                              "minLength": 1,
                              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                            },
                            "status": {
                              "description": "status of the condition, one of True, False, Unknown.",
                              "type": "string",
                              "enum": [
                                "True",
                                "False",
                                "Unknown"
                              ]
                            },
                            "type": {
                              "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                              "type": "string",
                              "maxLength": 316,
                              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                            },
                            "warnings": {
                              "description": "Warnings contains a slice of relevant warning subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "type"
                        ],
                        "x-kubernetes-list-type": "map"
                      },
                      "currentStatus": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "loadBalancer": {
                        "description": "LoadBalancer contains the current status of the load balancer.",
                        "type": "object",
                        "properties": {
                          "ingress": {
                            "description": "Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.",
                            "type": "array",
                            "items": {
                              "description": "LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.",
                              "type": "object",
                              "properties": {
                                "hostname": {
                                  "description": "Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)",
                                  "type": "string"
                                },
                                "ip": {
                                  "description": "IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)",
                                  "type": "string"
                                },
                                "ports": {
                                  "description": "Ports is a list of records of service ports If used, every port defined in the service should have an entry in it",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "required": [
                                      "port",
                                      "protocol"
                                    ],
                                    "properties": {
                                      "error": {
                                        "description": "Error is to record the problem with the service port The format of the error shall comply with the following rules: - built-in error values shall be specified in this file and those shall use   CamelCase names - cloud provider specific error values must have names that comply with the   format foo.example.com/CamelCase. --- The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                        "type": "string",
                                        "maxLength": 316,
                                        "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                      },
                                      "port": {
                                        "description": "Port is the port number of the service port of which status is recorded here",
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "protocol": {
                                        "description": "Protocol is the protocol of the service port of which status is recorded here The supported values are: \"TCP\", \"UDP\", \"SCTP\"",
                                        "type": "string",
                                        "default": "TCP"
                                      }
                                    }
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "FQDN",
                "type": "string",
                "description": "Fully qualified domain name",
                "jsonPath": ".spec.virtualhost.fqdn"
              },
              {
                "name": "TLS Secret",
                "type": "string",
                "description": "Secret with TLS credentials",
                "jsonPath": ".spec.virtualhost.tls.secretName"
              },
              {
                "name": "Status",
                "type": "string",
                "description": "The current status of the HTTPProxy",
                "jsonPath": ".status.currentStatus"
              },
              {
                "name": "Status Description",
                "type": "string",
                "description": "Description of the current status",
                "jsonPath": ".status.description"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "httpproxies",
          "singular": "httpproxy",
          "shortNames": [
            "proxy",
            "proxies"
          ],
          "kind": "HTTPProxy",
          "listKind": "HTTPProxyList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "installers.cluster.kurl.sh",
        "uid": "d41af623-cff7-4001-8101-e0022aff2f70",
        "resourceVersion": "500",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:50:20Z",
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.7.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.7.0\"},\"creationTimestamp\":null,\"name\":\"installers.cluster.kurl.sh\"},\"spec\":{\"group\":\"cluster.kurl.sh\",\"names\":{\"kind\":\"Installer\",\"listKind\":\"InstallerList\",\"plural\":\"installers\",\"singular\":\"installer\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"Installer is the Schema for the installers API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"properties\":{\"antrea\":{\"properties\":{\"isEncryptionDisabled\":{\"type\":\"boolean\"},\"podCIDR\":{\"type\":\"string\"},\"podCidrRange\":{\"type\":\"string\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"calico\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"certManager\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"collectd\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"containerd\":{\"properties\":{\"preserveConfig\":{\"type\":\"boolean\"},\"s3Override\":{\"type\":\"string\"},\"tomlConfig\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"contour\":{\"properties\":{\"httpPort\":{\"type\":\"integer\"},\"httpsPort\":{\"type\":\"integer\"},\"s3Override\":{\"type\":\"string\"},\"tlsMinimumProtocolVersion\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"docker\":{\"properties\":{\"bypassStorageDriverWarning\":{\"type\":\"boolean\"},\"daemonConfig\":{\"type\":\"string\"},\"dockerRegistryIP\":{\"type\":\"string\"},\"hardFailOnLoopback\":{\"type\":\"boolean\"},\"noCEOnEE\":{\"type\":\"boolean\"},\"preserveConfig\":{\"type\":\"boolean\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"ekco\":{\"properties\":{\"autoUpgradeSchedule\":{\"type\":\"string\"},\"enableInternalLoadBalancer\":{\"type\":\"boolean\"},\"minReadyMasterNodeCount\":{\"type\":\"integer\"},\"minReadyWorkerNodeCount\":{\"type\":\"integer\"},\"nodeUnreachableToleration\":{\"type\":\"string\"},\"podImageOverrides\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"rookShouldUseAllNodes\":{\"type\":\"boolean\"},\"s3Override\":{\"type\":\"string\"},\"shouldDisableClearNodes\":{\"type\":\"boolean\"},\"shouldDisableRebootServices\":{\"type\":\"boolean\"},\"shouldEnablePurgeNodes\":{\"type\":\"boolean\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"firewalldConfig\":{\"properties\":{\"bypassFirewalldWarning\":{\"type\":\"boolean\"},\"disableFirewalld\":{\"type\":\"boolean\"},\"firewalld\":{\"type\":\"string\"},\"firewalldCmds\":{\"items\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"type\":\"array\"},\"hardFailOnFirewalld\":{\"type\":\"boolean\"},\"preserveConfig\":{\"type\":\"boolean\"}},\"type\":\"object\"},\"fluentd\":{\"properties\":{\"fluentdConfPath\":{\"type\":\"string\"},\"fullEFKStack\":{\"type\":\"boolean\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"goldpinger\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"helm\":{\"properties\":{\"additionalImages\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"helmfileSpec\":{\"type\":\"string\"}},\"required\":[\"helmfileSpec\"],\"type\":\"object\"},\"iptablesConfig\":{\"properties\":{\"iptablesCmds\":{\"items\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"type\":\"array\"},\"preserveConfig\":{\"type\":\"boolean\"}},\"type\":\"object\"},\"k3s\":{\"properties\":{\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"kotsadm\":{\"properties\":{\"applicationNamespace\":{\"type\":\"string\"},\"applicationSlug\":{\"type\":\"string\"},\"applicationVersionLabel\":{\"type\":\"string\"},\"disableS3\":{\"type\":\"boolean\"},\"hostname\":{\"type\":\"string\"},\"s3Override\":{\"type\":\"string\"},\"uiBindPort\":{\"type\":\"integer\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"kubernetes\":{\"properties\":{\"HACluster\":{\"type\":\"boolean\"},\"bootstrapToken\":{\"type\":\"string\"},\"bootstrapTokenTTL\":{\"type\":\"string\"},\"certKey\":{\"type\":\"string\"},\"cisCompliance\":{\"type\":\"boolean\"},\"containerLogMaxFiles\":{\"type\":\"integer\"},\"containerLogMaxSize\":{\"type\":\"string\"},\"controlPlane\":{\"type\":\"boolean\"},\"evictionThresholdResources\":{\"type\":\"string\"},\"kubeReserved\":{\"type\":\"boolean\"},\"kubeadmToken\":{\"type\":\"string\"},\"kubeadmTokenCAHash\":{\"type\":\"string\"},\"loadBalancerAddress\":{\"type\":\"string\"},\"masterAddress\":{\"type\":\"string\"},\"s3Override\":{\"type\":\"string\"},\"serviceCIDR\":{\"type\":\"string\"},\"serviceCidrRange\":{\"type\":\"string\"},\"systemReservedResources\":{\"type\":\"string\"},\"useStandardNodePortRange\":{\"type\":\"boolean\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"kurl\":{\"properties\":{\"additionalNoProxyAddresses\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"airgap\":{\"type\":\"boolean\"},\"excludeBuiltinHostPreflights\":{\"type\":\"boolean\"},\"hostPreflightEnforceWarnings\":{\"type\":\"boolean\"},\"hostPreflightIgnore\":{\"type\":\"boolean\"},\"hostPreflights\":{\"description\":\"HostPreflight is the Schema for the hostpreflights API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"HostPreflightSpec defines the desired state of HostPreflight\",\"properties\":{\"analyzers\":{\"items\":{\"properties\":{\"blockDevices\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"includeUnmountedPartitions\":{\"type\":\"boolean\"},\"minimumAcceptableSize\":{\"format\":\"int64\",\"type\":\"integer\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"includeUnmountedPartitions\",\"minimumAcceptableSize\",\"outcomes\"],\"type\":\"object\"},\"certificate\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"cpu\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"diskUsage\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"filesystemPerformance\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"hostOS\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"hostServices\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"http\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"httpLoadBalancer\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"ipv4Interfaces\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"kernelModules\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"memory\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"systemPackages\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"tcpConnect\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"tcpLoadBalancer\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"tcpPortStatus\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"},\"time\":{\"properties\":{\"checkName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"outcomes\":{\"items\":{\"properties\":{\"fail\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"pass\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"},\"warn\":{\"properties\":{\"message\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"},\"when\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"outcomes\"],\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"},\"collectors\":{\"items\":{\"properties\":{\"blockDevices\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"certificate\":{\"properties\":{\"certificatePath\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"keyPath\":{\"type\":\"string\"}},\"required\":[\"certificatePath\",\"keyPath\"],\"type\":\"object\"},\"cpu\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"diskUsage\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"type\":\"object\"},\"filesystemPerformance\":{\"description\":\"FilesystemPerformance benchmarks sequential write latency on a single file. The optional background IOPS feature attempts to mimic real-world conditions by running read and write workloads prior to and during benchmark execution.\",\"properties\":{\"backgroundIOPSWarmupSeconds\":{\"description\":\"How long to run the background IOPS read and write workloads prior to starting the benchmarks.\",\"type\":\"integer\"},\"backgroundReadIOPS\":{\"description\":\"The target read IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background read jobs.\",\"type\":\"integer\"},\"backgroundReadIOPSJobs\":{\"description\":\"Number of threads to use for background read IOPS. This should be set high enough to reach the target specified in BackgrounReadIOPS.\",\"type\":\"integer\"},\"backgroundWriteIOPS\":{\"description\":\"The target write IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background write jobs.\",\"type\":\"integer\"},\"backgroundWriteIOPSJobs\":{\"description\":\"Number of threads to use for background write IOPS. This should be set high enough to reach the target specified in BackgroundWriteIOPS. Example: If BackgroundWriteIOPS is 100 and write latency is 10ms then a single job would barely be able to reach 100 IOPS so this should be at least 2.\",\"type\":\"integer\"},\"collectorName\":{\"type\":\"string\"},\"datasync\":{\"description\":\"Whether to call datasync on the file after each write. Skipped if Sync is also true. Does not apply to background IOPS task.\",\"type\":\"boolean\"},\"directory\":{\"description\":\"The directory where the benchmark will create files.\",\"type\":\"string\"},\"enableBackgroundIOPS\":{\"description\":\"Enable the background IOPS feature.\",\"type\":\"boolean\"},\"exclude\":{\"type\":\"string\"},\"fileSize\":{\"description\":\"The size of the file used in the benchmark. The number of IO operations for the benchmark will be FileSize / OperationSizeBytes. Accepts valid Kubernetes resource units such as Mi.\",\"type\":\"string\"},\"operationSize\":{\"description\":\"The size of each write operation performed while benchmarking. This does not apply to the background IOPS feature if enabled, since those must be fixed at 4096.\",\"format\":\"int64\",\"type\":\"integer\"},\"sync\":{\"description\":\"Whether to call sync on the file after each write. Does not apply to background IOPS task.\",\"type\":\"boolean\"},\"timeout\":{\"description\":\"Total timeout, including background IOPS setup and warmup if enabled.\",\"type\":\"string\"}},\"required\":[\"backgroundIOPSWarmupSeconds\",\"backgroundReadIOPS\",\"backgroundReadIOPSJobs\",\"backgroundWriteIOPS\",\"backgroundWriteIOPSJobs\",\"enableBackgroundIOPS\"],\"type\":\"object\"},\"hostOS\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"hostServices\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"http\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"get\":{\"properties\":{\"headers\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"insecureSkipVerify\":{\"type\":\"boolean\"},\"url\":{\"type\":\"string\"}},\"required\":[\"url\"],\"type\":\"object\"},\"post\":{\"properties\":{\"body\":{\"type\":\"string\"},\"headers\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"insecureSkipVerify\":{\"type\":\"boolean\"},\"url\":{\"type\":\"string\"}},\"required\":[\"url\"],\"type\":\"object\"},\"put\":{\"properties\":{\"body\":{\"type\":\"string\"},\"headers\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"insecureSkipVerify\":{\"type\":\"boolean\"},\"url\":{\"type\":\"string\"}},\"required\":[\"url\"],\"type\":\"object\"}},\"type\":\"object\"},\"httpLoadBalancer\":{\"properties\":{\"address\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"path\":{\"type\":\"string\"},\"port\":{\"type\":\"integer\"},\"timeout\":{\"type\":\"string\"}},\"required\":[\"address\",\"path\",\"port\"],\"type\":\"object\"},\"ipv4Interfaces\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"kernelModules\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"kubernetes\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"memory\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"systemPackages\":{\"properties\":{\"amzn\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"amzn2\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"centos\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"centos7\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"centos8\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"ol\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"ol7\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"ol8\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"rhel\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"rhel7\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"rhel8\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"ubuntu\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"ubuntu16\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"ubuntu18\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"ubuntu20\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"tcpConnect\":{\"properties\":{\"address\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"timeout\":{\"type\":\"string\"}},\"required\":[\"address\"],\"type\":\"object\"},\"tcpLoadBalancer\":{\"properties\":{\"address\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"port\":{\"type\":\"integer\"},\"timeout\":{\"type\":\"string\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"tcpPortStatus\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"interface\":{\"type\":\"string\"},\"port\":{\"type\":\"integer\"}},\"required\":[\"port\"],\"type\":\"object\"},\"time\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"},\"remoteCollectors\":{\"items\":{\"properties\":{\"blockDevices\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"certificate\":{\"properties\":{\"certificatePath\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"keyPath\":{\"type\":\"string\"}},\"required\":[\"certificatePath\",\"keyPath\"],\"type\":\"object\"},\"cpu\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"diskUsage\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"path\":{\"type\":\"string\"}},\"required\":[\"path\"],\"type\":\"object\"},\"filesystemPerformance\":{\"description\":\"RemoteFilesystemPerformance benchmarks sequential write latency on a single file. The optional background IOPS feature attempts to mimic real-world conditions by running read and write workloads prior to and during benchmark execution.\",\"properties\":{\"backgroundIOPSWarmupSeconds\":{\"description\":\"How long to run the background IOPS read and write workloads prior to starting the benchmarks.\",\"type\":\"integer\"},\"backgroundReadIOPS\":{\"description\":\"The target read IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background read jobs.\",\"type\":\"integer\"},\"backgroundReadIOPSJobs\":{\"description\":\"Number of threads to use for background read IOPS. This should be set high enough to reach the target specified in BackgrounReadIOPS.\",\"type\":\"integer\"},\"backgroundWriteIOPS\":{\"description\":\"The target write IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background write jobs.\",\"type\":\"integer\"},\"backgroundWriteIOPSJobs\":{\"description\":\"Number of threads to use for background write IOPS. This should be set high enough to reach the target specified in BackgroundWriteIOPS. Example: If BackgroundWriteIOPS is 100 and write latency is 10ms then a single job would barely be able to reach 100 IOPS so this should be at least 2.\",\"type\":\"integer\"},\"collectorName\":{\"type\":\"string\"},\"datasync\":{\"description\":\"Whether to call datasync on the file after each write. Skipped if Sync is also true. Does not apply to background IOPS task.\",\"type\":\"boolean\"},\"directory\":{\"description\":\"The directory where the benchmark will create files.\",\"type\":\"string\"},\"enableBackgroundIOPS\":{\"description\":\"Enable the background IOPS feature.\",\"type\":\"boolean\"},\"exclude\":{\"type\":\"string\"},\"fileSize\":{\"description\":\"The size of the file used in the benchmark. The number of IO operations for the benchmark will be FileSize / OperationSizeBytes. Accepts valid Kubernetes resource units such as Mi.\",\"type\":\"string\"},\"operationSize\":{\"description\":\"The size of each write operation performed while benchmarking. This does not apply to the background IOPS feature if enabled, since those must be fixed at 4096.\",\"format\":\"int64\",\"type\":\"integer\"},\"sync\":{\"description\":\"Whether to call sync on the file after each write. Does not apply to background IOPS task.\",\"type\":\"boolean\"},\"timeout\":{\"description\":\"Total timeout, including background IOPS setup and warmup if enabled.\",\"type\":\"string\"}},\"required\":[\"backgroundIOPSWarmupSeconds\",\"backgroundReadIOPS\",\"backgroundReadIOPSJobs\",\"backgroundWriteIOPS\",\"backgroundWriteIOPSJobs\",\"enableBackgroundIOPS\"],\"type\":\"object\"},\"hostServices\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"http\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"get\":{\"properties\":{\"headers\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"insecureSkipVerify\":{\"type\":\"boolean\"},\"url\":{\"type\":\"string\"}},\"required\":[\"url\"],\"type\":\"object\"},\"post\":{\"properties\":{\"body\":{\"type\":\"string\"},\"headers\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"insecureSkipVerify\":{\"type\":\"boolean\"},\"url\":{\"type\":\"string\"}},\"required\":[\"url\"],\"type\":\"object\"},\"put\":{\"properties\":{\"body\":{\"type\":\"string\"},\"headers\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"insecureSkipVerify\":{\"type\":\"boolean\"},\"url\":{\"type\":\"string\"}},\"required\":[\"url\"],\"type\":\"object\"}},\"type\":\"object\"},\"httpLoadBalancer\":{\"properties\":{\"address\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"path\":{\"type\":\"string\"},\"port\":{\"type\":\"integer\"},\"timeout\":{\"type\":\"string\"}},\"required\":[\"address\",\"path\",\"port\"],\"type\":\"object\"},\"ipv4Interfaces\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"kernelModules\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"memory\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"systemPackages\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"},\"tcpConnect\":{\"properties\":{\"address\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"timeout\":{\"type\":\"string\"}},\"required\":[\"address\"],\"type\":\"object\"},\"tcpLoadBalancer\":{\"properties\":{\"address\":{\"type\":\"string\"},\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"port\":{\"type\":\"integer\"},\"timeout\":{\"type\":\"string\"}},\"required\":[\"address\",\"port\"],\"type\":\"object\"},\"tcpPortStatus\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"},\"interface\":{\"type\":\"string\"},\"port\":{\"type\":\"integer\"}},\"required\":[\"port\"],\"type\":\"object\"},\"time\":{\"properties\":{\"collectorName\":{\"type\":\"string\"},\"exclude\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"status\":{\"description\":\"HostPreflightStatus defines the observed state of HostPreflight\",\"type\":\"object\"}},\"type\":\"object\"},\"hostnameCheck\":{\"type\":\"string\"},\"ignoreRemoteLoadImagesPrompt\":{\"type\":\"boolean\"},\"ignoreRemoteUpgradePrompt\":{\"type\":\"boolean\"},\"installerVersion\":{\"type\":\"string\"},\"ipv6\":{\"type\":\"boolean\"},\"licenseURL\":{\"type\":\"string\"},\"nameserver\":{\"type\":\"string\"},\"noProxy\":{\"type\":\"boolean\"},\"privateAddress\":{\"type\":\"string\"},\"proxyAddress\":{\"type\":\"string\"},\"publicAddress\":{\"type\":\"string\"},\"skipSystemPackageInstall\":{\"type\":\"boolean\"}},\"type\":\"object\"},\"longhorn\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"storageOverProvisioningPercentage\":{\"type\":\"integer\"},\"uiBindPort\":{\"type\":\"integer\"},\"uiReplicaCount\":{\"type\":\"integer\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"metricsServer\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"minio\":{\"properties\":{\"claimSize\":{\"type\":\"string\"},\"hostPath\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"openebs\":{\"properties\":{\"cstorStorageClassName\":{\"type\":\"string\"},\"isCstorEnabled\":{\"type\":\"boolean\"},\"isLocalPVEnabled\":{\"type\":\"boolean\"},\"localPVStorageClassName\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"prometheus\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"serviceType\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"registry\":{\"properties\":{\"publishPort\":{\"type\":\"integer\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"rke2\":{\"properties\":{\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"rook\":{\"properties\":{\"blockDeviceFilter\":{\"type\":\"string\"},\"bypassUpgradeWarning\":{\"type\":\"boolean\"},\"cephReplicaCount\":{\"type\":\"integer\"},\"hostpathRequiresPrivileged\":{\"type\":\"boolean\"},\"isBlockStorageEnabled\":{\"type\":\"boolean\"},\"isSharedFilesystemDisabled\":{\"type\":\"boolean\"},\"s3Override\":{\"type\":\"string\"},\"storageClassName\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"selinuxConfig\":{\"properties\":{\"chconCmds\":{\"items\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"type\":\"array\"},\"disableSelinux\":{\"type\":\"boolean\"},\"preserveConfig\":{\"type\":\"boolean\"},\"selinux\":{\"type\":\"string\"},\"semanageCmds\":{\"items\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"type\":\"array\"},\"type\":{\"type\":\"string\"}},\"type\":\"object\"},\"sonobuoy\":{\"properties\":{\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"ufwConfig\":{\"properties\":{\"bypassUFWWarning\":{\"type\":\"boolean\"},\"disableUFW\":{\"type\":\"boolean\"},\"hardFailOnUFW\":{\"type\":\"boolean\"}},\"type\":\"object\"},\"velero\":{\"properties\":{\"disableCLI\":{\"type\":\"boolean\"},\"disableRestic\":{\"type\":\"boolean\"},\"localBucket\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"},\"resticRequiresPrivileged\":{\"type\":\"boolean\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"},\"weave\":{\"properties\":{\"isEncryptionDisabled\":{\"type\":\"boolean\"},\"noMasqLocal\":{\"description\":\"NoMasqLocal if not present defaults to true, which will expose the original client IP address in the X-Forwarded-For header.\",\"type\":\"boolean\"},\"podCIDR\":{\"type\":\"string\"},\"podCidrRange\":{\"type\":\"string\"},\"s3Override\":{\"type\":\"string\"},\"version\":{\"type\":\"string\"}},\"required\":[\"version\"],\"type\":\"object\"}},\"type\":\"object\"},\"status\":{\"description\":\"InstallerStatus defines the observed state of Installer\",\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]},\"status\":{\"acceptedNames\":{\"kind\":\"\",\"plural\":\"\"},\"conditions\":[],\"storedVersions\":[]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:50:20Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:50:20Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "cluster.kurl.sh",
        "names": {
          "plural": "installers",
          "singular": "installer",
          "kind": "Installer",
          "listKind": "InstallerList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "Installer is the Schema for the installers API",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "type": "object",
                    "properties": {
                      "antrea": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "isEncryptionDisabled": {
                            "type": "boolean"
                          },
                          "podCIDR": {
                            "type": "string"
                          },
                          "podCidrRange": {
                            "type": "string"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "calico": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "certManager": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "collectd": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "containerd": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "preserveConfig": {
                            "type": "boolean"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "tomlConfig": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "contour": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "httpPort": {
                            "type": "integer"
                          },
                          "httpsPort": {
                            "type": "integer"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "tlsMinimumProtocolVersion": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "docker": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "bypassStorageDriverWarning": {
                            "type": "boolean"
                          },
                          "daemonConfig": {
                            "type": "string"
                          },
                          "dockerRegistryIP": {
                            "type": "string"
                          },
                          "hardFailOnLoopback": {
                            "type": "boolean"
                          },
                          "noCEOnEE": {
                            "type": "boolean"
                          },
                          "preserveConfig": {
                            "type": "boolean"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "ekco": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "autoUpgradeSchedule": {
                            "type": "string"
                          },
                          "enableInternalLoadBalancer": {
                            "type": "boolean"
                          },
                          "minReadyMasterNodeCount": {
                            "type": "integer"
                          },
                          "minReadyWorkerNodeCount": {
                            "type": "integer"
                          },
                          "nodeUnreachableToleration": {
                            "type": "string"
                          },
                          "podImageOverrides": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "rookShouldUseAllNodes": {
                            "type": "boolean"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "shouldDisableClearNodes": {
                            "type": "boolean"
                          },
                          "shouldDisableRebootServices": {
                            "type": "boolean"
                          },
                          "shouldEnablePurgeNodes": {
                            "type": "boolean"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "firewalldConfig": {
                        "type": "object",
                        "properties": {
                          "bypassFirewalldWarning": {
                            "type": "boolean"
                          },
                          "disableFirewalld": {
                            "type": "boolean"
                          },
                          "firewalld": {
                            "type": "string"
                          },
                          "firewalldCmds": {
                            "type": "array",
                            "items": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "hardFailOnFirewalld": {
                            "type": "boolean"
                          },
                          "preserveConfig": {
                            "type": "boolean"
                          }
                        }
                      },
                      "fluentd": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "fluentdConfPath": {
                            "type": "string"
                          },
                          "fullEFKStack": {
                            "type": "boolean"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "goldpinger": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "helm": {
                        "type": "object",
                        "required": [
                          "helmfileSpec"
                        ],
                        "properties": {
                          "additionalImages": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "helmfileSpec": {
                            "type": "string"
                          }
                        }
                      },
                      "iptablesConfig": {
                        "type": "object",
                        "properties": {
                          "iptablesCmds": {
                            "type": "array",
                            "items": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "preserveConfig": {
                            "type": "boolean"
                          }
                        }
                      },
                      "k3s": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "kotsadm": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "applicationNamespace": {
                            "type": "string"
                          },
                          "applicationSlug": {
                            "type": "string"
                          },
                          "applicationVersionLabel": {
                            "type": "string"
                          },
                          "disableS3": {
                            "type": "boolean"
                          },
                          "hostname": {
                            "type": "string"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "uiBindPort": {
                            "type": "integer"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "kubernetes": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "HACluster": {
                            "type": "boolean"
                          },
                          "bootstrapToken": {
                            "type": "string"
                          },
                          "bootstrapTokenTTL": {
                            "type": "string"
                          },
                          "certKey": {
                            "type": "string"
                          },
                          "cisCompliance": {
                            "type": "boolean"
                          },
                          "containerLogMaxFiles": {
                            "type": "integer"
                          },
                          "containerLogMaxSize": {
                            "type": "string"
                          },
                          "controlPlane": {
                            "type": "boolean"
                          },
                          "evictionThresholdResources": {
                            "type": "string"
                          },
                          "kubeReserved": {
                            "type": "boolean"
                          },
                          "kubeadmToken": {
                            "type": "string"
                          },
                          "kubeadmTokenCAHash": {
                            "type": "string"
                          },
                          "loadBalancerAddress": {
                            "type": "string"
                          },
                          "masterAddress": {
                            "type": "string"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "serviceCIDR": {
                            "type": "string"
                          },
                          "serviceCidrRange": {
                            "type": "string"
                          },
                          "systemReservedResources": {
                            "type": "string"
                          },
                          "useStandardNodePortRange": {
                            "type": "boolean"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "kurl": {
                        "type": "object",
                        "properties": {
                          "additionalNoProxyAddresses": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "airgap": {
                            "type": "boolean"
                          },
                          "excludeBuiltinHostPreflights": {
                            "type": "boolean"
                          },
                          "hostPreflightEnforceWarnings": {
                            "type": "boolean"
                          },
                          "hostPreflightIgnore": {
                            "type": "boolean"
                          },
                          "hostPreflights": {
                            "description": "HostPreflight is the Schema for the hostpreflights API",
                            "type": "object",
                            "properties": {
                              "apiVersion": {
                                "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                                "type": "string"
                              },
                              "kind": {
                                "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                                "type": "string"
                              },
                              "metadata": {
                                "type": "object"
                              },
                              "spec": {
                                "description": "HostPreflightSpec defines the desired state of HostPreflight",
                                "type": "object",
                                "properties": {
                                  "analyzers": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "blockDevices": {
                                          "type": "object",
                                          "required": [
                                            "includeUnmountedPartitions",
                                            "minimumAcceptableSize",
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "includeUnmountedPartitions": {
                                              "type": "boolean"
                                            },
                                            "minimumAcceptableSize": {
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "certificate": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "cpu": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "diskUsage": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "filesystemPerformance": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "hostOS": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "hostServices": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "http": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "httpLoadBalancer": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "ipv4Interfaces": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "kernelModules": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "memory": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "systemPackages": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "tcpConnect": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "tcpLoadBalancer": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "tcpPortStatus": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "time": {
                                          "type": "object",
                                          "required": [
                                            "outcomes"
                                          ],
                                          "properties": {
                                            "checkName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "outcomes": {
                                              "type": "array",
                                              "items": {
                                                "type": "object",
                                                "properties": {
                                                  "fail": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "pass": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "warn": {
                                                    "type": "object",
                                                    "properties": {
                                                      "message": {
                                                        "type": "string"
                                                      },
                                                      "uri": {
                                                        "type": "string"
                                                      },
                                                      "when": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "collectors": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "blockDevices": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "certificate": {
                                          "type": "object",
                                          "required": [
                                            "certificatePath",
                                            "keyPath"
                                          ],
                                          "properties": {
                                            "certificatePath": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "keyPath": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "cpu": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "diskUsage": {
                                          "type": "object",
                                          "required": [
                                            "path"
                                          ],
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "path": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "filesystemPerformance": {
                                          "description": "FilesystemPerformance benchmarks sequential write latency on a single file. The optional background IOPS feature attempts to mimic real-world conditions by running read and write workloads prior to and during benchmark execution.",
                                          "type": "object",
                                          "required": [
                                            "backgroundIOPSWarmupSeconds",
                                            "backgroundReadIOPS",
                                            "backgroundReadIOPSJobs",
                                            "backgroundWriteIOPS",
                                            "backgroundWriteIOPSJobs",
                                            "enableBackgroundIOPS"
                                          ],
                                          "properties": {
                                            "backgroundIOPSWarmupSeconds": {
                                              "description": "How long to run the background IOPS read and write workloads prior to starting the benchmarks.",
                                              "type": "integer"
                                            },
                                            "backgroundReadIOPS": {
                                              "description": "The target read IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background read jobs.",
                                              "type": "integer"
                                            },
                                            "backgroundReadIOPSJobs": {
                                              "description": "Number of threads to use for background read IOPS. This should be set high enough to reach the target specified in BackgrounReadIOPS.",
                                              "type": "integer"
                                            },
                                            "backgroundWriteIOPS": {
                                              "description": "The target write IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background write jobs.",
                                              "type": "integer"
                                            },
                                            "backgroundWriteIOPSJobs": {
                                              "description": "Number of threads to use for background write IOPS. This should be set high enough to reach the target specified in BackgroundWriteIOPS. Example: If BackgroundWriteIOPS is 100 and write latency is 10ms then a single job would barely be able to reach 100 IOPS so this should be at least 2.",
                                              "type": "integer"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "datasync": {
                                              "description": "Whether to call datasync on the file after each write. Skipped if Sync is also true. Does not apply to background IOPS task.",
                                              "type": "boolean"
                                            },
                                            "directory": {
                                              "description": "The directory where the benchmark will create files.",
                                              "type": "string"
                                            },
                                            "enableBackgroundIOPS": {
                                              "description": "Enable the background IOPS feature.",
                                              "type": "boolean"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "fileSize": {
                                              "description": "The size of the file used in the benchmark. The number of IO operations for the benchmark will be FileSize / OperationSizeBytes. Accepts valid Kubernetes resource units such as Mi.",
                                              "type": "string"
                                            },
                                            "operationSize": {
                                              "description": "The size of each write operation performed while benchmarking. This does not apply to the background IOPS feature if enabled, since those must be fixed at 4096.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "sync": {
                                              "description": "Whether to call sync on the file after each write. Does not apply to background IOPS task.",
                                              "type": "boolean"
                                            },
                                            "timeout": {
                                              "description": "Total timeout, including background IOPS setup and warmup if enabled.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "hostOS": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "hostServices": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "http": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "get": {
                                              "type": "object",
                                              "required": [
                                                "url"
                                              ],
                                              "properties": {
                                                "headers": {
                                                  "type": "object",
                                                  "additionalProperties": {
                                                    "type": "string"
                                                  }
                                                },
                                                "insecureSkipVerify": {
                                                  "type": "boolean"
                                                },
                                                "url": {
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "post": {
                                              "type": "object",
                                              "required": [
                                                "url"
                                              ],
                                              "properties": {
                                                "body": {
                                                  "type": "string"
                                                },
                                                "headers": {
                                                  "type": "object",
                                                  "additionalProperties": {
                                                    "type": "string"
                                                  }
                                                },
                                                "insecureSkipVerify": {
                                                  "type": "boolean"
                                                },
                                                "url": {
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "put": {
                                              "type": "object",
                                              "required": [
                                                "url"
                                              ],
                                              "properties": {
                                                "body": {
                                                  "type": "string"
                                                },
                                                "headers": {
                                                  "type": "object",
                                                  "additionalProperties": {
                                                    "type": "string"
                                                  }
                                                },
                                                "insecureSkipVerify": {
                                                  "type": "boolean"
                                                },
                                                "url": {
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "httpLoadBalancer": {
                                          "type": "object",
                                          "required": [
                                            "address",
                                            "path",
                                            "port"
                                          ],
                                          "properties": {
                                            "address": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "path": {
                                              "type": "string"
                                            },
                                            "port": {
                                              "type": "integer"
                                            },
                                            "timeout": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "ipv4Interfaces": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "kernelModules": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "kubernetes": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "memory": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "systemPackages": {
                                          "type": "object",
                                          "properties": {
                                            "amzn": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "amzn2": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "centos": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "centos7": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "centos8": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "ol": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "ol7": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "ol8": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "rhel": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "rhel7": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "rhel8": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "ubuntu": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "ubuntu16": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "ubuntu18": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "ubuntu20": {
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        },
                                        "tcpConnect": {
                                          "type": "object",
                                          "required": [
                                            "address"
                                          ],
                                          "properties": {
                                            "address": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "timeout": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "tcpLoadBalancer": {
                                          "type": "object",
                                          "required": [
                                            "address",
                                            "port"
                                          ],
                                          "properties": {
                                            "address": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "port": {
                                              "type": "integer"
                                            },
                                            "timeout": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "tcpPortStatus": {
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "interface": {
                                              "type": "string"
                                            },
                                            "port": {
                                              "type": "integer"
                                            }
                                          }
                                        },
                                        "time": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "remoteCollectors": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "blockDevices": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "certificate": {
                                          "type": "object",
                                          "required": [
                                            "certificatePath",
                                            "keyPath"
                                          ],
                                          "properties": {
                                            "certificatePath": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "keyPath": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "cpu": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "diskUsage": {
                                          "type": "object",
                                          "required": [
                                            "path"
                                          ],
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "path": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "filesystemPerformance": {
                                          "description": "RemoteFilesystemPerformance benchmarks sequential write latency on a single file. The optional background IOPS feature attempts to mimic real-world conditions by running read and write workloads prior to and during benchmark execution.",
                                          "type": "object",
                                          "required": [
                                            "backgroundIOPSWarmupSeconds",
                                            "backgroundReadIOPS",
                                            "backgroundReadIOPSJobs",
                                            "backgroundWriteIOPS",
                                            "backgroundWriteIOPSJobs",
                                            "enableBackgroundIOPS"
                                          ],
                                          "properties": {
                                            "backgroundIOPSWarmupSeconds": {
                                              "description": "How long to run the background IOPS read and write workloads prior to starting the benchmarks.",
                                              "type": "integer"
                                            },
                                            "backgroundReadIOPS": {
                                              "description": "The target read IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background read jobs.",
                                              "type": "integer"
                                            },
                                            "backgroundReadIOPSJobs": {
                                              "description": "Number of threads to use for background read IOPS. This should be set high enough to reach the target specified in BackgrounReadIOPS.",
                                              "type": "integer"
                                            },
                                            "backgroundWriteIOPS": {
                                              "description": "The target write IOPS to run while benchmarking. This is a limit and there is no guarantee it will be reached. This is the total IOPS for all background write jobs.",
                                              "type": "integer"
                                            },
                                            "backgroundWriteIOPSJobs": {
                                              "description": "Number of threads to use for background write IOPS. This should be set high enough to reach the target specified in BackgroundWriteIOPS. Example: If BackgroundWriteIOPS is 100 and write latency is 10ms then a single job would barely be able to reach 100 IOPS so this should be at least 2.",
                                              "type": "integer"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "datasync": {
                                              "description": "Whether to call datasync on the file after each write. Skipped if Sync is also true. Does not apply to background IOPS task.",
                                              "type": "boolean"
                                            },
                                            "directory": {
                                              "description": "The directory where the benchmark will create files.",
                                              "type": "string"
                                            },
                                            "enableBackgroundIOPS": {
                                              "description": "Enable the background IOPS feature.",
                                              "type": "boolean"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "fileSize": {
                                              "description": "The size of the file used in the benchmark. The number of IO operations for the benchmark will be FileSize / OperationSizeBytes. Accepts valid Kubernetes resource units such as Mi.",
                                              "type": "string"
                                            },
                                            "operationSize": {
                                              "description": "The size of each write operation performed while benchmarking. This does not apply to the background IOPS feature if enabled, since those must be fixed at 4096.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "sync": {
                                              "description": "Whether to call sync on the file after each write. Does not apply to background IOPS task.",
                                              "type": "boolean"
                                            },
                                            "timeout": {
                                              "description": "Total timeout, including background IOPS setup and warmup if enabled.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "hostServices": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "http": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "get": {
                                              "type": "object",
                                              "required": [
                                                "url"
                                              ],
                                              "properties": {
                                                "headers": {
                                                  "type": "object",
                                                  "additionalProperties": {
                                                    "type": "string"
                                                  }
                                                },
                                                "insecureSkipVerify": {
                                                  "type": "boolean"
                                                },
                                                "url": {
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "post": {
                                              "type": "object",
                                              "required": [
                                                "url"
                                              ],
                                              "properties": {
                                                "body": {
                                                  "type": "string"
                                                },
                                                "headers": {
                                                  "type": "object",
                                                  "additionalProperties": {
                                                    "type": "string"
                                                  }
                                                },
                                                "insecureSkipVerify": {
                                                  "type": "boolean"
                                                },
                                                "url": {
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "put": {
                                              "type": "object",
                                              "required": [
                                                "url"
                                              ],
                                              "properties": {
                                                "body": {
                                                  "type": "string"
                                                },
                                                "headers": {
                                                  "type": "object",
                                                  "additionalProperties": {
                                                    "type": "string"
                                                  }
                                                },
                                                "insecureSkipVerify": {
                                                  "type": "boolean"
                                                },
                                                "url": {
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "httpLoadBalancer": {
                                          "type": "object",
                                          "required": [
                                            "address",
                                            "path",
                                            "port"
                                          ],
                                          "properties": {
                                            "address": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "path": {
                                              "type": "string"
                                            },
                                            "port": {
                                              "type": "integer"
                                            },
                                            "timeout": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "ipv4Interfaces": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "kernelModules": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "memory": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "systemPackages": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "tcpConnect": {
                                          "type": "object",
                                          "required": [
                                            "address"
                                          ],
                                          "properties": {
                                            "address": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "timeout": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "tcpLoadBalancer": {
                                          "type": "object",
                                          "required": [
                                            "address",
                                            "port"
                                          ],
                                          "properties": {
                                            "address": {
                                              "type": "string"
                                            },
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "port": {
                                              "type": "integer"
                                            },
                                            "timeout": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "tcpPortStatus": {
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            },
                                            "interface": {
                                              "type": "string"
                                            },
                                            "port": {
                                              "type": "integer"
                                            }
                                          }
                                        },
                                        "time": {
                                          "type": "object",
                                          "properties": {
                                            "collectorName": {
                                              "type": "string"
                                            },
                                            "exclude": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "status": {
                                "description": "HostPreflightStatus defines the observed state of HostPreflight",
                                "type": "object"
                              }
                            }
                          },
                          "hostnameCheck": {
                            "type": "string"
                          },
                          "ignoreRemoteLoadImagesPrompt": {
                            "type": "boolean"
                          },
                          "ignoreRemoteUpgradePrompt": {
                            "type": "boolean"
                          },
                          "installerVersion": {
                            "type": "string"
                          },
                          "ipv6": {
                            "type": "boolean"
                          },
                          "licenseURL": {
                            "type": "string"
                          },
                          "nameserver": {
                            "type": "string"
                          },
                          "noProxy": {
                            "type": "boolean"
                          },
                          "privateAddress": {
                            "type": "string"
                          },
                          "proxyAddress": {
                            "type": "string"
                          },
                          "publicAddress": {
                            "type": "string"
                          },
                          "skipSystemPackageInstall": {
                            "type": "boolean"
                          }
                        }
                      },
                      "longhorn": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "storageOverProvisioningPercentage": {
                            "type": "integer"
                          },
                          "uiBindPort": {
                            "type": "integer"
                          },
                          "uiReplicaCount": {
                            "type": "integer"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "metricsServer": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "minio": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "claimSize": {
                            "type": "string"
                          },
                          "hostPath": {
                            "type": "string"
                          },
                          "namespace": {
                            "type": "string"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "openebs": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "cstorStorageClassName": {
                            "type": "string"
                          },
                          "isCstorEnabled": {
                            "type": "boolean"
                          },
                          "isLocalPVEnabled": {
                            "type": "boolean"
                          },
                          "localPVStorageClassName": {
                            "type": "string"
                          },
                          "namespace": {
                            "type": "string"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "prometheus": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "serviceType": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "registry": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "publishPort": {
                            "type": "integer"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "rke2": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "rook": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "blockDeviceFilter": {
                            "type": "string"
                          },
                          "bypassUpgradeWarning": {
                            "type": "boolean"
                          },
                          "cephReplicaCount": {
                            "type": "integer"
                          },
                          "hostpathRequiresPrivileged": {
                            "type": "boolean"
                          },
                          "isBlockStorageEnabled": {
                            "type": "boolean"
                          },
                          "isSharedFilesystemDisabled": {
                            "type": "boolean"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "storageClassName": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "selinuxConfig": {
                        "type": "object",
                        "properties": {
                          "chconCmds": {
                            "type": "array",
                            "items": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "disableSelinux": {
                            "type": "boolean"
                          },
                          "preserveConfig": {
                            "type": "boolean"
                          },
                          "selinux": {
                            "type": "string"
                          },
                          "semanageCmds": {
                            "type": "array",
                            "items": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "type": {
                            "type": "string"
                          }
                        }
                      },
                      "sonobuoy": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "ufwConfig": {
                        "type": "object",
                        "properties": {
                          "bypassUFWWarning": {
                            "type": "boolean"
                          },
                          "disableUFW": {
                            "type": "boolean"
                          },
                          "hardFailOnUFW": {
                            "type": "boolean"
                          }
                        }
                      },
                      "velero": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "disableCLI": {
                            "type": "boolean"
                          },
                          "disableRestic": {
                            "type": "boolean"
                          },
                          "localBucket": {
                            "type": "string"
                          },
                          "namespace": {
                            "type": "string"
                          },
                          "resticRequiresPrivileged": {
                            "type": "boolean"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      },
                      "weave": {
                        "type": "object",
                        "required": [
                          "version"
                        ],
                        "properties": {
                          "isEncryptionDisabled": {
                            "type": "boolean"
                          },
                          "noMasqLocal": {
                            "description": "NoMasqLocal if not present defaults to true, which will expose the original client IP address in the X-Forwarded-For header.",
                            "type": "boolean"
                          },
                          "podCIDR": {
                            "type": "string"
                          },
                          "podCidrRange": {
                            "type": "string"
                          },
                          "s3Override": {
                            "type": "string"
                          },
                          "version": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "InstallerStatus defines the observed state of Installer",
                    "type": "object"
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:50:20Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:50:20Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "installers",
          "singular": "installer",
          "kind": "Installer",
          "listKind": "InstallerList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "instancemanagers.longhorn.io",
        "uid": "5edad4ac-cbca-4ab5-ae55-a335c56f5514",
        "resourceVersion": "834",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "InstanceManager"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"InstanceManager\"},\"name\":\"instancemanagers.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"InstanceManager\",\"listKind\":\"InstanceManagerList\",\"plural\":\"instancemanagers\",\"shortNames\":[\"lhim\"],\"singular\":\"instancemanager\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The state of the instance manager\",\"jsonPath\":\".status.currentState\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The type of the instance manager (engine or replica)\",\"jsonPath\":\".spec.type\",\"name\":\"Type\",\"type\":\"string\"},{\"description\":\"The node that the instance manager is running on\",\"jsonPath\":\".spec.nodeID\",\"name\":\"Node\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "instancemanagers",
          "singular": "instancemanager",
          "shortNames": [
            "lhim"
          ],
          "kind": "InstanceManager",
          "listKind": "InstanceManagerList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The state of the instance manager",
                "jsonPath": ".status.currentState"
              },
              {
                "name": "Type",
                "type": "string",
                "description": "The type of the instance manager (engine or replica)",
                "jsonPath": ".spec.type"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node that the instance manager is running on",
                "jsonPath": ".spec.nodeID"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "instancemanagers",
          "singular": "instancemanager",
          "shortNames": [
            "lhim"
          ],
          "kind": "InstanceManager",
          "listKind": "InstanceManagerList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "nodes.longhorn.io",
        "uid": "ba05735e-1b14-469e-b1ed-affa077dc2fe",
        "resourceVersion": "831",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "Node"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"Node\"},\"name\":\"nodes.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"Node\",\"listKind\":\"NodeList\",\"plural\":\"nodes\",\"shortNames\":[\"lhn\"],\"singular\":\"node\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"Indicate whether the node is ready\",\"jsonPath\":\".status.conditions['Ready']['status']\",\"name\":\"Ready\",\"type\":\"string\"},{\"description\":\"Indicate whether the user disabled/enabled replica scheduling for the node\",\"jsonPath\":\".spec.allowScheduling\",\"name\":\"AllowScheduling\",\"type\":\"boolean\"},{\"description\":\"Indicate whether Longhorn can schedule replicas on the node\",\"jsonPath\":\".status.conditions['Schedulable']['status']\",\"name\":\"Schedulable\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "nodes",
          "singular": "node",
          "shortNames": [
            "lhn"
          ],
          "kind": "Node",
          "listKind": "NodeList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "Ready",
                "type": "string",
                "description": "Indicate whether the node is ready",
                "jsonPath": ".status.conditions['Ready']['status']"
              },
              {
                "name": "AllowScheduling",
                "type": "boolean",
                "description": "Indicate whether the user disabled/enabled replica scheduling for the node",
                "jsonPath": ".spec.allowScheduling"
              },
              {
                "name": "Schedulable",
                "type": "string",
                "description": "Indicate whether Longhorn can schedule replicas on the node",
                "jsonPath": ".status.conditions['Schedulable']['status']"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "nodes",
          "singular": "node",
          "shortNames": [
            "lhn"
          ],
          "kind": "Node",
          "listKind": "NodeList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "podvolumebackups.velero.io",
        "uid": "baf5cbab-8bf8-4a98-b1d6-05f1ce4642cb",
        "resourceVersion": "1845",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"podvolumebackups.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"PodVolumeBackup\",\"listKind\":\"PodVolumeBackupList\",\"plural\":\"podvolumebackups\",\"singular\":\"podvolumebackup\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"PodVolumeBackupSpec is the specification for a PodVolumeBackup.\",\"properties\":{\"backupStorageLocation\":{\"description\":\"BackupStorageLocation is the name of the backup storage location where the restic repository is stored.\",\"type\":\"string\"},\"node\":{\"description\":\"Node is the name of the node that the Pod is running on.\",\"type\":\"string\"},\"pod\":{\"description\":\"Pod is a reference to the pod containing the volume to be backed up.\",\"properties\":{\"apiVersion\":{\"description\":\"API version of the referent.\",\"type\":\"string\"},\"fieldPath\":{\"description\":\"If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \\\"spec.containers{name}\\\" (where \\\"name\\\" refers to the name of the container that triggered the event) or if no container name is specified \\\"spec.containers[2]\\\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\",\"type\":\"string\"},\"namespace\":{\"description\":\"Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\",\"type\":\"string\"},\"resourceVersion\":{\"description\":\"Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\",\"type\":\"string\"},\"uid\":{\"description\":\"UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\",\"type\":\"string\"}},\"type\":\"object\"},\"repoIdentifier\":{\"description\":\"RepoIdentifier is the restic repository identifier.\",\"type\":\"string\"},\"tags\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"Tags are a map of key-value pairs that should be applied to the volume backup as tags.\",\"type\":\"object\"},\"volume\":{\"description\":\"Volume is the name of the volume within the Pod to be backed up.\",\"type\":\"string\"}},\"required\":[\"backupStorageLocation\",\"node\",\"pod\",\"repoIdentifier\",\"volume\"],\"type\":\"object\"},\"status\":{\"description\":\"PodVolumeBackupStatus is the current status of a PodVolumeBackup.\",\"properties\":{\"completionTimestamp\":{\"description\":\"CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"message\":{\"description\":\"Message is a message about the pod volume backup's status.\",\"type\":\"string\"},\"path\":{\"description\":\"Path is the full path within the controller pod being backed up.\",\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the PodVolumeBackup.\",\"enum\":[\"New\",\"InProgress\",\"Completed\",\"Failed\"],\"type\":\"string\"},\"progress\":{\"description\":\"Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.\",\"properties\":{\"bytesDone\":{\"format\":\"int64\",\"type\":\"integer\"},\"totalBytes\":{\"format\":\"int64\",\"type\":\"integer\"}},\"type\":\"object\"},\"snapshotID\":{\"description\":\"SnapshotID is the identifier for the snapshot of the pod volume.\",\"type\":\"string\"},\"startTimestamp\":{\"description\":\"StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "podvolumebackups",
          "singular": "podvolumebackup",
          "kind": "PodVolumeBackup",
          "listKind": "PodVolumeBackupList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "PodVolumeBackupSpec is the specification for a PodVolumeBackup.",
                    "type": "object",
                    "required": [
                      "backupStorageLocation",
                      "node",
                      "pod",
                      "repoIdentifier",
                      "volume"
                    ],
                    "properties": {
                      "backupStorageLocation": {
                        "description": "BackupStorageLocation is the name of the backup storage location where the restic repository is stored.",
                        "type": "string"
                      },
                      "node": {
                        "description": "Node is the name of the node that the Pod is running on.",
                        "type": "string"
                      },
                      "pod": {
                        "description": "Pod is a reference to the pod containing the volume to be backed up.",
                        "type": "object",
                        "properties": {
                          "apiVersion": {
                            "description": "API version of the referent.",
                            "type": "string"
                          },
                          "fieldPath": {
                            "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          },
                          "resourceVersion": {
                            "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                            "type": "string"
                          },
                          "uid": {
                            "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                            "type": "string"
                          }
                        }
                      },
                      "repoIdentifier": {
                        "description": "RepoIdentifier is the restic repository identifier.",
                        "type": "string"
                      },
                      "tags": {
                        "description": "Tags are a map of key-value pairs that should be applied to the volume backup as tags.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "volume": {
                        "description": "Volume is the name of the volume within the Pod to be backed up.",
                        "type": "string"
                      }
                    }
                  },
                  "status": {
                    "description": "PodVolumeBackupStatus is the current status of a PodVolumeBackup.",
                    "type": "object",
                    "properties": {
                      "completionTimestamp": {
                        "description": "CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "message": {
                        "description": "Message is a message about the pod volume backup's status.",
                        "type": "string"
                      },
                      "path": {
                        "description": "Path is the full path within the controller pod being backed up.",
                        "type": "string"
                      },
                      "phase": {
                        "description": "Phase is the current state of the PodVolumeBackup.",
                        "type": "string",
                        "enum": [
                          "New",
                          "InProgress",
                          "Completed",
                          "Failed"
                        ]
                      },
                      "progress": {
                        "description": "Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.",
                        "type": "object",
                        "properties": {
                          "bytesDone": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "totalBytes": {
                            "type": "integer",
                            "format": "int64"
                          }
                        }
                      },
                      "snapshotID": {
                        "description": "SnapshotID is the identifier for the snapshot of the pod volume.",
                        "type": "string"
                      },
                      "startTimestamp": {
                        "description": "StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "podvolumebackups",
          "singular": "podvolumebackup",
          "kind": "PodVolumeBackup",
          "listKind": "PodVolumeBackupList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "podvolumerestores.velero.io",
        "uid": "c0af8e3e-e6c6-4e45-ac5e-e8252ff99c62",
        "resourceVersion": "1846",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"podvolumerestores.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"PodVolumeRestore\",\"listKind\":\"PodVolumeRestoreList\",\"plural\":\"podvolumerestores\",\"singular\":\"podvolumerestore\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"PodVolumeRestoreSpec is the specification for a PodVolumeRestore.\",\"properties\":{\"backupStorageLocation\":{\"description\":\"BackupStorageLocation is the name of the backup storage location where the restic repository is stored.\",\"type\":\"string\"},\"pod\":{\"description\":\"Pod is a reference to the pod containing the volume to be restored.\",\"properties\":{\"apiVersion\":{\"description\":\"API version of the referent.\",\"type\":\"string\"},\"fieldPath\":{\"description\":\"If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \\\"spec.containers{name}\\\" (where \\\"name\\\" refers to the name of the container that triggered the event) or if no container name is specified \\\"spec.containers[2]\\\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\",\"type\":\"string\"},\"namespace\":{\"description\":\"Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\",\"type\":\"string\"},\"resourceVersion\":{\"description\":\"Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\",\"type\":\"string\"},\"uid\":{\"description\":\"UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\",\"type\":\"string\"}},\"type\":\"object\"},\"repoIdentifier\":{\"description\":\"RepoIdentifier is the restic repository identifier.\",\"type\":\"string\"},\"snapshotID\":{\"description\":\"SnapshotID is the ID of the volume snapshot to be restored.\",\"type\":\"string\"},\"volume\":{\"description\":\"Volume is the name of the volume within the Pod to be restored.\",\"type\":\"string\"}},\"required\":[\"backupStorageLocation\",\"pod\",\"repoIdentifier\",\"snapshotID\",\"volume\"],\"type\":\"object\"},\"status\":{\"description\":\"PodVolumeRestoreStatus is the current status of a PodVolumeRestore.\",\"properties\":{\"completionTimestamp\":{\"description\":\"CompletionTimestamp records the time a restore was completed. Completion time is recorded even on failed restores. The server's time is used for CompletionTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"message\":{\"description\":\"Message is a message about the pod volume restore's status.\",\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the PodVolumeRestore.\",\"enum\":[\"New\",\"InProgress\",\"Completed\",\"Failed\"],\"type\":\"string\"},\"progress\":{\"description\":\"Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.\",\"properties\":{\"bytesDone\":{\"format\":\"int64\",\"type\":\"integer\"},\"totalBytes\":{\"format\":\"int64\",\"type\":\"integer\"}},\"type\":\"object\"},\"startTimestamp\":{\"description\":\"StartTimestamp records the time a restore was started. The server's time is used for StartTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "podvolumerestores",
          "singular": "podvolumerestore",
          "kind": "PodVolumeRestore",
          "listKind": "PodVolumeRestoreList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "PodVolumeRestoreSpec is the specification for a PodVolumeRestore.",
                    "type": "object",
                    "required": [
                      "backupStorageLocation",
                      "pod",
                      "repoIdentifier",
                      "snapshotID",
                      "volume"
                    ],
                    "properties": {
                      "backupStorageLocation": {
                        "description": "BackupStorageLocation is the name of the backup storage location where the restic repository is stored.",
                        "type": "string"
                      },
                      "pod": {
                        "description": "Pod is a reference to the pod containing the volume to be restored.",
                        "type": "object",
                        "properties": {
                          "apiVersion": {
                            "description": "API version of the referent.",
                            "type": "string"
                          },
                          "fieldPath": {
                            "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          },
                          "resourceVersion": {
                            "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                            "type": "string"
                          },
                          "uid": {
                            "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                            "type": "string"
                          }
                        }
                      },
                      "repoIdentifier": {
                        "description": "RepoIdentifier is the restic repository identifier.",
                        "type": "string"
                      },
                      "snapshotID": {
                        "description": "SnapshotID is the ID of the volume snapshot to be restored.",
                        "type": "string"
                      },
                      "volume": {
                        "description": "Volume is the name of the volume within the Pod to be restored.",
                        "type": "string"
                      }
                    }
                  },
                  "status": {
                    "description": "PodVolumeRestoreStatus is the current status of a PodVolumeRestore.",
                    "type": "object",
                    "properties": {
                      "completionTimestamp": {
                        "description": "CompletionTimestamp records the time a restore was completed. Completion time is recorded even on failed restores. The server's time is used for CompletionTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "message": {
                        "description": "Message is a message about the pod volume restore's status.",
                        "type": "string"
                      },
                      "phase": {
                        "description": "Phase is the current state of the PodVolumeRestore.",
                        "type": "string",
                        "enum": [
                          "New",
                          "InProgress",
                          "Completed",
                          "Failed"
                        ]
                      },
                      "progress": {
                        "description": "Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.",
                        "type": "object",
                        "properties": {
                          "bytesDone": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "totalBytes": {
                            "type": "integer",
                            "format": "int64"
                          }
                        }
                      },
                      "startTimestamp": {
                        "description": "StartTimestamp records the time a restore was started. The server's time is used for StartTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "podvolumerestores",
          "singular": "podvolumerestore",
          "kind": "PodVolumeRestore",
          "listKind": "PodVolumeRestoreList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "recurringjobs.longhorn.io",
        "uid": "1dd0af68-4de9-49c6-a931-9737fbcbd33e",
        "resourceVersion": "858",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "RecurringJob"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"RecurringJob\"},\"name\":\"recurringjobs.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"RecurringJob\",\"listKind\":\"RecurringJobList\",\"plural\":\"recurringjobs\",\"shortNames\":[\"lhrj\"],\"singular\":\"recurringjob\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"Sets groupings to the jobs. When set to \\\"default\\\" group will be added to the volume label when no other job label exist in volume.\",\"jsonPath\":\".spec.groups\",\"name\":\"Groups\",\"type\":\"string\"},{\"description\":\"Should be one of \\\"backup\\\" or \\\"snapshot\\\".\",\"jsonPath\":\".spec.task\",\"name\":\"Task\",\"type\":\"string\"},{\"description\":\"The cron expression represents recurring job scheduling.\",\"jsonPath\":\".spec.cron\",\"name\":\"Cron\",\"type\":\"string\"},{\"description\":\"The number of snapshots/backups to keep for the volume.\",\"jsonPath\":\".spec.retain\",\"name\":\"Retain\",\"type\":\"integer\"},{\"description\":\"The concurrent job to run by each cron job.\",\"jsonPath\":\".spec.concurrency\",\"name\":\"Concurrency\",\"type\":\"integer\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"},{\"description\":\"Specify the labels\",\"jsonPath\":\".spec.labels\",\"name\":\"Labels\",\"type\":\"string\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"metadata\":{\"properties\":{\"name\":{\"type\":\"string\"}},\"type\":\"object\"},\"spec\":{\"properties\":{\"concurrency\":{\"type\":\"integer\"},\"cron\":{\"type\":\"string\"},\"groups\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"labels\":{\"x-kubernetes-preserve-unknown-fields\":true},\"retain\":{\"type\":\"integer\"},\"task\":{\"pattern\":\"^snapshot|backup$\",\"type\":\"string\"}},\"type\":\"object\"},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "recurringjobs",
          "singular": "recurringjob",
          "shortNames": [
            "lhrj"
          ],
          "kind": "RecurringJob",
          "listKind": "RecurringJobList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "metadata": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      }
                    }
                  },
                  "spec": {
                    "type": "object",
                    "properties": {
                      "concurrency": {
                        "type": "integer"
                      },
                      "cron": {
                        "type": "string"
                      },
                      "groups": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "labels": {
                        "x-kubernetes-preserve-unknown-fields": true
                      },
                      "retain": {
                        "type": "integer"
                      },
                      "task": {
                        "type": "string",
                        "pattern": "^snapshot|backup$"
                      }
                    }
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "Groups",
                "type": "string",
                "description": "Sets groupings to the jobs. When set to \"default\" group will be added to the volume label when no other job label exist in volume.",
                "jsonPath": ".spec.groups"
              },
              {
                "name": "Task",
                "type": "string",
                "description": "Should be one of \"backup\" or \"snapshot\".",
                "jsonPath": ".spec.task"
              },
              {
                "name": "Cron",
                "type": "string",
                "description": "The cron expression represents recurring job scheduling.",
                "jsonPath": ".spec.cron"
              },
              {
                "name": "Retain",
                "type": "integer",
                "description": "The number of snapshots/backups to keep for the volume.",
                "jsonPath": ".spec.retain"
              },
              {
                "name": "Concurrency",
                "type": "integer",
                "description": "The concurrent job to run by each cron job.",
                "jsonPath": ".spec.concurrency"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              },
              {
                "name": "Labels",
                "type": "string",
                "description": "Specify the labels",
                "jsonPath": ".spec.labels"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "recurringjobs",
          "singular": "recurringjob",
          "shortNames": [
            "lhrj"
          ],
          "kind": "RecurringJob",
          "listKind": "RecurringJobList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "replicas.longhorn.io",
        "uid": "7224fe59-5bdc-4217-90a0-f3a360b04c57",
        "resourceVersion": "819",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "Replica"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"Replica\"},\"name\":\"replicas.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"Replica\",\"listKind\":\"ReplicaList\",\"plural\":\"replicas\",\"shortNames\":[\"lhr\"],\"singular\":\"replica\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The current state of the replica\",\"jsonPath\":\".status.currentState\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The node that the replica is on\",\"jsonPath\":\".spec.nodeID\",\"name\":\"Node\",\"type\":\"string\"},{\"description\":\"The disk that the replica is on\",\"jsonPath\":\".spec.diskID\",\"name\":\"Disk\",\"type\":\"string\"},{\"description\":\"The instance manager of the replica\",\"jsonPath\":\".status.instanceManagerName\",\"name\":\"InstanceManager\",\"type\":\"string\"},{\"description\":\"The current image of the replica\",\"jsonPath\":\".status.currentImage\",\"name\":\"Image\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "replicas",
          "singular": "replica",
          "shortNames": [
            "lhr"
          ],
          "kind": "Replica",
          "listKind": "ReplicaList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The current state of the replica",
                "jsonPath": ".status.currentState"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node that the replica is on",
                "jsonPath": ".spec.nodeID"
              },
              {
                "name": "Disk",
                "type": "string",
                "description": "The disk that the replica is on",
                "jsonPath": ".spec.diskID"
              },
              {
                "name": "InstanceManager",
                "type": "string",
                "description": "The instance manager of the replica",
                "jsonPath": ".status.instanceManagerName"
              },
              {
                "name": "Image",
                "type": "string",
                "description": "The current image of the replica",
                "jsonPath": ".status.currentImage"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "replicas",
          "singular": "replica",
          "shortNames": [
            "lhr"
          ],
          "kind": "Replica",
          "listKind": "ReplicaList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "resticrepositories.velero.io",
        "uid": "d9d73749-6666-4076-acdc-8a613e956b6b",
        "resourceVersion": "1847",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"resticrepositories.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"ResticRepository\",\"listKind\":\"ResticRepositoryList\",\"plural\":\"resticrepositories\",\"singular\":\"resticrepository\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"ResticRepositorySpec is the specification for a ResticRepository.\",\"properties\":{\"backupStorageLocation\":{\"description\":\"BackupStorageLocation is the name of the BackupStorageLocation that should contain this repository.\",\"type\":\"string\"},\"maintenanceFrequency\":{\"description\":\"MaintenanceFrequency is how often maintenance should be run.\",\"type\":\"string\"},\"resticIdentifier\":{\"description\":\"ResticIdentifier is the full restic-compatible string for identifying this repository.\",\"type\":\"string\"},\"volumeNamespace\":{\"description\":\"VolumeNamespace is the namespace this restic repository contains pod volume backups for.\",\"type\":\"string\"}},\"required\":[\"backupStorageLocation\",\"maintenanceFrequency\",\"resticIdentifier\",\"volumeNamespace\"],\"type\":\"object\"},\"status\":{\"description\":\"ResticRepositoryStatus is the current status of a ResticRepository.\",\"properties\":{\"lastMaintenanceTime\":{\"description\":\"LastMaintenanceTime is the last time maintenance was run.\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"message\":{\"description\":\"Message is a message about the current status of the ResticRepository.\",\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the ResticRepository.\",\"enum\":[\"New\",\"Ready\",\"NotReady\"],\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "resticrepositories",
          "singular": "resticrepository",
          "kind": "ResticRepository",
          "listKind": "ResticRepositoryList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "ResticRepositorySpec is the specification for a ResticRepository.",
                    "type": "object",
                    "required": [
                      "backupStorageLocation",
                      "maintenanceFrequency",
                      "resticIdentifier",
                      "volumeNamespace"
                    ],
                    "properties": {
                      "backupStorageLocation": {
                        "description": "BackupStorageLocation is the name of the BackupStorageLocation that should contain this repository.",
                        "type": "string"
                      },
                      "maintenanceFrequency": {
                        "description": "MaintenanceFrequency is how often maintenance should be run.",
                        "type": "string"
                      },
                      "resticIdentifier": {
                        "description": "ResticIdentifier is the full restic-compatible string for identifying this repository.",
                        "type": "string"
                      },
                      "volumeNamespace": {
                        "description": "VolumeNamespace is the namespace this restic repository contains pod volume backups for.",
                        "type": "string"
                      }
                    }
                  },
                  "status": {
                    "description": "ResticRepositoryStatus is the current status of a ResticRepository.",
                    "type": "object",
                    "properties": {
                      "lastMaintenanceTime": {
                        "description": "LastMaintenanceTime is the last time maintenance was run.",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "message": {
                        "description": "Message is a message about the current status of the ResticRepository.",
                        "type": "string"
                      },
                      "phase": {
                        "description": "Phase is the current state of the ResticRepository.",
                        "type": "string",
                        "enum": [
                          "New",
                          "Ready",
                          "NotReady"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "resticrepositories",
          "singular": "resticrepository",
          "kind": "ResticRepository",
          "listKind": "ResticRepositoryList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "restores.velero.io",
        "uid": "ba0cc506-4167-41ce-b243-868d83440ee5",
        "resourceVersion": "1848",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"restores.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"Restore\",\"listKind\":\"RestoreList\",\"plural\":\"restores\",\"singular\":\"restore\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"Restore is a Velero resource that represents the application of resources from a Velero backup to a target Kubernetes cluster.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"RestoreSpec defines the specification for a Velero restore.\",\"properties\":{\"backupName\":{\"description\":\"BackupName is the unique name of the Velero backup to restore from.\",\"type\":\"string\"},\"excludedNamespaces\":{\"description\":\"ExcludedNamespaces contains a list of namespaces that are not included in the restore.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"excludedResources\":{\"description\":\"ExcludedResources is a slice of resource names that are not included in the restore.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"hooks\":{\"description\":\"Hooks represent custom behaviors that should be executed during or post restore.\",\"properties\":{\"resources\":{\"items\":{\"description\":\"RestoreResourceHookSpec defines one or more RestoreResrouceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.\",\"properties\":{\"excludedNamespaces\":{\"description\":\"ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"excludedResources\":{\"description\":\"ExcludedResources specifies the resources to which this hook spec does not apply.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedNamespaces\":{\"description\":\"IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedResources\":{\"description\":\"IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"labelSelector\":{\"description\":\"LabelSelector, if specified, filters the resources to which this hook spec applies.\",\"nullable\":true,\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"name\":{\"description\":\"Name is the name of this hook.\",\"type\":\"string\"},\"postHooks\":{\"description\":\"PostHooks is a list of RestoreResourceHooks to execute during and after restoring a resource.\",\"items\":{\"description\":\"RestoreResourceHook defines a restore hook for a resource.\",\"properties\":{\"exec\":{\"description\":\"Exec defines an exec restore hook.\",\"properties\":{\"command\":{\"description\":\"Command is the command and arguments to execute from within a container after a pod has been restored.\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"container\":{\"description\":\"Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.\",\"type\":\"string\"},\"execTimeout\":{\"description\":\"ExecTimeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.\",\"type\":\"string\"},\"onError\":{\"description\":\"OnError specifies how Velero should behave if it encounters an error executing this hook.\",\"enum\":[\"Continue\",\"Fail\"],\"type\":\"string\"},\"waitTimeout\":{\"description\":\"WaitTimeout defines the maximum amount of time Velero should wait for the container to be Ready before attempting to run the command.\",\"type\":\"string\"}},\"required\":[\"command\"],\"type\":\"object\"},\"init\":{\"description\":\"Init defines an init restore hook.\",\"properties\":{\"initContainers\":{\"description\":\"InitContainers is list of init containers to be added to a pod during its restore.\",\"items\":{\"description\":\"A single application container that you want to run within a pod.\",\"properties\":{\"args\":{\"description\":\"Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \\\"$$(VAR_NAME)\\\" will produce the string literal \\\"$(VAR_NAME)\\\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"command\":{\"description\":\"Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \\\"$$(VAR_NAME)\\\" will produce the string literal \\\"$(VAR_NAME)\\\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"env\":{\"description\":\"List of environment variables to set in the container. Cannot be updated.\",\"items\":{\"description\":\"EnvVar represents an environment variable present in a Container.\",\"properties\":{\"name\":{\"description\":\"Name of the environment variable. Must be a C_IDENTIFIER.\",\"type\":\"string\"},\"value\":{\"description\":\"Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \\\"$$(VAR_NAME)\\\" will produce the string literal \\\"$(VAR_NAME)\\\". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \\\"\\\".\",\"type\":\"string\"},\"valueFrom\":{\"description\":\"Source for the environment variable's value. Cannot be used if value is not empty.\",\"properties\":{\"configMapKeyRef\":{\"description\":\"Selects a key of a ConfigMap.\",\"properties\":{\"key\":{\"description\":\"The key to select.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the ConfigMap or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"},\"fieldRef\":{\"description\":\"Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['\\u003cKEY\\u003e']`, `metadata.annotations['\\u003cKEY\\u003e']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.\",\"properties\":{\"apiVersion\":{\"description\":\"Version of the schema the FieldPath is written in terms of, defaults to \\\"v1\\\".\",\"type\":\"string\"},\"fieldPath\":{\"description\":\"Path of the field to select in the specified API version.\",\"type\":\"string\"}},\"required\":[\"fieldPath\"],\"type\":\"object\"},\"resourceFieldRef\":{\"description\":\"Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.\",\"properties\":{\"containerName\":{\"description\":\"Container name: required for volumes, optional for env vars\",\"type\":\"string\"},\"divisor\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Specifies the output format of the exposed resources, defaults to \\\"1\\\"\",\"pattern\":\"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\"x-kubernetes-int-or-string\":true},\"resource\":{\"description\":\"Required: resource to select\",\"type\":\"string\"}},\"required\":[\"resource\"],\"type\":\"object\"},\"secretKeyRef\":{\"description\":\"Selects a key of a secret in the pod's namespace\",\"properties\":{\"key\":{\"description\":\"The key of the secret to select from.  Must be a valid secret key.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"}},\"type\":\"object\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"envFrom\":{\"description\":\"List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.\",\"items\":{\"description\":\"EnvFromSource represents the source of a set of ConfigMaps\",\"properties\":{\"configMapRef\":{\"description\":\"The ConfigMap to select from\",\"properties\":{\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the ConfigMap must be defined\",\"type\":\"boolean\"}},\"type\":\"object\"},\"prefix\":{\"description\":\"An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.\",\"type\":\"string\"},\"secretRef\":{\"description\":\"The Secret to select from\",\"properties\":{\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret must be defined\",\"type\":\"boolean\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"},\"image\":{\"description\":\"Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.\",\"type\":\"string\"},\"imagePullPolicy\":{\"description\":\"Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images\",\"type\":\"string\"},\"lifecycle\":{\"description\":\"Actions that the management system should take in response to container lifecycle events. Cannot be updated.\",\"properties\":{\"postStart\":{\"description\":\"PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks\",\"properties\":{\"exec\":{\"description\":\"One and only one of the following should be specified. Exec specifies the action to take.\",\"properties\":{\"command\":{\"description\":\"Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"httpGet\":{\"description\":\"HTTPGet specifies the http request to perform.\",\"properties\":{\"host\":{\"description\":\"Host name to connect to, defaults to the pod IP. You probably want to set \\\"Host\\\" in httpHeaders instead.\",\"type\":\"string\"},\"httpHeaders\":{\"description\":\"Custom headers to set in the request. HTTP allows repeated headers.\",\"items\":{\"description\":\"HTTPHeader describes a custom header to be used in HTTP probes\",\"properties\":{\"name\":{\"description\":\"The header field name\",\"type\":\"string\"},\"value\":{\"description\":\"The header field value\",\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"path\":{\"description\":\"Path to access on the HTTP server.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true},\"scheme\":{\"description\":\"Scheme to use for connecting to the host. Defaults to HTTP.\",\"type\":\"string\"}},\"required\":[\"port\"],\"type\":\"object\"},\"tcpSocket\":{\"description\":\"TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook\",\"properties\":{\"host\":{\"description\":\"Optional: Host name to connect to, defaults to the pod IP.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true}},\"required\":[\"port\"],\"type\":\"object\"}},\"type\":\"object\"},\"preStop\":{\"description\":\"PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The reason for termination is passed to the handler. The Pod's termination grace period countdown begins before the PreStop hooked is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks\",\"properties\":{\"exec\":{\"description\":\"One and only one of the following should be specified. Exec specifies the action to take.\",\"properties\":{\"command\":{\"description\":\"Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"httpGet\":{\"description\":\"HTTPGet specifies the http request to perform.\",\"properties\":{\"host\":{\"description\":\"Host name to connect to, defaults to the pod IP. You probably want to set \\\"Host\\\" in httpHeaders instead.\",\"type\":\"string\"},\"httpHeaders\":{\"description\":\"Custom headers to set in the request. HTTP allows repeated headers.\",\"items\":{\"description\":\"HTTPHeader describes a custom header to be used in HTTP probes\",\"properties\":{\"name\":{\"description\":\"The header field name\",\"type\":\"string\"},\"value\":{\"description\":\"The header field value\",\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"path\":{\"description\":\"Path to access on the HTTP server.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true},\"scheme\":{\"description\":\"Scheme to use for connecting to the host. Defaults to HTTP.\",\"type\":\"string\"}},\"required\":[\"port\"],\"type\":\"object\"},\"tcpSocket\":{\"description\":\"TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook\",\"properties\":{\"host\":{\"description\":\"Optional: Host name to connect to, defaults to the pod IP.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true}},\"required\":[\"port\"],\"type\":\"object\"}},\"type\":\"object\"}},\"type\":\"object\"},\"livenessProbe\":{\"description\":\"Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"properties\":{\"exec\":{\"description\":\"One and only one of the following should be specified. Exec specifies the action to take.\",\"properties\":{\"command\":{\"description\":\"Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"failureThreshold\":{\"description\":\"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"httpGet\":{\"description\":\"HTTPGet specifies the http request to perform.\",\"properties\":{\"host\":{\"description\":\"Host name to connect to, defaults to the pod IP. You probably want to set \\\"Host\\\" in httpHeaders instead.\",\"type\":\"string\"},\"httpHeaders\":{\"description\":\"Custom headers to set in the request. HTTP allows repeated headers.\",\"items\":{\"description\":\"HTTPHeader describes a custom header to be used in HTTP probes\",\"properties\":{\"name\":{\"description\":\"The header field name\",\"type\":\"string\"},\"value\":{\"description\":\"The header field value\",\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"path\":{\"description\":\"Path to access on the HTTP server.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true},\"scheme\":{\"description\":\"Scheme to use for connecting to the host. Defaults to HTTP.\",\"type\":\"string\"}},\"required\":[\"port\"],\"type\":\"object\"},\"initialDelaySeconds\":{\"description\":\"Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"format\":\"int32\",\"type\":\"integer\"},\"periodSeconds\":{\"description\":\"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"successThreshold\":{\"description\":\"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"tcpSocket\":{\"description\":\"TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook\",\"properties\":{\"host\":{\"description\":\"Optional: Host name to connect to, defaults to the pod IP.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true}},\"required\":[\"port\"],\"type\":\"object\"},\"terminationGracePeriodSeconds\":{\"description\":\"Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.\",\"format\":\"int64\",\"type\":\"integer\"},\"timeoutSeconds\":{\"description\":\"Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"format\":\"int32\",\"type\":\"integer\"}},\"type\":\"object\"},\"name\":{\"description\":\"Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.\",\"type\":\"string\"},\"ports\":{\"description\":\"List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \\\"***HIDDEN***\\\" address inside a container will be accessible from the network. Cannot be updated.\",\"items\":{\"description\":\"ContainerPort represents a network port in a single container.\",\"properties\":{\"containerPort\":{\"description\":\"Number of port to expose on the pod's IP address. This must be a valid port number, 0 \\u003c x \\u003c 65536.\",\"format\":\"int32\",\"type\":\"integer\"},\"hostIP\":{\"description\":\"What host IP to bind the external port to.\",\"type\":\"string\"},\"hostPort\":{\"description\":\"Number of port to expose on the host. If specified, this must be a valid port number, 0 \\u003c x \\u003c 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.\",\"format\":\"int32\",\"type\":\"integer\"},\"name\":{\"description\":\"If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.\",\"type\":\"string\"},\"protocol\":{\"description\":\"Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \\\"TCP\\\".\",\"type\":\"string\"}},\"required\":[\"containerPort\",\"protocol\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-map-keys\":[\"containerPort\",\"protocol\"],\"x-kubernetes-list-type\":\"map\"},\"readinessProbe\":{\"description\":\"Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"properties\":{\"exec\":{\"description\":\"One and only one of the following should be specified. Exec specifies the action to take.\",\"properties\":{\"command\":{\"description\":\"Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"failureThreshold\":{\"description\":\"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"httpGet\":{\"description\":\"HTTPGet specifies the http request to perform.\",\"properties\":{\"host\":{\"description\":\"Host name to connect to, defaults to the pod IP. You probably want to set \\\"Host\\\" in httpHeaders instead.\",\"type\":\"string\"},\"httpHeaders\":{\"description\":\"Custom headers to set in the request. HTTP allows repeated headers.\",\"items\":{\"description\":\"HTTPHeader describes a custom header to be used in HTTP probes\",\"properties\":{\"name\":{\"description\":\"The header field name\",\"type\":\"string\"},\"value\":{\"description\":\"The header field value\",\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"path\":{\"description\":\"Path to access on the HTTP server.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true},\"scheme\":{\"description\":\"Scheme to use for connecting to the host. Defaults to HTTP.\",\"type\":\"string\"}},\"required\":[\"port\"],\"type\":\"object\"},\"initialDelaySeconds\":{\"description\":\"Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"format\":\"int32\",\"type\":\"integer\"},\"periodSeconds\":{\"description\":\"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"successThreshold\":{\"description\":\"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"tcpSocket\":{\"description\":\"TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook\",\"properties\":{\"host\":{\"description\":\"Optional: Host name to connect to, defaults to the pod IP.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true}},\"required\":[\"port\"],\"type\":\"object\"},\"terminationGracePeriodSeconds\":{\"description\":\"Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.\",\"format\":\"int64\",\"type\":\"integer\"},\"timeoutSeconds\":{\"description\":\"Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"format\":\"int32\",\"type\":\"integer\"}},\"type\":\"object\"},\"resources\":{\"description\":\"Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\"properties\":{\"limits\":{\"additionalProperties\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"pattern\":\"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\"x-kubernetes-int-or-string\":true},\"description\":\"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\"type\":\"object\"},\"requests\":{\"additionalProperties\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"pattern\":\"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\"x-kubernetes-int-or-string\":true},\"description\":\"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\"type\":\"object\"}},\"type\":\"object\"},\"securityContext\":{\"description\":\"SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\",\"properties\":{\"allowPrivilegeEscalation\":{\"description\":\"AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN\",\"type\":\"boolean\"},\"capabilities\":{\"description\":\"The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.\",\"properties\":{\"add\":{\"description\":\"Added capabilities\",\"items\":{\"description\":\"Capability represent POSIX capabilities type\",\"type\":\"string\"},\"type\":\"array\"},\"drop\":{\"description\":\"Removed capabilities\",\"items\":{\"description\":\"Capability represent POSIX capabilities type\",\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"privileged\":{\"description\":\"Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.\",\"type\":\"boolean\"},\"procMount\":{\"description\":\"procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.\",\"type\":\"string\"},\"readOnlyRootFilesystem\":{\"description\":\"Whether this container has a read-only root filesystem. Default is false.\",\"type\":\"boolean\"},\"runAsGroup\":{\"description\":\"The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\",\"format\":\"int64\",\"type\":\"integer\"},\"runAsNonRoot\":{\"description\":\"Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\",\"type\":\"boolean\"},\"runAsUser\":{\"description\":\"The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\",\"format\":\"int64\",\"type\":\"integer\"},\"seLinuxOptions\":{\"description\":\"The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\",\"properties\":{\"level\":{\"description\":\"Level is SELinux level label that applies to the container.\",\"type\":\"string\"},\"role\":{\"description\":\"Role is a SELinux role label that applies to the container.\",\"type\":\"string\"},\"type\":{\"description\":\"Type is a SELinux type label that applies to the container.\",\"type\":\"string\"},\"user\":{\"description\":\"User is a SELinux user label that applies to the container.\",\"type\":\"string\"}},\"type\":\"object\"},\"seccompProfile\":{\"description\":\"The seccomp options to use by this container. If seccomp options are provided at both the pod \\u0026 container level, the container options override the pod options.\",\"properties\":{\"localhostProfile\":{\"description\":\"localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is \\\"Localhost\\\".\",\"type\":\"string\"},\"type\":{\"description\":\"type indicates which kind of seccomp profile will be applied. Valid options are: \\n Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.\",\"type\":\"string\"}},\"required\":[\"type\"],\"type\":\"object\"},\"windowsOptions\":{\"description\":\"The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\",\"properties\":{\"gmsaCredentialSpec\":{\"description\":\"GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.\",\"type\":\"string\"},\"gmsaCredentialSpecName\":{\"description\":\"GMSACredentialSpecName is the name of the GMSA credential spec to use.\",\"type\":\"string\"},\"hostProcess\":{\"description\":\"HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.\",\"type\":\"boolean\"},\"runAsUserName\":{\"description\":\"The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"startupProbe\":{\"description\":\"StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"properties\":{\"exec\":{\"description\":\"One and only one of the following should be specified. Exec specifies the action to take.\",\"properties\":{\"command\":{\"description\":\"Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"failureThreshold\":{\"description\":\"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"httpGet\":{\"description\":\"HTTPGet specifies the http request to perform.\",\"properties\":{\"host\":{\"description\":\"Host name to connect to, defaults to the pod IP. You probably want to set \\\"Host\\\" in httpHeaders instead.\",\"type\":\"string\"},\"httpHeaders\":{\"description\":\"Custom headers to set in the request. HTTP allows repeated headers.\",\"items\":{\"description\":\"HTTPHeader describes a custom header to be used in HTTP probes\",\"properties\":{\"name\":{\"description\":\"The header field name\",\"type\":\"string\"},\"value\":{\"description\":\"The header field value\",\"type\":\"string\"}},\"required\":[\"name\",\"value\"],\"type\":\"object\"},\"type\":\"array\"},\"path\":{\"description\":\"Path to access on the HTTP server.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true},\"scheme\":{\"description\":\"Scheme to use for connecting to the host. Defaults to HTTP.\",\"type\":\"string\"}},\"required\":[\"port\"],\"type\":\"object\"},\"initialDelaySeconds\":{\"description\":\"Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"format\":\"int32\",\"type\":\"integer\"},\"periodSeconds\":{\"description\":\"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"successThreshold\":{\"description\":\"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.\",\"format\":\"int32\",\"type\":\"integer\"},\"tcpSocket\":{\"description\":\"TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook\",\"properties\":{\"host\":{\"description\":\"Optional: Host name to connect to, defaults to the pod IP.\",\"type\":\"string\"},\"port\":{\"anyOf\":[{\"type\":\"integer\"},{\"type\":\"string\"}],\"description\":\"Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\",\"x-kubernetes-int-or-string\":true}},\"required\":[\"port\"],\"type\":\"object\"},\"terminationGracePeriodSeconds\":{\"description\":\"Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.\",\"format\":\"int64\",\"type\":\"integer\"},\"timeoutSeconds\":{\"description\":\"Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\",\"format\":\"int32\",\"type\":\"integer\"}},\"type\":\"object\"},\"stdin\":{\"description\":\"Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.\",\"type\":\"boolean\"},\"stdinOnce\":{\"description\":\"Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false\",\"type\":\"boolean\"},\"terminationMessagePath\":{\"description\":\"Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.\",\"type\":\"string\"},\"terminationMessagePolicy\":{\"description\":\"Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.\",\"type\":\"string\"},\"tty\":{\"description\":\"Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.\",\"type\":\"boolean\"},\"volumeDevices\":{\"description\":\"volumeDevices is the list of block devices to be used by the container.\",\"items\":{\"description\":\"volumeDevice describes a mapping of a raw block device within a container.\",\"properties\":{\"devicePath\":{\"description\":\"devicePath is the path inside of the container that the device will be mapped to.\",\"type\":\"string\"},\"name\":{\"description\":\"name must match the name of a persistentVolumeClaim in the pod\",\"type\":\"string\"}},\"required\":[\"devicePath\",\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"volumeMounts\":{\"description\":\"Pod volumes to mount into the container's filesystem. Cannot be updated.\",\"items\":{\"description\":\"VolumeMount describes a mounting of a Volume within a container.\",\"properties\":{\"mountPath\":{\"description\":\"Path within the container at which the volume should be mounted.  Must not contain ':'.\",\"type\":\"string\"},\"mountPropagation\":{\"description\":\"mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.\",\"type\":\"string\"},\"name\":{\"description\":\"This must match the Name of a Volume.\",\"type\":\"string\"},\"readOnly\":{\"description\":\"Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.\",\"type\":\"boolean\"},\"subPath\":{\"description\":\"Path within the volume from which the container's volume should be mounted. Defaults to \\\"\\\" (volume's root).\",\"type\":\"string\"},\"subPathExpr\":{\"description\":\"Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \\\"\\\" (volume's root). SubPathExpr and SubPath are mutually exclusive.\",\"type\":\"string\"}},\"required\":[\"mountPath\",\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"workingDir\":{\"description\":\"Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"},\"timeout\":{\"description\":\"Timeout defines the maximum amount of time Velero should wait for the initContainers to complete.\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"includeClusterResources\":{\"description\":\"IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the restore. If null, defaults to true.\",\"nullable\":true,\"type\":\"boolean\"},\"includedNamespaces\":{\"description\":\"IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedResources\":{\"description\":\"IncludedResources is a slice of resource names to include in the restore. If empty, all resources in the backup are included.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"labelSelector\":{\"description\":\"LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.\",\"nullable\":true,\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaceMapping\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"NamespaceMapping is a map of source namespace names to target namespace names to restore into. Any source namespaces not included in the map will be restored into namespaces of the same name.\",\"type\":\"object\"},\"preserveNodePorts\":{\"description\":\"PreserveNodePorts specifies whether to restore old nodePorts from backup.\",\"nullable\":true,\"type\":\"boolean\"},\"restorePVs\":{\"description\":\"RestorePVs specifies whether to restore all included PVs from snapshot (via the cloudprovider).\",\"nullable\":true,\"type\":\"boolean\"},\"scheduleName\":{\"description\":\"ScheduleName is the unique name of the Velero schedule to restore from. If specified, and BackupName is empty, Velero will restore from the most recent successful backup created from this schedule.\",\"type\":\"string\"}},\"required\":[\"backupName\"],\"type\":\"object\"},\"status\":{\"description\":\"RestoreStatus captures the current status of a Velero restore\",\"properties\":{\"completionTimestamp\":{\"description\":\"CompletionTimestamp records the time the restore operation was completed. Completion time is recorded even on failed restore. The server's time is used for StartTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"errors\":{\"description\":\"Errors is a count of all error messages that were generated during execution of the restore. The actual errors are stored in object storage.\",\"type\":\"integer\"},\"failureReason\":{\"description\":\"FailureReason is an error that caused the entire restore to fail.\",\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current state of the Restore\",\"enum\":[\"New\",\"FailedValidation\",\"InProgress\",\"Completed\",\"PartiallyFailed\",\"Failed\"],\"type\":\"string\"},\"progress\":{\"description\":\"Progress contains information about the restore's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a restore for any reason, it may be inaccurate/stale.\",\"nullable\":true,\"properties\":{\"itemsRestored\":{\"description\":\"ItemsRestored is the number of items that have actually been restored so far\",\"type\":\"integer\"},\"totalItems\":{\"description\":\"TotalItems is the total number of items to be restored. This number may change throughout the execution of the restore due to plugins that return additional related items to restore\",\"type\":\"integer\"}},\"type\":\"object\"},\"startTimestamp\":{\"description\":\"StartTimestamp records the time the restore operation was started. The server's time is used for StartTimestamps\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"validationErrors\":{\"description\":\"ValidationErrors is a slice of all validation errors (if applicable)\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"warnings\":{\"description\":\"Warnings is a count of all warning messages that were generated during execution of the restore. The actual warnings are stored in object storage.\",\"type\":\"integer\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "restores",
          "singular": "restore",
          "kind": "Restore",
          "listKind": "RestoreList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "Restore is a Velero resource that represents the application of resources from a Velero backup to a target Kubernetes cluster.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "RestoreSpec defines the specification for a Velero restore.",
                    "type": "object",
                    "required": [
                      "backupName"
                    ],
                    "properties": {
                      "backupName": {
                        "description": "BackupName is the unique name of the Velero backup to restore from.",
                        "type": "string"
                      },
                      "excludedNamespaces": {
                        "description": "ExcludedNamespaces contains a list of namespaces that are not included in the restore.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "excludedResources": {
                        "description": "ExcludedResources is a slice of resource names that are not included in the restore.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "hooks": {
                        "description": "Hooks represent custom behaviors that should be executed during or post restore.",
                        "type": "object",
                        "properties": {
                          "resources": {
                            "type": "array",
                            "items": {
                              "description": "RestoreResourceHookSpec defines one or more RestoreResrouceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.",
                              "type": "object",
                              "required": [
                                "name"
                              ],
                              "properties": {
                                "excludedNamespaces": {
                                  "description": "ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "excludedResources": {
                                  "description": "ExcludedResources specifies the resources to which this hook spec does not apply.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "includedNamespaces": {
                                  "description": "IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "includedResources": {
                                  "description": "IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "nullable": true
                                },
                                "labelSelector": {
                                  "description": "LabelSelector, if specified, filters the resources to which this hook spec applies.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string"
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "nullable": true
                                },
                                "name": {
                                  "description": "Name is the name of this hook.",
                                  "type": "string"
                                },
                                "postHooks": {
                                  "description": "PostHooks is a list of RestoreResourceHooks to execute during and after restoring a resource.",
                                  "type": "array",
                                  "items": {
                                    "description": "RestoreResourceHook defines a restore hook for a resource.",
                                    "type": "object",
                                    "properties": {
                                      "exec": {
                                        "description": "Exec defines an exec restore hook.",
                                        "type": "object",
                                        "required": [
                                          "command"
                                        ],
                                        "properties": {
                                          "command": {
                                            "description": "Command is the command and arguments to execute from within a container after a pod has been restored.",
                                            "type": "array",
                                            "minItems": 1,
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "container": {
                                            "description": "Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.",
                                            "type": "string"
                                          },
                                          "execTimeout": {
                                            "description": "ExecTimeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.",
                                            "type": "string"
                                          },
                                          "onError": {
                                            "description": "OnError specifies how Velero should behave if it encounters an error executing this hook.",
                                            "type": "string",
                                            "enum": [
                                              "Continue",
                                              "Fail"
                                            ]
                                          },
                                          "waitTimeout": {
                                            "description": "WaitTimeout defines the maximum amount of time Velero should wait for the container to be Ready before attempting to run the command.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "init": {
                                        "description": "Init defines an init restore hook.",
                                        "type": "object",
                                        "properties": {
                                          "initContainers": {
                                            "description": "InitContainers is list of init containers to be added to a pod during its restore.",
                                            "type": "array",
                                            "items": {
                                              "description": "A single application container that you want to run within a pod.",
                                              "type": "object",
                                              "required": [
                                                "name"
                                              ],
                                              "properties": {
                                                "args": {
                                                  "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "command": {
                                                  "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "env": {
                                                  "description": "List of environment variables to set in the container. Cannot be updated.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "EnvVar represents an environment variable present in a Container.",
                                                    "type": "object",
                                                    "required": [
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "name": {
                                                        "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
                                                        "type": "string"
                                                      },
                                                      "value": {
                                                        "description": "Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".",
                                                        "type": "string"
                                                      },
                                                      "valueFrom": {
                                                        "description": "Source for the environment variable's value. Cannot be used if value is not empty.",
                                                        "type": "object",
                                                        "properties": {
                                                          "configMapKeyRef": {
                                                            "description": "Selects a key of a ConfigMap.",
                                                            "type": "object",
                                                            "required": [
                                                              "key"
                                                            ],
                                                            "properties": {
                                                              "key": {
                                                                "description": "The key to select.",
                                                                "type": "string"
                                                              },
                                                              "name": {
                                                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                                                "type": "string"
                                                              },
                                                              "optional": {
                                                                "description": "Specify whether the ConfigMap or its key must be defined",
                                                                "type": "boolean"
                                                              }
                                                            }
                                                          },
                                                          "fieldRef": {
                                                            "description": "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.",
                                                            "type": "object",
                                                            "required": [
                                                              "fieldPath"
                                                            ],
                                                            "properties": {
                                                              "apiVersion": {
                                                                "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                                                "type": "string"
                                                              },
                                                              "fieldPath": {
                                                                "description": "Path of the field to select in the specified API version.",
                                                                "type": "string"
                                                              }
                                                            }
                                                          },
                                                          "resourceFieldRef": {
                                                            "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.",
                                                            "type": "object",
                                                            "required": [
                                                              "resource"
                                                            ],
                                                            "properties": {
                                                              "containerName": {
                                                                "description": "Container name: required for volumes, optional for env vars",
                                                                "type": "string"
                                                              },
                                                              "divisor": {
                                                                "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                                                "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                                                "anyOf": [
                                                                  {
                                                                    "type": "integer"
                                                                  },
                                                                  {
                                                                    "type": "string"
                                                                  }
                                                                ],
                                                                "x-kubernetes-int-or-string": true
                                                              },
                                                              "resource": {
                                                                "description": "Required: resource to select",
                                                                "type": "string"
                                                              }
                                                            }
                                                          },
                                                          "secretKeyRef": {
                                                            "description": "Selects a key of a secret in the pod's namespace",
                                                            "type": "object",
                                                            "required": [
                                                              "key"
                                                            ],
                                                            "properties": {
                                                              "key": {
                                                                "description": "The key of the secret to select from.  Must be a valid secret key.",
                                                                "type": "string"
                                                              },
                                                              "name": {
                                                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                                                "type": "string"
                                                              },
                                                              "optional": {
                                                                "description": "Specify whether the Secret or its key must be defined",
                                                                "type": "boolean"
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                },
                                                "envFrom": {
                                                  "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "EnvFromSource represents the source of a set of ConfigMaps",
                                                    "type": "object",
                                                    "properties": {
                                                      "configMapRef": {
                                                        "description": "The ConfigMap to select from",
                                                        "type": "object",
                                                        "properties": {
                                                          "name": {
                                                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                                            "type": "string"
                                                          },
                                                          "optional": {
                                                            "description": "Specify whether the ConfigMap must be defined",
                                                            "type": "boolean"
                                                          }
                                                        }
                                                      },
                                                      "prefix": {
                                                        "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
                                                        "type": "string"
                                                      },
                                                      "secretRef": {
                                                        "description": "The Secret to select from",
                                                        "type": "object",
                                                        "properties": {
                                                          "name": {
                                                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                                            "type": "string"
                                                          },
                                                          "optional": {
                                                            "description": "Specify whether the Secret must be defined",
                                                            "type": "boolean"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                },
                                                "image": {
                                                  "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
                                                  "type": "string"
                                                },
                                                "imagePullPolicy": {
                                                  "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
                                                  "type": "string"
                                                },
                                                "lifecycle": {
                                                  "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
                                                  "type": "object",
                                                  "properties": {
                                                    "postStart": {
                                                      "description": "PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                                                      "type": "object",
                                                      "properties": {
                                                        "exec": {
                                                          "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                                          "type": "object",
                                                          "properties": {
                                                            "command": {
                                                              "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                                              "type": "array",
                                                              "items": {
                                                                "type": "string"
                                                              }
                                                            }
                                                          }
                                                        },
                                                        "httpGet": {
                                                          "description": "HTTPGet specifies the http request to perform.",
                                                          "type": "object",
                                                          "required": [
                                                            "port"
                                                          ],
                                                          "properties": {
                                                            "host": {
                                                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                                              "type": "string"
                                                            },
                                                            "httpHeaders": {
                                                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                                              "type": "array",
                                                              "items": {
                                                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                                                "type": "object",
                                                                "required": [
                                                                  "name",
                                                                  "value"
                                                                ],
                                                                "properties": {
                                                                  "name": {
                                                                    "description": "The header field name",
                                                                    "type": "string"
                                                                  },
                                                                  "value": {
                                                                    "description": "The header field value",
                                                                    "type": "string"
                                                                  }
                                                                }
                                                              }
                                                            },
                                                            "path": {
                                                              "description": "Path to access on the HTTP server.",
                                                              "type": "string"
                                                            },
                                                            "port": {
                                                              "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                              "anyOf": [
                                                                {
                                                                  "type": "integer"
                                                                },
                                                                {
                                                                  "type": "string"
                                                                }
                                                              ],
                                                              "x-kubernetes-int-or-string": true
                                                            },
                                                            "scheme": {
                                                              "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                                              "type": "string"
                                                            }
                                                          }
                                                        },
                                                        "tcpSocket": {
                                                          "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                                          "type": "object",
                                                          "required": [
                                                            "port"
                                                          ],
                                                          "properties": {
                                                            "host": {
                                                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                                              "type": "string"
                                                            },
                                                            "port": {
                                                              "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                              "anyOf": [
                                                                {
                                                                  "type": "integer"
                                                                },
                                                                {
                                                                  "type": "string"
                                                                }
                                                              ],
                                                              "x-kubernetes-int-or-string": true
                                                            }
                                                          }
                                                        }
                                                      }
                                                    },
                                                    "preStop": {
                                                      "description": "PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The reason for termination is passed to the handler. The Pod's termination grace period countdown begins before the PreStop hooked is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                                                      "type": "object",
                                                      "properties": {
                                                        "exec": {
                                                          "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                                          "type": "object",
                                                          "properties": {
                                                            "command": {
                                                              "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                                              "type": "array",
                                                              "items": {
                                                                "type": "string"
                                                              }
                                                            }
                                                          }
                                                        },
                                                        "httpGet": {
                                                          "description": "HTTPGet specifies the http request to perform.",
                                                          "type": "object",
                                                          "required": [
                                                            "port"
                                                          ],
                                                          "properties": {
                                                            "host": {
                                                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                                              "type": "string"
                                                            },
                                                            "httpHeaders": {
                                                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                                              "type": "array",
                                                              "items": {
                                                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                                                "type": "object",
                                                                "required": [
                                                                  "name",
                                                                  "value"
                                                                ],
                                                                "properties": {
                                                                  "name": {
                                                                    "description": "The header field name",
                                                                    "type": "string"
                                                                  },
                                                                  "value": {
                                                                    "description": "The header field value",
                                                                    "type": "string"
                                                                  }
                                                                }
                                                              }
                                                            },
                                                            "path": {
                                                              "description": "Path to access on the HTTP server.",
                                                              "type": "string"
                                                            },
                                                            "port": {
                                                              "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                              "anyOf": [
                                                                {
                                                                  "type": "integer"
                                                                },
                                                                {
                                                                  "type": "string"
                                                                }
                                                              ],
                                                              "x-kubernetes-int-or-string": true
                                                            },
                                                            "scheme": {
                                                              "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                                              "type": "string"
                                                            }
                                                          }
                                                        },
                                                        "tcpSocket": {
                                                          "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                                          "type": "object",
                                                          "required": [
                                                            "port"
                                                          ],
                                                          "properties": {
                                                            "host": {
                                                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                                              "type": "string"
                                                            },
                                                            "port": {
                                                              "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                              "anyOf": [
                                                                {
                                                                  "type": "integer"
                                                                },
                                                                {
                                                                  "type": "string"
                                                                }
                                                              ],
                                                              "x-kubernetes-int-or-string": true
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                },
                                                "livenessProbe": {
                                                  "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                  "type": "object",
                                                  "properties": {
                                                    "exec": {
                                                      "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                                      "type": "object",
                                                      "properties": {
                                                        "command": {
                                                          "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                                          "type": "array",
                                                          "items": {
                                                            "type": "string"
                                                          }
                                                        }
                                                      }
                                                    },
                                                    "failureThreshold": {
                                                      "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "httpGet": {
                                                      "description": "HTTPGet specifies the http request to perform.",
                                                      "type": "object",
                                                      "required": [
                                                        "port"
                                                      ],
                                                      "properties": {
                                                        "host": {
                                                          "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                                          "type": "string"
                                                        },
                                                        "httpHeaders": {
                                                          "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                                          "type": "array",
                                                          "items": {
                                                            "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                                            "type": "object",
                                                            "required": [
                                                              "name",
                                                              "value"
                                                            ],
                                                            "properties": {
                                                              "name": {
                                                                "description": "The header field name",
                                                                "type": "string"
                                                              },
                                                              "value": {
                                                                "description": "The header field value",
                                                                "type": "string"
                                                              }
                                                            }
                                                          }
                                                        },
                                                        "path": {
                                                          "description": "Path to access on the HTTP server.",
                                                          "type": "string"
                                                        },
                                                        "port": {
                                                          "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                          "anyOf": [
                                                            {
                                                              "type": "integer"
                                                            },
                                                            {
                                                              "type": "string"
                                                            }
                                                          ],
                                                          "x-kubernetes-int-or-string": true
                                                        },
                                                        "scheme": {
                                                          "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "initialDelaySeconds": {
                                                      "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "periodSeconds": {
                                                      "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "successThreshold": {
                                                      "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "tcpSocket": {
                                                      "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                                      "type": "object",
                                                      "required": [
                                                        "port"
                                                      ],
                                                      "properties": {
                                                        "host": {
                                                          "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                                          "type": "string"
                                                        },
                                                        "port": {
                                                          "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                          "anyOf": [
                                                            {
                                                              "type": "integer"
                                                            },
                                                            {
                                                              "type": "string"
                                                            }
                                                          ],
                                                          "x-kubernetes-int-or-string": true
                                                        }
                                                      }
                                                    },
                                                    "terminationGracePeriodSeconds": {
                                                      "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
                                                      "type": "integer",
                                                      "format": "int64"
                                                    },
                                                    "timeoutSeconds": {
                                                      "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    }
                                                  }
                                                },
                                                "name": {
                                                  "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                                                  "type": "string"
                                                },
                                                "ports": {
                                                  "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"***HIDDEN***\" address inside a container will be accessible from the network. Cannot be updated.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "ContainerPort represents a network port in a single container.",
                                                    "type": "object",
                                                    "required": [
                                                      "containerPort",
                                                      "protocol"
                                                    ],
                                                    "properties": {
                                                      "containerPort": {
                                                        "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 \u003c x \u003c 65536.",
                                                        "type": "integer",
                                                        "format": "int32"
                                                      },
                                                      "hostIP": {
                                                        "description": "What host IP to bind the external port to.",
                                                        "type": "string"
                                                      },
                                                      "hostPort": {
                                                        "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 \u003c x \u003c 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
                                                        "type": "integer",
                                                        "format": "int32"
                                                      },
                                                      "name": {
                                                        "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
                                                        "type": "string"
                                                      },
                                                      "protocol": {
                                                        "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "x-kubernetes-list-map-keys": [
                                                    "containerPort",
                                                    "protocol"
                                                  ],
                                                  "x-kubernetes-list-type": "map"
                                                },
                                                "readinessProbe": {
                                                  "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                  "type": "object",
                                                  "properties": {
                                                    "exec": {
                                                      "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                                      "type": "object",
                                                      "properties": {
                                                        "command": {
                                                          "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                                          "type": "array",
                                                          "items": {
                                                            "type": "string"
                                                          }
                                                        }
                                                      }
                                                    },
                                                    "failureThreshold": {
                                                      "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "httpGet": {
                                                      "description": "HTTPGet specifies the http request to perform.",
                                                      "type": "object",
                                                      "required": [
                                                        "port"
                                                      ],
                                                      "properties": {
                                                        "host": {
                                                          "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                                          "type": "string"
                                                        },
                                                        "httpHeaders": {
                                                          "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                                          "type": "array",
                                                          "items": {
                                                            "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                                            "type": "object",
                                                            "required": [
                                                              "name",
                                                              "value"
                                                            ],
                                                            "properties": {
                                                              "name": {
                                                                "description": "The header field name",
                                                                "type": "string"
                                                              },
                                                              "value": {
                                                                "description": "The header field value",
                                                                "type": "string"
                                                              }
                                                            }
                                                          }
                                                        },
                                                        "path": {
                                                          "description": "Path to access on the HTTP server.",
                                                          "type": "string"
                                                        },
                                                        "port": {
                                                          "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                          "anyOf": [
                                                            {
                                                              "type": "integer"
                                                            },
                                                            {
                                                              "type": "string"
                                                            }
                                                          ],
                                                          "x-kubernetes-int-or-string": true
                                                        },
                                                        "scheme": {
                                                          "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "initialDelaySeconds": {
                                                      "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "periodSeconds": {
                                                      "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "successThreshold": {
                                                      "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "tcpSocket": {
                                                      "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                                      "type": "object",
                                                      "required": [
                                                        "port"
                                                      ],
                                                      "properties": {
                                                        "host": {
                                                          "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                                          "type": "string"
                                                        },
                                                        "port": {
                                                          "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                          "anyOf": [
                                                            {
                                                              "type": "integer"
                                                            },
                                                            {
                                                              "type": "string"
                                                            }
                                                          ],
                                                          "x-kubernetes-int-or-string": true
                                                        }
                                                      }
                                                    },
                                                    "terminationGracePeriodSeconds": {
                                                      "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
                                                      "type": "integer",
                                                      "format": "int64"
                                                    },
                                                    "timeoutSeconds": {
                                                      "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    }
                                                  }
                                                },
                                                "resources": {
                                                  "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                                                  "type": "object",
                                                  "properties": {
                                                    "limits": {
                                                      "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                                                      "type": "object",
                                                      "additionalProperties": {
                                                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                                        "anyOf": [
                                                          {
                                                            "type": "integer"
                                                          },
                                                          {
                                                            "type": "string"
                                                          }
                                                        ],
                                                        "x-kubernetes-int-or-string": true
                                                      }
                                                    },
                                                    "requests": {
                                                      "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                                                      "type": "object",
                                                      "additionalProperties": {
                                                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                                        "anyOf": [
                                                          {
                                                            "type": "integer"
                                                          },
                                                          {
                                                            "type": "string"
                                                          }
                                                        ],
                                                        "x-kubernetes-int-or-string": true
                                                      }
                                                    }
                                                  }
                                                },
                                                "securityContext": {
                                                  "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
                                                  "type": "object",
                                                  "properties": {
                                                    "allowPrivilegeEscalation": {
                                                      "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
                                                      "type": "boolean"
                                                    },
                                                    "capabilities": {
                                                      "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.",
                                                      "type": "object",
                                                      "properties": {
                                                        "add": {
                                                          "description": "Added capabilities",
                                                          "type": "array",
                                                          "items": {
                                                            "description": "Capability represent POSIX capabilities type",
                                                            "type": "string"
                                                          }
                                                        },
                                                        "drop": {
                                                          "description": "Removed capabilities",
                                                          "type": "array",
                                                          "items": {
                                                            "description": "Capability represent POSIX capabilities type",
                                                            "type": "string"
                                                          }
                                                        }
                                                      }
                                                    },
                                                    "privileged": {
                                                      "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
                                                      "type": "boolean"
                                                    },
                                                    "procMount": {
                                                      "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
                                                      "type": "string"
                                                    },
                                                    "readOnlyRootFilesystem": {
                                                      "description": "Whether this container has a read-only root filesystem. Default is false.",
                                                      "type": "boolean"
                                                    },
                                                    "runAsGroup": {
                                                      "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                                                      "type": "integer",
                                                      "format": "int64"
                                                    },
                                                    "runAsNonRoot": {
                                                      "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                                                      "type": "boolean"
                                                    },
                                                    "runAsUser": {
                                                      "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                                                      "type": "integer",
                                                      "format": "int64"
                                                    },
                                                    "seLinuxOptions": {
                                                      "description": "The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                                                      "type": "object",
                                                      "properties": {
                                                        "level": {
                                                          "description": "Level is SELinux level label that applies to the container.",
                                                          "type": "string"
                                                        },
                                                        "role": {
                                                          "description": "Role is a SELinux role label that applies to the container.",
                                                          "type": "string"
                                                        },
                                                        "type": {
                                                          "description": "Type is a SELinux type label that applies to the container.",
                                                          "type": "string"
                                                        },
                                                        "user": {
                                                          "description": "User is a SELinux user label that applies to the container.",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "seccompProfile": {
                                                      "description": "The seccomp options to use by this container. If seccomp options are provided at both the pod \u0026 container level, the container options override the pod options.",
                                                      "type": "object",
                                                      "required": [
                                                        "type"
                                                      ],
                                                      "properties": {
                                                        "localhostProfile": {
                                                          "description": "localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is \"Localhost\".",
                                                          "type": "string"
                                                        },
                                                        "type": {
                                                          "description": "type indicates which kind of seccomp profile will be applied. Valid options are: \n Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "windowsOptions": {
                                                      "description": "The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                                                      "type": "object",
                                                      "properties": {
                                                        "gmsaCredentialSpec": {
                                                          "description": "GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.",
                                                          "type": "string"
                                                        },
                                                        "gmsaCredentialSpecName": {
                                                          "description": "GMSACredentialSpecName is the name of the GMSA credential spec to use.",
                                                          "type": "string"
                                                        },
                                                        "hostProcess": {
                                                          "description": "HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.",
                                                          "type": "boolean"
                                                        },
                                                        "runAsUserName": {
                                                          "description": "The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                                                          "type": "string"
                                                        }
                                                      }
                                                    }
                                                  }
                                                },
                                                "startupProbe": {
                                                  "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                  "type": "object",
                                                  "properties": {
                                                    "exec": {
                                                      "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                                      "type": "object",
                                                      "properties": {
                                                        "command": {
                                                          "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                                          "type": "array",
                                                          "items": {
                                                            "type": "string"
                                                          }
                                                        }
                                                      }
                                                    },
                                                    "failureThreshold": {
                                                      "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "httpGet": {
                                                      "description": "HTTPGet specifies the http request to perform.",
                                                      "type": "object",
                                                      "required": [
                                                        "port"
                                                      ],
                                                      "properties": {
                                                        "host": {
                                                          "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                                          "type": "string"
                                                        },
                                                        "httpHeaders": {
                                                          "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                                          "type": "array",
                                                          "items": {
                                                            "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                                            "type": "object",
                                                            "required": [
                                                              "name",
                                                              "value"
                                                            ],
                                                            "properties": {
                                                              "name": {
                                                                "description": "The header field name",
                                                                "type": "string"
                                                              },
                                                              "value": {
                                                                "description": "The header field value",
                                                                "type": "string"
                                                              }
                                                            }
                                                          }
                                                        },
                                                        "path": {
                                                          "description": "Path to access on the HTTP server.",
                                                          "type": "string"
                                                        },
                                                        "port": {
                                                          "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                          "anyOf": [
                                                            {
                                                              "type": "integer"
                                                            },
                                                            {
                                                              "type": "string"
                                                            }
                                                          ],
                                                          "x-kubernetes-int-or-string": true
                                                        },
                                                        "scheme": {
                                                          "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "initialDelaySeconds": {
                                                      "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "periodSeconds": {
                                                      "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "successThreshold": {
                                                      "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    },
                                                    "tcpSocket": {
                                                      "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                                      "type": "object",
                                                      "required": [
                                                        "port"
                                                      ],
                                                      "properties": {
                                                        "host": {
                                                          "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                                          "type": "string"
                                                        },
                                                        "port": {
                                                          "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                                          "anyOf": [
                                                            {
                                                              "type": "integer"
                                                            },
                                                            {
                                                              "type": "string"
                                                            }
                                                          ],
                                                          "x-kubernetes-int-or-string": true
                                                        }
                                                      }
                                                    },
                                                    "terminationGracePeriodSeconds": {
                                                      "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
                                                      "type": "integer",
                                                      "format": "int64"
                                                    },
                                                    "timeoutSeconds": {
                                                      "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                                                      "type": "integer",
                                                      "format": "int32"
                                                    }
                                                  }
                                                },
                                                "stdin": {
                                                  "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
                                                  "type": "boolean"
                                                },
                                                "stdinOnce": {
                                                  "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
                                                  "type": "boolean"
                                                },
                                                "terminationMessagePath": {
                                                  "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
                                                  "type": "string"
                                                },
                                                "terminationMessagePolicy": {
                                                  "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
                                                  "type": "string"
                                                },
                                                "tty": {
                                                  "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
                                                  "type": "boolean"
                                                },
                                                "volumeDevices": {
                                                  "description": "volumeDevices is the list of block devices to be used by the container.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "volumeDevice describes a mapping of a raw block device within a container.",
                                                    "type": "object",
                                                    "required": [
                                                      "devicePath",
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "devicePath": {
                                                        "description": "devicePath is the path inside of the container that the device will be mapped to.",
                                                        "type": "string"
                                                      },
                                                      "name": {
                                                        "description": "name must match the name of a persistentVolumeClaim in the pod",
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                },
                                                "volumeMounts": {
                                                  "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "VolumeMount describes a mounting of a Volume within a container.",
                                                    "type": "object",
                                                    "required": [
                                                      "mountPath",
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "mountPath": {
                                                        "description": "Path within the container at which the volume should be mounted.  Must not contain ':'.",
                                                        "type": "string"
                                                      },
                                                      "mountPropagation": {
                                                        "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
                                                        "type": "string"
                                                      },
                                                      "name": {
                                                        "description": "This must match the Name of a Volume.",
                                                        "type": "string"
                                                      },
                                                      "readOnly": {
                                                        "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
                                                        "type": "boolean"
                                                      },
                                                      "subPath": {
                                                        "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
                                                        "type": "string"
                                                      },
                                                      "subPathExpr": {
                                                        "description": "Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root). SubPathExpr and SubPath are mutually exclusive.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                },
                                                "workingDir": {
                                                  "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          },
                                          "timeout": {
                                            "description": "Timeout defines the maximum amount of time Velero should wait for the initContainers to complete.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "includeClusterResources": {
                        "description": "IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the restore. If null, defaults to true.",
                        "type": "boolean",
                        "nullable": true
                      },
                      "includedNamespaces": {
                        "description": "IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "includedResources": {
                        "description": "IncludedResources is a slice of resource names to include in the restore. If empty, all resources in the backup are included.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "labelSelector": {
                        "description": "LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        },
                        "nullable": true
                      },
                      "namespaceMapping": {
                        "description": "NamespaceMapping is a map of source namespace names to target namespace names to restore into. Any source namespaces not included in the map will be restored into namespaces of the same name.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "preserveNodePorts": {
                        "description": "PreserveNodePorts specifies whether to restore old nodePorts from backup.",
                        "type": "boolean",
                        "nullable": true
                      },
                      "restorePVs": {
                        "description": "RestorePVs specifies whether to restore all included PVs from snapshot (via the cloudprovider).",
                        "type": "boolean",
                        "nullable": true
                      },
                      "scheduleName": {
                        "description": "ScheduleName is the unique name of the Velero schedule to restore from. If specified, and BackupName is empty, Velero will restore from the most recent successful backup created from this schedule.",
                        "type": "string"
                      }
                    }
                  },
                  "status": {
                    "description": "RestoreStatus captures the current status of a Velero restore",
                    "type": "object",
                    "properties": {
                      "completionTimestamp": {
                        "description": "CompletionTimestamp records the time the restore operation was completed. Completion time is recorded even on failed restore. The server's time is used for StartTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "errors": {
                        "description": "Errors is a count of all error messages that were generated during execution of the restore. The actual errors are stored in object storage.",
                        "type": "integer"
                      },
                      "failureReason": {
                        "description": "FailureReason is an error that caused the entire restore to fail.",
                        "type": "string"
                      },
                      "phase": {
                        "description": "Phase is the current state of the Restore",
                        "type": "string",
                        "enum": [
                          "New",
                          "FailedValidation",
                          "InProgress",
                          "Completed",
                          "PartiallyFailed",
                          "Failed"
                        ]
                      },
                      "progress": {
                        "description": "Progress contains information about the restore's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a restore for any reason, it may be inaccurate/stale.",
                        "type": "object",
                        "properties": {
                          "itemsRestored": {
                            "description": "ItemsRestored is the number of items that have actually been restored so far",
                            "type": "integer"
                          },
                          "totalItems": {
                            "description": "TotalItems is the total number of items to be restored. This number may change throughout the execution of the restore due to plugins that return additional related items to restore",
                            "type": "integer"
                          }
                        },
                        "nullable": true
                      },
                      "startTimestamp": {
                        "description": "StartTimestamp records the time the restore operation was started. The server's time is used for StartTimestamps",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "validationErrors": {
                        "description": "ValidationErrors is a slice of all validation errors (if applicable)",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "nullable": true
                      },
                      "warnings": {
                        "description": "Warnings is a count of all warning messages that were generated during execution of the restore. The actual warnings are stored in object storage.",
                        "type": "integer"
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "restores",
          "singular": "restore",
          "kind": "Restore",
          "listKind": "RestoreList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "schedules.velero.io",
        "uid": "97c442aa-14ca-4e64-8795-5e0972c2da13",
        "resourceVersion": "1849",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"schedules.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"Schedule\",\"listKind\":\"ScheduleList\",\"plural\":\"schedules\",\"singular\":\"schedule\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"Schedule is a Velero resource that represents a pre-scheduled or periodic Backup that should be run.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"ScheduleSpec defines the specification for a Velero schedule\",\"properties\":{\"schedule\":{\"description\":\"Schedule is a Cron expression defining when to run the Backup.\",\"type\":\"string\"},\"template\":{\"description\":\"Template is the definition of the Backup to be run on the provided schedule\",\"properties\":{\"defaultVolumesToRestic\":{\"description\":\"DefaultVolumesToRestic specifies whether restic should be used to take a backup of all pod volumes by default.\",\"type\":\"boolean\"},\"excludedNamespaces\":{\"description\":\"ExcludedNamespaces contains a list of namespaces that are not included in the backup.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"excludedResources\":{\"description\":\"ExcludedResources is a slice of resource names that are not included in the backup.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"hooks\":{\"description\":\"Hooks represent custom behaviors that should be executed at different phases of the backup.\",\"properties\":{\"resources\":{\"description\":\"Resources are hooks that should be executed when backing up individual instances of a resource.\",\"items\":{\"description\":\"BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.\",\"properties\":{\"excludedNamespaces\":{\"description\":\"ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"excludedResources\":{\"description\":\"ExcludedResources specifies the resources to which this hook spec does not apply.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedNamespaces\":{\"description\":\"IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedResources\":{\"description\":\"IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"labelSelector\":{\"description\":\"LabelSelector, if specified, filters the resources to which this hook spec applies.\",\"nullable\":true,\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"name\":{\"description\":\"Name is the name of this hook.\",\"type\":\"string\"},\"post\":{\"description\":\"PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all \\\"additional items\\\" from item actions are processed.\",\"items\":{\"description\":\"BackupResourceHook defines a hook for a resource.\",\"properties\":{\"exec\":{\"description\":\"Exec defines an exec hook.\",\"properties\":{\"command\":{\"description\":\"Command is the command and arguments to execute.\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"container\":{\"description\":\"Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.\",\"type\":\"string\"},\"onError\":{\"description\":\"OnError specifies how Velero should behave if it encounters an error executing this hook.\",\"enum\":[\"Continue\",\"Fail\"],\"type\":\"string\"},\"timeout\":{\"description\":\"Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.\",\"type\":\"string\"}},\"required\":[\"command\"],\"type\":\"object\"}},\"required\":[\"exec\"],\"type\":\"object\"},\"type\":\"array\"},\"pre\":{\"description\":\"PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any \\\"additional items\\\" from item actions are processed.\",\"items\":{\"description\":\"BackupResourceHook defines a hook for a resource.\",\"properties\":{\"exec\":{\"description\":\"Exec defines an exec hook.\",\"properties\":{\"command\":{\"description\":\"Command is the command and arguments to execute.\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"container\":{\"description\":\"Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.\",\"type\":\"string\"},\"onError\":{\"description\":\"OnError specifies how Velero should behave if it encounters an error executing this hook.\",\"enum\":[\"Continue\",\"Fail\"],\"type\":\"string\"},\"timeout\":{\"description\":\"Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.\",\"type\":\"string\"}},\"required\":[\"command\"],\"type\":\"object\"}},\"required\":[\"exec\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"name\"],\"type\":\"object\"},\"nullable\":true,\"type\":\"array\"}},\"type\":\"object\"},\"includeClusterResources\":{\"description\":\"IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.\",\"nullable\":true,\"type\":\"boolean\"},\"includedNamespaces\":{\"description\":\"IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"includedResources\":{\"description\":\"IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"type\":\"array\"},\"labelSelector\":{\"description\":\"LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.\",\"nullable\":true,\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"metadata\":{\"properties\":{\"labels\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"},\"orderedResources\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"OrderedResources specifies the backup order of resources of specific Kind. The map key is the Kind name and value is a list of resource names separated by commas. Each resource name has format \\\"namespace/resourcename\\\".  For cluster resources, simply use \\\"resourcename\\\".\",\"nullable\":true,\"type\":\"object\"},\"snapshotVolumes\":{\"description\":\"SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.\",\"nullable\":true,\"type\":\"boolean\"},\"storageLocation\":{\"description\":\"StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.\",\"type\":\"string\"},\"ttl\":{\"description\":\"TTL is a time.Duration-parseable string describing how long the Backup should be retained for.\",\"type\":\"string\"},\"volumeSnapshotLocations\":{\"description\":\"VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"useOwnerReferencesInBackup\":{\"description\":\"UseOwnerReferencesBackup specifies whether to use OwnerReferences on backups created by this Schedule.\",\"nullable\":true,\"type\":\"boolean\"}},\"required\":[\"schedule\",\"template\"],\"type\":\"object\"},\"status\":{\"description\":\"ScheduleStatus captures the current state of a Velero schedule\",\"properties\":{\"lastBackup\":{\"description\":\"LastBackup is the last time a Backup was run for this Schedule schedule\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"phase\":{\"description\":\"Phase is the current phase of the Schedule\",\"enum\":[\"New\",\"Enabled\",\"FailedValidation\"],\"type\":\"string\"},\"validationErrors\":{\"description\":\"ValidationErrors is a slice of all validation errors (if applicable)\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "schedules",
          "singular": "schedule",
          "kind": "Schedule",
          "listKind": "ScheduleList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "Schedule is a Velero resource that represents a pre-scheduled or periodic Backup that should be run.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "ScheduleSpec defines the specification for a Velero schedule",
                    "type": "object",
                    "required": [
                      "schedule",
                      "template"
                    ],
                    "properties": {
                      "schedule": {
                        "description": "Schedule is a Cron expression defining when to run the Backup.",
                        "type": "string"
                      },
                      "template": {
                        "description": "Template is the definition of the Backup to be run on the provided schedule",
                        "type": "object",
                        "properties": {
                          "defaultVolumesToRestic": {
                            "description": "DefaultVolumesToRestic specifies whether restic should be used to take a backup of all pod volumes by default.",
                            "type": "boolean"
                          },
                          "excludedNamespaces": {
                            "description": "ExcludedNamespaces contains a list of namespaces that are not included in the backup.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "nullable": true
                          },
                          "excludedResources": {
                            "description": "ExcludedResources is a slice of resource names that are not included in the backup.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "nullable": true
                          },
                          "hooks": {
                            "description": "Hooks represent custom behaviors that should be executed at different phases of the backup.",
                            "type": "object",
                            "properties": {
                              "resources": {
                                "description": "Resources are hooks that should be executed when backing up individual instances of a resource.",
                                "type": "array",
                                "items": {
                                  "description": "BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "excludedNamespaces": {
                                      "description": "ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "nullable": true
                                    },
                                    "excludedResources": {
                                      "description": "ExcludedResources specifies the resources to which this hook spec does not apply.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "nullable": true
                                    },
                                    "includedNamespaces": {
                                      "description": "IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "nullable": true
                                    },
                                    "includedResources": {
                                      "description": "IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "nullable": true
                                    },
                                    "labelSelector": {
                                      "description": "LabelSelector, if specified, filters the resources to which this hook spec applies.",
                                      "type": "object",
                                      "properties": {
                                        "matchExpressions": {
                                          "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                          "type": "array",
                                          "items": {
                                            "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                            "type": "object",
                                            "required": [
                                              "key",
                                              "operator"
                                            ],
                                            "properties": {
                                              "key": {
                                                "description": "key is the label key that the selector applies to.",
                                                "type": "string"
                                              },
                                              "operator": {
                                                "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                "type": "string"
                                              },
                                              "values": {
                                                "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "matchLabels": {
                                          "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "nullable": true
                                    },
                                    "name": {
                                      "description": "Name is the name of this hook.",
                                      "type": "string"
                                    },
                                    "post": {
                                      "description": "PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all \"additional items\" from item actions are processed.",
                                      "type": "array",
                                      "items": {
                                        "description": "BackupResourceHook defines a hook for a resource.",
                                        "type": "object",
                                        "required": [
                                          "exec"
                                        ],
                                        "properties": {
                                          "exec": {
                                            "description": "Exec defines an exec hook.",
                                            "type": "object",
                                            "required": [
                                              "command"
                                            ],
                                            "properties": {
                                              "command": {
                                                "description": "Command is the command and arguments to execute.",
                                                "type": "array",
                                                "minItems": 1,
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "container": {
                                                "description": "Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.",
                                                "type": "string"
                                              },
                                              "onError": {
                                                "description": "OnError specifies how Velero should behave if it encounters an error executing this hook.",
                                                "type": "string",
                                                "enum": [
                                                  "Continue",
                                                  "Fail"
                                                ]
                                              },
                                              "timeout": {
                                                "description": "Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "pre": {
                                      "description": "PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any \"additional items\" from item actions are processed.",
                                      "type": "array",
                                      "items": {
                                        "description": "BackupResourceHook defines a hook for a resource.",
                                        "type": "object",
                                        "required": [
                                          "exec"
                                        ],
                                        "properties": {
                                          "exec": {
                                            "description": "Exec defines an exec hook.",
                                            "type": "object",
                                            "required": [
                                              "command"
                                            ],
                                            "properties": {
                                              "command": {
                                                "description": "Command is the command and arguments to execute.",
                                                "type": "array",
                                                "minItems": 1,
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "container": {
                                                "description": "Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.",
                                                "type": "string"
                                              },
                                              "onError": {
                                                "description": "OnError specifies how Velero should behave if it encounters an error executing this hook.",
                                                "type": "string",
                                                "enum": [
                                                  "Continue",
                                                  "Fail"
                                                ]
                                              },
                                              "timeout": {
                                                "description": "Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "nullable": true
                              }
                            }
                          },
                          "includeClusterResources": {
                            "description": "IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.",
                            "type": "boolean",
                            "nullable": true
                          },
                          "includedNamespaces": {
                            "description": "IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "nullable": true
                          },
                          "includedResources": {
                            "description": "IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "nullable": true
                          },
                          "labelSelector": {
                            "description": "LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            },
                            "nullable": true
                          },
                          "metadata": {
                            "type": "object",
                            "properties": {
                              "labels": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "orderedResources": {
                            "description": "OrderedResources specifies the backup order of resources of specific Kind. The map key is the Kind name and value is a list of resource names separated by commas. Each resource name has format \"namespace/resourcename\".  For cluster resources, simply use \"resourcename\".",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            },
                            "nullable": true
                          },
                          "snapshotVolumes": {
                            "description": "SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.",
                            "type": "boolean",
                            "nullable": true
                          },
                          "storageLocation": {
                            "description": "StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.",
                            "type": "string"
                          },
                          "ttl": {
                            "description": "TTL is a time.Duration-parseable string describing how long the Backup should be retained for.",
                            "type": "string"
                          },
                          "volumeSnapshotLocations": {
                            "description": "VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "useOwnerReferencesInBackup": {
                        "description": "UseOwnerReferencesBackup specifies whether to use OwnerReferences on backups created by this Schedule.",
                        "type": "boolean",
                        "nullable": true
                      }
                    }
                  },
                  "status": {
                    "description": "ScheduleStatus captures the current state of a Velero schedule",
                    "type": "object",
                    "properties": {
                      "lastBackup": {
                        "description": "LastBackup is the last time a Backup was run for this Schedule schedule",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "phase": {
                        "description": "Phase is the current phase of the Schedule",
                        "type": "string",
                        "enum": [
                          "New",
                          "Enabled",
                          "FailedValidation"
                        ]
                      },
                      "validationErrors": {
                        "description": "ValidationErrors is a slice of all validation errors (if applicable)",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "schedules",
          "singular": "schedule",
          "kind": "Schedule",
          "listKind": "ScheduleList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "serverstatusrequests.velero.io",
        "uid": "a2c6f99d-6115-429d-b87c-2474a3f03e01",
        "resourceVersion": "1850",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"serverstatusrequests.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"ServerStatusRequest\",\"listKind\":\"ServerStatusRequestList\",\"plural\":\"serverstatusrequests\",\"shortNames\":[\"ssr\"],\"singular\":\"serverstatusrequest\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"ServerStatusRequest is a request to access current status information about the Velero server.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"ServerStatusRequestSpec is the specification for a ServerStatusRequest.\",\"type\":\"object\"},\"status\":{\"description\":\"ServerStatusRequestStatus is the current status of a ServerStatusRequest.\",\"properties\":{\"phase\":{\"description\":\"Phase is the current lifecycle phase of the ServerStatusRequest.\",\"enum\":[\"New\",\"Processed\"],\"type\":\"string\"},\"plugins\":{\"description\":\"Plugins list information about the plugins running on the Velero server\",\"items\":{\"description\":\"PluginInfo contains attributes of a Velero plugin\",\"properties\":{\"kind\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"}},\"required\":[\"kind\",\"name\"],\"type\":\"object\"},\"nullable\":true,\"type\":\"array\"},\"processedTimestamp\":{\"description\":\"ProcessedTimestamp is when the ServerStatusRequest was processed by the ServerStatusRequestController.\",\"format\":\"date-time\",\"nullable\":true,\"type\":\"string\"},\"serverVersion\":{\"description\":\"ServerVersion is the Velero server version.\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "serverstatusrequests",
          "singular": "serverstatusrequest",
          "shortNames": [
            "ssr"
          ],
          "kind": "ServerStatusRequest",
          "listKind": "ServerStatusRequestList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "ServerStatusRequest is a request to access current status information about the Velero server.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "ServerStatusRequestSpec is the specification for a ServerStatusRequest.",
                    "type": "object"
                  },
                  "status": {
                    "description": "ServerStatusRequestStatus is the current status of a ServerStatusRequest.",
                    "type": "object",
                    "properties": {
                      "phase": {
                        "description": "Phase is the current lifecycle phase of the ServerStatusRequest.",
                        "type": "string",
                        "enum": [
                          "New",
                          "Processed"
                        ]
                      },
                      "plugins": {
                        "description": "Plugins list information about the plugins running on the Velero server",
                        "type": "array",
                        "items": {
                          "description": "PluginInfo contains attributes of a Velero plugin",
                          "type": "object",
                          "required": [
                            "kind",
                            "name"
                          ],
                          "properties": {
                            "kind": {
                              "type": "string"
                            },
                            "name": {
                              "type": "string"
                            }
                          }
                        },
                        "nullable": true
                      },
                      "processedTimestamp": {
                        "description": "ProcessedTimestamp is when the ServerStatusRequest was processed by the ServerStatusRequestController.",
                        "type": "string",
                        "format": "date-time",
                        "nullable": true
                      },
                      "serverVersion": {
                        "description": "ServerVersion is the Velero server version.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "serverstatusrequests",
          "singular": "serverstatusrequest",
          "shortNames": [
            "ssr"
          ],
          "kind": "ServerStatusRequest",
          "listKind": "ServerStatusRequestList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "settings.longhorn.io",
        "uid": "1fbc639d-269b-4ef0-b663-57b4eac95984",
        "resourceVersion": "822",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "Setting"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"Setting\"},\"name\":\"settings.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"Setting\",\"listKind\":\"SettingList\",\"plural\":\"settings\",\"shortNames\":[\"lhs\"],\"singular\":\"setting\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The value of the setting\",\"jsonPath\":\".value\",\"name\":\"Value\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "settings",
          "singular": "setting",
          "shortNames": [
            "lhs"
          ],
          "kind": "Setting",
          "listKind": "SettingList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "x-kubernetes-preserve-unknown-fields": true
              }
            },
            "additionalPrinterColumns": [
              {
                "name": "Value",
                "type": "string",
                "description": "The value of the setting",
                "jsonPath": ".value"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "settings",
          "singular": "setting",
          "shortNames": [
            "lhs"
          ],
          "kind": "Setting",
          "listKind": "SettingList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "sharemanagers.longhorn.io",
        "uid": "858487a3-5120-4be9-b062-9dbfe439ea2f",
        "resourceVersion": "838",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "ShareManager"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"ShareManager\"},\"name\":\"sharemanagers.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"ShareManager\",\"listKind\":\"ShareManagerList\",\"plural\":\"sharemanagers\",\"shortNames\":[\"lhsm\"],\"singular\":\"sharemanager\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The state of the share manager\",\"jsonPath\":\".status.state\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The node that the share manager is owned by\",\"jsonPath\":\".status.ownerID\",\"name\":\"Node\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "sharemanagers",
          "singular": "sharemanager",
          "shortNames": [
            "lhsm"
          ],
          "kind": "ShareManager",
          "listKind": "ShareManagerList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The state of the share manager",
                "jsonPath": ".status.state"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node that the share manager is owned by",
                "jsonPath": ".status.ownerID"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "sharemanagers",
          "singular": "sharemanager",
          "shortNames": [
            "lhsm"
          ],
          "kind": "ShareManager",
          "listKind": "ShareManagerList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "tlscertificatedelegations.projectcontour.io",
        "uid": "7b5e0907-540b-4605-86fe-28a403c35ef2",
        "resourceVersion": "1539",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:42Z",
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.6.2",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.6.2\"},\"creationTimestamp\":null,\"name\":\"tlscertificatedelegations.projectcontour.io\"},\"spec\":{\"group\":\"projectcontour.io\",\"names\":{\"kind\":\"TLSCertificateDelegation\",\"listKind\":\"TLSCertificateDelegationList\",\"plural\":\"tlscertificatedelegations\",\"shortNames\":[\"tlscerts\"],\"singular\":\"tlscertificatedelegation\"},\"preserveUnknownFields\":false,\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"TLSCertificateDelegation is an TLS Certificate Delegation CRD specification. See design/tls-certificate-delegation.md for details.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"TLSCertificateDelegationSpec defines the spec of the CRD\",\"properties\":{\"delegations\":{\"items\":{\"description\":\"CertificateDelegation maps the authority to reference a secret in the current namespace to a set of namespaces.\",\"properties\":{\"secretName\":{\"description\":\"required, the name of a secret in the current namespace.\",\"type\":\"string\"},\"targetNamespaces\":{\"description\":\"required, the namespaces the authority to reference the the secret will be delegated to. If TargetNamespaces is nil or empty, the CertificateDelegation' is ignored. If the TargetNamespace list contains the character, \\\"*\\\" the secret will be delegated to all namespaces.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"secretName\",\"targetNamespaces\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"delegations\"],\"type\":\"object\"},\"status\":{\"description\":\"TLSCertificateDelegationStatus allows for the status of the delegation to be presented to the user.\",\"properties\":{\"conditions\":{\"description\":\"Conditions contains information about the current status of the HTTPProxy, in an upstream-friendly container. \\n Contour will update a single condition, `Valid`, that is in normal-true polarity. That is, when `currentStatus` is `valid`, the `Valid` condition will be `status: true`, and vice versa. \\n Contour will leave untouched any other Conditions set in this block, in case some other controller wants to add a Condition. \\n If you are another controller owner and wish to add a condition, you *should* namespace your condition with a label, like `controller.domain.com\\\\ConditionName`.\",\"items\":{\"description\":\"DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \\n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \\n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \\n Remember that Conditions have a type, a status, and a reason. \\n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \\n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \\n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \\n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \\n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.\",\"properties\":{\"errors\":{\"description\":\"Errors contains a slice of relevant error subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"lastTransitionTime\":{\"description\":\"lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.\",\"format\":\"date-time\",\"type\":\"string\"},\"message\":{\"description\":\"message is a human readable message indicating details about the transition. This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"observedGeneration\":{\"description\":\"observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.\",\"format\":\"int64\",\"minimum\":0,\"type\":\"integer\"},\"reason\":{\"description\":\"reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"},\"warnings\":{\"description\":\"Warnings contains a slice of relevant warning subconditions for this object. \\n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.\",\"items\":{\"description\":\"SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \\n It contains a subset of the Condition fields. \\n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \\\"ErrorPresent: true\\\". \\n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.\",\"properties\":{\"message\":{\"description\":\"Message is a human readable message indicating details about the transition. \\n This may be an empty string.\",\"maxLength\":32768,\"type\":\"string\"},\"reason\":{\"description\":\"Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \\n The value should be a CamelCase string. \\n This field may not be empty.\",\"maxLength\":1024,\"minLength\":1,\"pattern\":\"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\",\"type\":\"string\"},\"status\":{\"description\":\"Status of the condition, one of True, False, Unknown.\",\"enum\":[\"True\",\"False\",\"Unknown\"],\"type\":\"string\"},\"type\":{\"description\":\"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \\n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \\n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\",\"maxLength\":316,\"pattern\":\"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\",\"type\":\"string\"}},\"required\":[\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"lastTransitionTime\",\"message\",\"reason\",\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\",\"x-kubernetes-list-map-keys\":[\"type\"],\"x-kubernetes-list-type\":\"map\"}},\"type\":\"object\"}},\"required\":[\"metadata\",\"spec\"],\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]},\"status\":{\"acceptedNames\":{\"kind\":\"\",\"plural\":\"\"},\"conditions\":[],\"storedVersions\":[]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:42Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "projectcontour.io",
        "names": {
          "plural": "tlscertificatedelegations",
          "singular": "tlscertificatedelegation",
          "shortNames": [
            "tlscerts"
          ],
          "kind": "TLSCertificateDelegation",
          "listKind": "TLSCertificateDelegationList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "TLSCertificateDelegation is an TLS Certificate Delegation CRD specification. See design/tls-certificate-delegation.md for details.",
                "type": "object",
                "required": [
                  "metadata",
                  "spec"
                ],
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "TLSCertificateDelegationSpec defines the spec of the CRD",
                    "type": "object",
                    "required": [
                      "delegations"
                    ],
                    "properties": {
                      "delegations": {
                        "type": "array",
                        "items": {
                          "description": "CertificateDelegation maps the authority to reference a secret in the current namespace to a set of namespaces.",
                          "type": "object",
                          "required": [
                            "secretName",
                            "targetNamespaces"
                          ],
                          "properties": {
                            "secretName": {
                              "description": "required, the name of a secret in the current namespace.",
                              "type": "string"
                            },
                            "targetNamespaces": {
                              "description": "required, the namespaces the authority to reference the the secret will be delegated to. If TargetNamespaces is nil or empty, the CertificateDelegation' is ignored. If the TargetNamespace list contains the character, \"*\" the secret will be delegated to all namespaces.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "status": {
                    "description": "TLSCertificateDelegationStatus allows for the status of the delegation to be presented to the user.",
                    "type": "object",
                    "properties": {
                      "conditions": {
                        "description": "Conditions contains information about the current status of the HTTPProxy, in an upstream-friendly container. \n Contour will update a single condition, `Valid`, that is in normal-true polarity. That is, when `currentStatus` is `valid`, the `Valid` condition will be `status: true`, and vice versa. \n Contour will leave untouched any other Conditions set in this block, in case some other controller wants to add a Condition. \n If you are another controller owner and wish to add a condition, you *should* namespace your condition with a label, like `controller.domain.com\\ConditionName`.",
                        "type": "array",
                        "items": {
                          "description": "DetailedCondition is an extension of the normal Kubernetes conditions, with two extra fields to hold sub-conditions, which provide more detailed reasons for the state (True or False) of the condition. \n `errors` holds information about sub-conditions which are fatal to that condition and render its state False. \n `warnings` holds information about sub-conditions which are not fatal to that condition and do not force the state to be False. \n Remember that Conditions have a type, a status, and a reason. \n The type is the type of the condition, the most important one in this CRD set is `Valid`. `Valid` is a positive-polarity condition: when it is `status: true` there are no problems. \n In more detail, `status: true` means that the object is has been ingested into Contour with no errors. `warnings` may still be present, and will be indicated in the Reason field. There must be zero entries in the `errors` slice in this case. \n `Valid`, `status: false` means that the object has had one or more fatal errors during processing into Contour.  The details of the errors will be present under the `errors` field. There must be at least one error in the `errors` slice if `status` is `false`. \n For DetailedConditions of types other than `Valid`, the Condition must be in the negative polarity. When they have `status` `true`, there is an error. There must be at least one entry in the `errors` Subcondition slice. When they have `status` `false`, there are no serious errors, and there must be zero entries in the `errors` slice. In either case, there may be entries in the `warnings` slice. \n Regardless of the polarity, the `reason` and `message` fields must be updated with either the detail of the reason (if there is one and only one entry in total across both the `errors` and `warnings` slices), or `MultipleReasons` if there is more than one entry.",
                          "type": "object",
                          "required": [
                            "lastTransitionTime",
                            "message",
                            "reason",
                            "status",
                            "type"
                          ],
                          "properties": {
                            "errors": {
                              "description": "Errors contains a slice of relevant error subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a error), and disappear when not relevant. An empty slice here indicates no errors.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            },
                            "lastTransitionTime": {
                              "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                              "type": "string",
                              "format": "date-time"
                            },
                            "message": {
                              "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                              "type": "string",
                              "maxLength": 32768
                            },
                            "observedGeneration": {
                              "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                              "type": "integer",
                              "format": "int64",
                              "minimum": 0
                            },
                            "reason": {
                              "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                              "type": "string",
                              "maxLength": 1024,
                              "minLength": 1,
                              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                            },
                            "status": {
                              "description": "status of the condition, one of True, False, Unknown.",
                              "type": "string",
                              "enum": [
                                "True",
                                "False",
                                "Unknown"
                              ]
                            },
                            "type": {
                              "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                              "type": "string",
                              "maxLength": 316,
                              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                            },
                            "warnings": {
                              "description": "Warnings contains a slice of relevant warning subconditions for this object. \n Subconditions are expected to appear when relevant (when there is a warning), and disappear when not relevant. An empty slice here indicates no warnings.",
                              "type": "array",
                              "items": {
                                "description": "SubCondition is a Condition-like type intended for use as a subcondition inside a DetailedCondition. \n It contains a subset of the Condition fields. \n It is intended for warnings and errors, so `type` names should use abnormal-true polarity, that is, they should be of the form \"ErrorPresent: true\". \n The expected lifecycle for these errors is that they should only be present when the error or warning is, and should be removed when they are not relevant.",
                                "type": "object",
                                "required": [
                                  "message",
                                  "reason",
                                  "status",
                                  "type"
                                ],
                                "properties": {
                                  "message": {
                                    "description": "Message is a human readable message indicating details about the transition. \n This may be an empty string.",
                                    "type": "string",
                                    "maxLength": 32768
                                  },
                                  "reason": {
                                    "description": "Reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. \n The value should be a CamelCase string. \n This field may not be empty.",
                                    "type": "string",
                                    "maxLength": 1024,
                                    "minLength": 1,
                                    "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                                  },
                                  "status": {
                                    "description": "Status of the condition, one of True, False, Unknown.",
                                    "type": "string",
                                    "enum": [
                                      "True",
                                      "False",
                                      "Unknown"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type of condition in `CamelCase` or in `foo.example.com/CamelCase`. \n This must be in abnormal-true polarity, that is, `ErrorFound` or `controller.io/ErrorFound`. \n The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                    "type": "string",
                                    "maxLength": 316,
                                    "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "type"
                        ],
                        "x-kubernetes-list-type": "map"
                      }
                    }
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:42Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "tlscertificatedelegations",
          "singular": "tlscertificatedelegation",
          "shortNames": [
            "tlscerts"
          ],
          "kind": "TLSCertificateDelegation",
          "listKind": "TLSCertificateDelegationList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    },
    {
      "metadata": {
        "name": "volumes.longhorn.io",
        "uid": "57d8fea3-74fc-4bd4-9fc7-ebe3aa39c69b",
        "resourceVersion": "825",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:51:33Z",
        "labels": {
          "longhorn-manager": "Volume"
        },
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{},\"labels\":{\"longhorn-manager\":\"Volume\"},\"name\":\"volumes.longhorn.io\"},\"spec\":{\"group\":\"longhorn.io\",\"names\":{\"kind\":\"Volume\",\"listKind\":\"VolumeList\",\"plural\":\"volumes\",\"shortNames\":[\"lhv\"],\"singular\":\"volume\"},\"scope\":\"Namespaced\",\"versions\":[{\"additionalPrinterColumns\":[{\"description\":\"The state of the volume\",\"jsonPath\":\".status.state\",\"name\":\"State\",\"type\":\"string\"},{\"description\":\"The robustness of the volume\",\"jsonPath\":\".status.robustness\",\"name\":\"Robustness\",\"type\":\"string\"},{\"description\":\"The scheduled condition of the volume\",\"jsonPath\":\".status.conditions['scheduled']['status']\",\"name\":\"Scheduled\",\"type\":\"string\"},{\"description\":\"The size of the volume\",\"jsonPath\":\".spec.size\",\"name\":\"Size\",\"type\":\"string\"},{\"description\":\"The node that the volume is currently attaching to\",\"jsonPath\":\".status.currentNodeID\",\"name\":\"Node\",\"type\":\"string\"},{\"jsonPath\":\".metadata.creationTimestamp\",\"name\":\"Age\",\"type\":\"date\"}],\"name\":\"v1beta1\",\"schema\":{\"openAPIV3Schema\":{\"properties\":{\"spec\":{\"x-kubernetes-preserve-unknown-fields\":true},\"status\":{\"x-kubernetes-preserve-unknown-fields\":true}},\"type\":\"object\"}},\"served\":true,\"storage\":true,\"subresources\":{\"status\":{}}}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:51:33Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                },
                "f:labels": {
                  ".": {},
                  "f:longhorn-manager": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:shortNames": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          }
        ]
      },
      "spec": {
        "group": "longhorn.io",
        "names": {
          "plural": "volumes",
          "singular": "volume",
          "shortNames": [
            "lhv"
          ],
          "kind": "Volume",
          "listKind": "VolumeList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1beta1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "type": "object",
                "properties": {
                  "spec": {
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "status": {
                    "x-kubernetes-preserve-unknown-fields": true
                  }
                }
              }
            },
            "subresources": {
              "status": {}
            },
            "additionalPrinterColumns": [
              {
                "name": "State",
                "type": "string",
                "description": "The state of the volume",
                "jsonPath": ".status.state"
              },
              {
                "name": "Robustness",
                "type": "string",
                "description": "The robustness of the volume",
                "jsonPath": ".status.robustness"
              },
              {
                "name": "Scheduled",
                "type": "string",
                "description": "The scheduled condition of the volume",
                "jsonPath": ".status.conditions['scheduled']['status']"
              },
              {
                "name": "Size",
                "type": "string",
                "description": "The size of the volume",
                "jsonPath": ".spec.size"
              },
              {
                "name": "Node",
                "type": "string",
                "description": "The node that the volume is currently attaching to",
                "jsonPath": ".status.currentNodeID"
              },
              {
                "name": "Age",
                "type": "date",
                "jsonPath": ".metadata.creationTimestamp"
              }
            ]
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:51:33Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "volumes",
          "singular": "volume",
          "shortNames": [
            "lhv"
          ],
          "kind": "Volume",
          "listKind": "VolumeList"
        },
        "storedVersions": [
          "v1beta1"
        ]
      }
    },
    {
      "metadata": {
        "name": "volumesnapshotlocations.velero.io",
        "uid": "9edc8cdf-7ec6-4d92-bc29-a11140a05b7f",
        "resourceVersion": "1851",
        "generation": 1,
        "creationTimestamp": "2022-04-11T22:52:55Z",
        "labels": {
          "component": "velero"
        },
        "annotations": {
          "controller-gen.kubebuilder.io/version": "v0.3.0",
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"apiextensions.k8s.io/v1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"annotations\":{\"controller-gen.kubebuilder.io/version\":\"v0.3.0\"},\"creationTimestamp\":null,\"labels\":{\"component\":\"velero\"},\"name\":\"volumesnapshotlocations.velero.io\"},\"spec\":{\"group\":\"velero.io\",\"names\":{\"kind\":\"VolumeSnapshotLocation\",\"listKind\":\"VolumeSnapshotLocationList\",\"plural\":\"volumesnapshotlocations\",\"singular\":\"volumesnapshotlocation\"},\"scope\":\"Namespaced\",\"versions\":[{\"name\":\"v1\",\"schema\":{\"openAPIV3Schema\":{\"description\":\"VolumeSnapshotLocation is a location where Velero stores volume snapshots.\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.\",\"properties\":{\"config\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"Config is for provider-specific configuration fields.\",\"type\":\"object\"},\"provider\":{\"description\":\"Provider is the provider of the volume storage.\",\"type\":\"string\"}},\"required\":[\"provider\"],\"type\":\"object\"},\"status\":{\"description\":\"VolumeSnapshotLocationStatus describes the current status of a Velero VolumeSnapshotLocation.\",\"properties\":{\"phase\":{\"description\":\"VolumeSnapshotLocationPhase is the lifecycle phase of a Velero VolumeSnapshotLocation.\",\"enum\":[\"Available\",\"Unavailable\"],\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"served\":true,\"storage\":true}]}}\n"
        },
        "managedFields": [
          {
            "manager": "Go-http-client",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:status": {
                "f:acceptedNames": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:conditions": {
                  "k:{\"type\":\"Established\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  },
                  "k:{\"type\":\"NamesAccepted\"}": {
                    ".": {},
                    "f:lastTransitionTime": {},
                    "f:message": {},
                    "f:reason": {},
                    "f:status": {},
                    "f:type": {}
                  }
                }
              }
            },
            "subresource": "status"
          },
          {
            "manager": "velero",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:55Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:controller-gen.kubebuilder.io/version": {}
                },
                "f:labels": {
                  ".": {},
                  "f:component": {}
                }
              },
              "f:spec": {
                "f:conversion": {
                  ".": {},
                  "f:strategy": {}
                },
                "f:group": {},
                "f:names": {
                  "f:kind": {},
                  "f:listKind": {},
                  "f:plural": {},
                  "f:singular": {}
                },
                "f:scope": {},
                "f:versions": {}
              }
            }
          },
          {
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "apiVersion": "apiextensions.k8s.io/v1",
            "time": "2022-04-11T22:52:59Z",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              }
            }
          }
        ]
      },
      "spec": {
        "group": "velero.io",
        "names": {
          "plural": "volumesnapshotlocations",
          "singular": "volumesnapshotlocation",
          "kind": "VolumeSnapshotLocation",
          "listKind": "VolumeSnapshotLocationList"
        },
        "scope": "Namespaced",
        "versions": [
          {
            "name": "v1",
            "served": true,
            "storage": true,
            "schema": {
              "openAPIV3Schema": {
                "description": "VolumeSnapshotLocation is a location where Velero stores volume snapshots.",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object"
                  },
                  "spec": {
                    "description": "VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.",
                    "type": "object",
                    "required": [
                      "provider"
                    ],
                    "properties": {
                      "config": {
                        "description": "Config is for provider-specific configuration fields.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "provider": {
                        "description": "Provider is the provider of the volume storage.",
                        "type": "string"
                      }
                    }
                  },
                  "status": {
                    "description": "VolumeSnapshotLocationStatus describes the current status of a Velero VolumeSnapshotLocation.",
                    "type": "object",
                    "properties": {
                      "phase": {
                        "description": "VolumeSnapshotLocationPhase is the lifecycle phase of a Velero VolumeSnapshotLocation.",
                        "type": "string",
                        "enum": [
                          "Available",
                          "Unavailable"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        ],
        "conversion": {
          "strategy": "None"
        }
      },
      "status": {
        "conditions": [
          {
            "type": "NamesAccepted",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "NoConflicts",
            "message": "no conflicts found"
          },
          {
            "type": "Established",
            "status": "True",
            "lastTransitionTime": "2022-04-11T22:52:55Z",
            "reason": "InitialNamesAccepted",
            "message": "the initial names have been accepted"
          }
        ],
        "acceptedNames": {
          "plural": "volumesnapshotlocations",
          "singular": "volumesnapshotlocation",
          "kind": "VolumeSnapshotLocation",
          "listKind": "VolumeSnapshotLocationList"
        },
        "storedVersions": [
          "v1"
        ]
      }
    }
  ]
}
